import type { Table } from 'dexie';
import type { YClientMessage } from 'dexie-cloud-common';
import { DexieCloudDB } from '../db/DexieCloudDB';
import { EntityCommon } from '../db/entities/EntityCommon';
/** Queries the local database for YMessages to send to server.
 *
 * There are 2 messages that this function can provide:
 *   YUpdateFromClientRequest ( for local updates )
 *   YStateVector ( for state vector of foreign updates so that server can reduce the number of udpates to send back )
 *
 * Notice that we do not do a step 1 sync phase here to get a state vector from the server. Reason we can avoid
 * the 2-step sync is that we are client-server and not client-client here and we keep track of the client changes
 * sent to server by letting server acknowledge them. There is always a chance that some client update has already
 * been sent and that the client failed to receive the ack. However, if this happens it does not matter - the change
 * would be sent again and Yjs handles duplicate changes anyway. And it's rare so we earn the cost of roundtrips by
 * avoiding the step1 sync and instead keep track of this in the `unsentFrom` property of the SyncState.
 *
 * @param db
 * @returns
 */
export declare function listYClientMessagesAndStateVector(db: DexieCloudDB, tablesToSync: Table<EntityCommon>[]): Promise<{
    yMessages: YClientMessage[];
    lastUpdateIds: {
        [yTable: string]: number;
    };
}>;
