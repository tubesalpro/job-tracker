import*as e from"yjs";import{Dexie as t,cmp as r,liveQuery as n}from"dexie";const o={}.hasOwnProperty,s=(e,t)=>o.call(e,t),a=[];const i=new FinalizationRegistry((({cache:e,key:t})=>{delete e[t]}));function c(e){var t,r;return null!==(t=(r=e._novip)._docCache)&&void 0!==t?t:r._docCache={cache:{},get size(){return Object.keys(this.cache).length},find(e,t,r){const n=u(e,t,r),o=this.cache[n];return o?o.deref():void 0},add(e){var t;const{parentTable:r,parentId:n,parentProp:o}=e.meta;if(!r||!o||null==n)throw new Error("Missing Dexie-related metadata in Y.Doc");const s=u(r,n,o),a=null===(t=this.cache[s])||void 0===t?void 0:t.deref();a&&i.unregister(a),this.cache[s]=new WeakRef(e),i.register(e,{cache:this.cache,key:s},e)},delete(e){i.unregister(e);const t=u(e.meta.parentTable,e.meta.parentId,e.meta.parentProp),r=this.cache[t];(null==r?void 0:r.deref())===e&&delete this.cache[t]}}}const l=new WeakSet;function d(e){if(l.has(e))throw new Error(`Y.Doc ${e.meta.parentId} has been destroyed`)}function u(e,t,r){return`${e}[${t}].${r}`}function h(t,r,n,o,s,a){let i=r.find(n,a,o);return i||(i=new e.Doc({meta:{db:t,updatesTable:s,parentProp:o,parentTable:n,parentId:a}}),r.add(i),i.on("destroy",(()=>{l.add(i),r.delete(i)})),i)}const{getByKeyPath:p}=t;function f(e,t){let r=Promise.resolve();for(const n of e.tables)for(const o of n.schema.yProps||[])r=r.then((()=>b(e,o,t)));return r}function b(e,{updatesTable:t},n){const o=e.table(t);return Promise.all([o.where("i").startsWith("").toArray(),e.transaction("rw",t,(()=>o.get(0).then((e=>n&&e&&e.lastRun&&e.lastRun.getTime()>Date.now()-n?null:(e=e||{i:0,lastCompressed:0},o.put(Object.assign(Object.assign({},e),{lastRun:new Date})).then((()=>e)))))))]).then((([n,s])=>{if(!s)return;const a=s.lastCompressed,i=Math.min(...n.map((e=>Math.min(e.unsentFrom||1/0,null!=e.receivedUntil?e.receivedUntil+1:1/0))));return o.where("i").between(a,1/0,!1).toArray((n=>{if(0===n.length)return;const s=[];let c=a;for(let e=0;e<n.length;++e){const t=n[e],{i:o,f:a,k:l}=t;if(o>=i&&a&&1&a)break;const d=s.find((e=>0===r(e.docId,l)));d?d.updates.push(t):s.push({docId:l,updates:[t]}),c=o}if(c===a)return;let l=Promise.resolve();for(const{docId:r,updates:n}of s)l=l.then((()=>y(e,t,r,n)));return l.then((()=>e.transaction("rw",o,(()=>o.get(0).then((e=>{if(!(e&&c<=e.lastCompressed))return o.put(Object.assign(Object.assign({},e),{lastCompressed:c}))}))))))}))}))}function y(t,r,n,o){if(o.length<1)throw new Error("Invalid input");return t.transaction("rw",r,(t=>{const s=t.table(r);return s.where({k:n}).first((t=>{if(!t)return;const r=[t].concat(o.filter((e=>e.i!==t.i))),a=new e.Doc({gc:!0});r.forEach((t=>{e.applyUpdateV2(a,t.u)}));const i=e.encodeStateAsUpdateV2(a),c=r.pop();return s.put({i:c.i,k:n,u:i}).then((()=>s.bulkDelete(r.map((e=>e.i)))))}))}))}const m=1e4,w=3e5;let g=null;function v(e){g=e}function T(){}const P=new WeakMap;function D(){return t.Events(null,"load","sync","error")}class E{static getOrCreateDocument(e,t,r,n){var o,s;const a=c(e),i=null===(s=null===(o=e.table(t).schema.yProps)||void 0===o?void 0:o.find((e=>e.prop===r)))||void 0===s?void 0:s.updatesTable;if(!i)throw new Error(`Updates table for ${t}.${r} not found`);return h(e,a,t,r,i,n)}static load(e,t){var r;let n=P.get(e);return n?(++n.refCount,null!=(null==t?void 0:t.gracePeriod)&&n.graceTimeout<t.gracePeriod&&(n.graceTimeout=t.gracePeriod),n.graceTimer&&(clearTimeout(n.graceTimer),n.graceTimer=null)):(n=new E(e),n.graceTimeout=null!==(r=null==t?void 0:t.gracePeriod)&&void 0!==r?r:-1,P.set(e,n)),n}static release(e){if(!e||l.has(e))return;const t=P.get(e);t?--t.refCount<=0&&(t.graceTimeout<0?t._release():t.graceTimer||(t.graceTimer=setTimeout((()=>{t.graceTimer=null,0===t.refCount&&t._release()}),t.graceTimeout))):e.destroy()}_release(){this.doc&&Promise.resolve(E.on("beforeunload").fire(this)).finally((()=>{var e;0===this.refCount&&(null===(e=this.doc)||void 0===e||e.destroy())}))}static for(e){return P.get(e)}static get currentUpdateRow(){return g}get whenLoaded(){return this._whenLoaded||(this._whenLoaded=new Promise(((e,r)=>{this.doc?this.doc.isLoaded?e():this._error?r(this._error):l.has(this.doc)?r(new t.AbortError("Document was destroyed before loaded")):(this.on("load",e),this.on("error",r),this.doc.on("destroy",(()=>r(new t.AbortError("Document was destroyed before loaded"))))):r(new Error("No Y.Doc associated with this provider"))}))),this._whenLoaded}get whenSynced(){return this._whenSynced||(this._whenSynced=new Promise(((e,r)=>{this.doc?this.doc.isSynced?e():this._error?r(this._error):l.has(this.doc)?r(new t.AbortError("Document was destroyed before synced")):(this.on("sync",e),this.on("error",r),this.doc.on("destroy",(()=>r(new t.AbortError("Document was destroyed before synced"))))):r(new Error("No Y.Doc associated with this provider"))}))),this._whenSynced}constructor(t){this.refCount=1,this.cleanupHandlers=[],this.graceTimeout=-1,this.doc=null,this.destroyed=!1,this.on=D(),this.doc=t,this.off=(e,t)=>{var r;return null===(r=this.on[e])||void 0===r?void 0:r.unsubscribe(t)},"dispose"in Symbol&&(this[Symbol.dispose]=()=>E.release(t)),t.on("load",(()=>this.on("load").fire())),t.on("sync",(e=>!1!==e&&this.on("sync").fire())),t.on("destroy",this.destroy.bind(this)),this.on("error",(e=>{this._error=e}));const{db:o,parentTable:s,parentId:a,updatesTable:i}=t.meta||{};if(!o||!s||!i)throw new Error("Missing Dexie-related metadata in Y.Doc. Documents need to be obtained through Y.Doc properties from dexie queries.");if(!o.table(s)||!o.table(i))throw new Error(`Table ${s} or ${i} not found in db`);d(t),this.stopObserving=function(t,o,s,a,i,c){let l=0,u=!0;const h=n((()=>{d(o);const e=s.table(i);return Promise.all([(l>0?e.where("i").between(l,1/0,!1).toArray().then((e=>e.filter((e=>0===r(e.k,c))))):e.where({k:c}).toArray()).then((e=>e)),s.table(a).where(":id").equals(c).toArray()])})).subscribe((([r,n])=>{r.length>0&&(l=r[r.length-1].i),0!==n.length?(d(o),r.length>0&&e.transact(o,(()=>{r.forEach((t=>{try{v(t),e.applyUpdateV2(o,t.u)}finally{v(null)}}))}),t,!1),u&&(u=!1,o.emit("load",[o]))):o.destroy()}),(e=>{t.on("error").fire(e)})),p=(e,r)=>{r!==t&&s.table(i).add({k:c,u:e,f:1}).then((e=>{e===l-1&&++l})).catch((e=>{t.on("error").fire(e)}))},f=()=>{h.unsubscribe(),o.off("updateV2",p),o.off("destroy",f)};return o.on("updateV2",p),o.on("destroy",f),f}(this,t,o,s,i,a),E.on("new").fire(this)}destroy(){var e;P.delete(this.doc),this.doc=null,this.destroyed=!0,this.refCount=0,null===(e=this.stopObserving)||void 0===e||e.call(this),this.on=D(),this.cleanupHandlers.forEach((e=>e()))}addCleanupHandler(e){this.cleanupHandlers.push("function"==typeof e?e:()=>e.unsubscribe())}}E.on=t.Events(null,{new:[function(e,t){return e===T?t:function(){e.apply(this,arguments),t.apply(this,arguments)}}],beforeunload:[function(e,t){return e===T?t:function(){var r=e.apply(this,arguments);if(r&&"function"==typeof r.then){for(var n=this,o=arguments.length,s=new Array(o);o--;)s[o]=arguments[o];return r.then((function(){return t.apply(n,s)}))}return t.apply(this,arguments)}}]}),E.getDocCache=c,t.DexieYProvider?E=t.DexieYProvider||E:t.DexieYProvider=E;const _="yjsMiddleware";function j(e){if("transaction"in e)return k(e,{});{const t=e;return e=>k(e,t)}}function k(t,r){t.Table=class extends t.Table{mapToClass(e){this.schema.yProps&&(e=class extends e{},this.schema.yProps.forEach((({prop:r,updatesTable:n})=>{Object.defineProperty(e.prototype,r,function(e,t,r,n){const o=t.schema.primKey.keyPath;if(!o)throw new Error(`Cannot create Y.Doc property for ${t.name}.${r} because the table has no inbound primary key. See https://dexie.org/docs/inbound`);const s=c(e);return{set(){throw new TypeError("Y.Doc properties are read-only")},get(){const a=p(this,o);return h(e,s,t.name,r,n,a)}}}(t,this,r,n))})));const r=super.mapToClass(e);return this.schema.mappedClass=e,r}},t.Version=class extends t.Version{_createTableSchema(e,t,r){const n=r.filter((e=>"Y"===e.type||"Y.Doc"===e.type));r=r.filter((e=>!n.includes(e)));const o=super._createTableSchema(e,t,r);return n.length>0&&(o.yProps=n.map((t=>({prop:t.name,updatesTable:`$${e}.${t.name}_updates`})))),o}_parseStoresSpec(e,t){super._parseStoresSpec(e,t),Object.keys(e).forEach((e=>{const r=t[e];if(r)for(const e of r.yProps||[])super._parseStoresSpec({[e.updatesTable]:"++i,k"},t)}))}stores(t){const r=this.db,n=super.stores(t),o=r._dbSchema;var i;return Object.keys(o).forEach((e=>{o[e].yProps&&r.table(e).mapToClass(o[e].mappedClass||Object)})),Object.values(o).some((e=>e.yProps))?r.use({stack:"dbcore",name:_,level:50,create:(i=o,t=>Object.assign(Object.assign({},t),{table(r){const n=t.table(r),o=i[r],{yProps:c}=o;return c&&0!==c.length?Object.assign(Object.assign({},n),{mutate(o){if("add"!==o.type&&"put"!==o.type)return n.mutate(o);let i=o;const l=c.map((t=>({p:t,entries:o.values.flatMap(((n,c)=>{if(!n||"object"!=typeof n)throw new TypeError(`Table ${r} (with Y-properties) must only contain objects`);if(!s(n,t.prop))return[];i===o&&(i=Object.assign(Object.assign({},o),{values:o.values.map((e=>Object.assign({},e)))})),delete i.values[c][t.prop];const l=n[t.prop];if(null===l)throw new TypeError("Cannot set Y property to null");if(void 0===l)return a;if("object"!=typeof l||!("whenLoaded"in l))throw new TypeError("Y properties can only be inited with an Y.Doc instance or undefined to create an empty Y.Doc");if("put"===o.type)throw new TypeError(`Setting ${r}.${t.prop} (declared as ${t.prop}:Y) is only allowed when inserting new objects using db.${r}.add(), not put() or update().`);return 1===e.encodeStateVector(l).length?a:{iter:c,u:e.encodeStateAsUpdateV2(l)}}))}))).filter((({entries:e})=>e.length>0));return o===i?n.mutate(o):n.mutate(i).then((e=>0===l.length?e:Promise.all(l.map((({p:r,entries:n})=>{const s=t.table(r.updatesTable),a=n.map((({iter:t,u:r})=>({k:e.results[t],u:r,f:1})));return s.mutate({type:"add",values:a,trans:o.trans})}))).then((()=>e))))}}):n}}))}):r.unuse({stack:"dbcore",name:_}),n}},!1!==(null==r?void 0:r.gc)&&function(e){let t=null;e.on("ready",(e=>{if(e.tables.some((e=>e.schema.yProps))){const r=()=>{e.isOpen()&&f(e,w).catch((e=>{!e||e.name})).then((()=>{t=setTimeout(r,w)}))};t=setTimeout(r,m)}}),!0),e.on("close",(()=>{t&&clearTimeout(t),t=null}))}(t)}export{E as DexieYProvider,f as compressYDocs,j as default};
//# sourceMappingURL=y-dexie.min.js.map
