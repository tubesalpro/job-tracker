/* ========================================================================== 
 *                           y-dexie.js
 * ==========================================================================
 *
 * Dexie addon that integrates Dexie with Y.js
 *
 * By David Fahlander, david@dexie.org
 *
 * ==========================================================================
 *
 * Version 4.2.2, Tue Dec 09 2025
 *
 * https://dexie.org
 *
 * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/
 * 
 */

import * as Y from 'yjs';
import { Dexie, cmp, liveQuery } from 'dexie';

const _hasOwn = {}.hasOwnProperty;
const hasOwn = (obj, prop) => {
    return _hasOwn.call(obj, prop);
};

const EMPTY_ARRAY = []; // Optimization of returning empty array frequently in flatMap operaion.
function createYjsMiddleware(dbSchema) {
    return (downCore) => (Object.assign(Object.assign({}, downCore), { table(tableName) {
            const downTable = downCore.table(tableName);
            const dbTableSchema = dbSchema[tableName]; // DBCore don't understand Yjs specific schema - need dexie xchema
            const { yProps } = dbTableSchema;
            if (!yProps || yProps.length === 0)
                return downTable;
            const tableMiddleware = Object.assign(Object.assign({}, downTable), { mutate(req) {
                    if (req.type !== 'add' && req.type !== 'put')
                        return downTable.mutate(req);
                    // From here on, req.type is "add":
                    let reqClone = req;
                    const updateSources = yProps
                        .map((p) => ({
                        p,
                        entries: req.values.flatMap((value, iter) => {
                            if (!value || typeof value !== 'object')
                                throw new TypeError(`Table ${tableName} (with Y-properties) must only contain objects`);
                            if (!hasOwn(value, p.prop))
                                return [];
                            // Clone req, req.values and each value so that we can delete yProps from being stored:
                            if (reqClone === req)
                                reqClone = Object.assign(Object.assign({}, req), { values: req.values.map((v) => (Object.assign({}, v))) });
                            // Delete prop so that it isn't physically stored in DB
                            delete reqClone.values[iter][p.prop];
                            const doc = value[p.prop];
                            if (doc === null)
                                throw new TypeError(`Cannot set Y property to null`);
                            // Allow undefined, treat it as if the object didn't have the property at all.
                            if (doc === undefined)
                                return EMPTY_ARRAY;
                            // Check that the property is of type Y.Doc:
                            if (typeof doc !== 'object' || !('whenLoaded' in doc)) {
                                throw new TypeError(`Y properties can only be inited with an Y.Doc instance or undefined to create an empty Y.Doc`);
                            }
                            if (req.type === 'put')
                                // Don't allow setting y properties on put requests
                                throw new TypeError(`Setting ${tableName}.${p.prop} (declared as ${p.prop}:Y) is only allowed when inserting new objects using db.${tableName}.add(), not put() or update().`);
                            if (Y.encodeStateVector(doc).length === 1) {
                                // Document is empty and has no updates
                                return EMPTY_ARRAY;
                            }
                            // Clone the Yjs state before storing it in the database
                            return {
                                iter,
                                u: Y.encodeStateAsUpdateV2(doc),
                            };
                        }),
                    }))
                        .filter(({ entries }) => entries.length > 0);
                    if (req === reqClone)
                        // No object had their Y-props in own props - no need to intercept.
                        return downTable.mutate(req);
                    // We have a reqClone to forward down the stack. The reqClone
                    // is a copy of req, but where some objects have their yProps deleted.
                    return downTable.mutate(reqClone).then((res) => {
                        if (updateSources.length === 0)
                            // No updates to create (but user provided empty Y.Docs so reqClone was still needed)
                            return res;
                        // For each yProp affect, write docs (monolit-updates) to their corresponding tables.
                        return Promise.all(updateSources.map(({ p, entries }) => {
                            const updatesTable = downCore.table(p.updatesTable);
                            const updatesToInsert = entries.map(({ iter, u }) => ({
                                k: res.results[iter],
                                u,
                                f: 1, // Flag as local update (to be included when syncing)
                            }));
                            return updatesTable.mutate({
                                type: 'add',
                                values: updatesToInsert,
                                trans: req.trans,
                            });
                        })).then(() => res);
                    });
                } });
            return tableMiddleware;
        } }));
}

// The finalization registry
const docRegistry = new FinalizationRegistry(({ cache, key }) => {
    delete cache[key];
});
// The Y.Doc cache containing all active documents
function getDocCache(db) {
    var _a;
    var _b;
    return (_a = (_b = db._novip)['_docCache']) !== null && _a !== void 0 ? _a : (_b['_docCache'] = {
        cache: {},
        get size() {
            return Object.keys(this.cache).length;
        },
        find(table, primaryKey, ydocProp) {
            const cacheKey = getYDocCacheKey(table, primaryKey, ydocProp);
            const docRef = this.cache[cacheKey];
            return docRef ? docRef.deref() : undefined;
        },
        add(doc) {
            var _a;
            const { parentTable, parentId, parentProp } = doc.meta;
            if (!parentTable || !parentProp || parentId == null)
                throw new Error(`Missing Dexie-related metadata in Y.Doc`);
            const cacheKey = getYDocCacheKey(parentTable, parentId, parentProp);
            const existingDoc = (_a = this.cache[cacheKey]) === null || _a === void 0 ? void 0 : _a.deref();
            if (existingDoc) {
                docRegistry.unregister(existingDoc); // Don't run garbage collection on this doc as it is being replaced.
            }
            this.cache[cacheKey] = new WeakRef(doc);
            docRegistry.register(doc, { cache: this.cache, key: cacheKey }, doc);
        },
        delete(doc) {
            docRegistry.unregister(doc); // Don't run garbage collection on this doc as it is being deleted here and now.
            const cacheKey = getYDocCacheKey(doc.meta.parentTable, doc.meta.parentId, doc.meta.parentProp);
            const cacheEntry = this.cache[cacheKey];
            if ((cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.deref()) === doc) {
                delete this.cache[cacheKey]; // Remove the entry from the cache only if it is the same doc.
            }
        },
    });
}
// Emulate a private boolean property "destroyed" on Y.Doc instances that we manage
// in createYDocProperty.ts:
const destroyedDocs = new WeakSet();
function throwIfDestroyed(doc) {
    if (destroyedDocs.has(doc))
        throw new Error(`Y.Doc ${doc.meta.parentId} has been destroyed`);
}
function getYDocCacheKey(table, primaryKey, ydocProp) {
    return `${table}[${primaryKey}].${ydocProp}`;
}

function getOrCreateDocument(db, docCache, tableName, prop, updatesTable, id) {
    let doc = docCache.find(tableName, id, prop);
    if (doc)
        return doc;
    doc = new Y.Doc({
        meta: {
            db,
            updatesTable,
            parentProp: prop,
            parentTable: tableName,
            parentId: id,
        },
    });
    docCache.add(doc);
    doc.on('destroy', () => {
        destroyedDocs.add(doc);
        docCache.delete(doc);
    });
    return doc;
}

const { getByKeyPath } = Dexie;
function createYDocProperty(db, table, prop, updatesTable) {
    const pkKeyPath = table.schema.primKey.keyPath;
    if (!pkKeyPath) {
        throw new Error(`Cannot create Y.Doc property for ${table.name}.${prop} because the table has no inbound primary key. See https://dexie.org/docs/inbound`);
    }
    const docCache = getDocCache(db);
    return {
        set() {
            throw new TypeError(`Y.Doc properties are read-only`);
        },
        get() {
            const id = getByKeyPath(this, pkKeyPath);
            return getOrCreateDocument(db, docCache, table.name, prop, updatesTable, id);
        },
    };
}

/** Go through all Y.Doc tables in the entire local db and compress updates
 *
 * @param db Dexie
 * @returns
 */
function compressYDocs(db, skipIfRecentlyDoneMillisec) {
    let p = Promise.resolve();
    for (const table of db.tables) {
        for (const yProp of table.schema.yProps || []) {
            p = p.then(() => compressYDocsTable(db, yProp, skipIfRecentlyDoneMillisec));
        }
    }
    return p;
}
/** Compress an individual Y.Doc table */
function compressYDocsTable(db, { updatesTable }, skipIfRunnedSince // milliseconds
) {
    const updTbl = db.table(updatesTable);
    return Promise.all([
        // syncers (for example dexie-cloud-addon or other 3rd part syncers) They may have unsentFrom set.
        updTbl
            .where('i')
            .startsWith('') // Syncers have string primary keys while updates have auto-incremented numbers.
            .toArray(),
        // lastCompressed (pointer to the last compressed update)
        db.transaction('rw', updatesTable, () => updTbl.get(0).then((lastCompressed) => {
            if (skipIfRunnedSince &&
                lastCompressed &&
                lastCompressed.lastRun &&
                lastCompressed.lastRun.getTime() > Date.now() - skipIfRunnedSince) {
                // Skip it. It has run recently or is still running.
                return null;
            }
            // isRunning might be true but we don't respect it if started before skipIfRunningSince.
            lastCompressed = lastCompressed || { i: 0, lastCompressed: 0 };
            return updTbl
                .put(Object.assign(Object.assign({}, lastCompressed), { lastRun: new Date() }))
                .then(() => lastCompressed);
        })),
    ]).then(([syncers, stamp]) => {
        if (!stamp)
            return; // Skip. Already running.
        const lastCompressedUpdate = stamp.lastCompressed;
        const unsyncedFrom = Math.min(...syncers.map((s) => Math.min(s.unsentFrom || Infinity, s.receivedUntil != null ? s.receivedUntil + 1 : Infinity)));
        // Per updates-table:
        // 1. Find all updates after lastCompressedId. Run toArray() on them.
        // 2. IF there are any "mine" (flagged) updates AFTER unsentFrom, skip all from including this entry, else include all regardless of unsentFrom.
        // 3. Now we know which keys have updates since last compression. We also know how far we're gonna go (max unsentFrom unless all additional updates are foreign).
        // 4. For every key that had updates, load their main update (this is one single update per key before the lastCompressedId marker)
        // 5. For every key that had updates: Compress main update along with additional updates until and including the number that was computed on step 2 (could be Infinity).
        // 6. Update lastCompressedId to the i of the latest compressed entry.
        return updTbl
            .where('i')
            .between(lastCompressedUpdate, Infinity, false)
            .toArray((addedUpdates) => {
            if (addedUpdates.length === 0)
                return; // No more updates where added
            const docsToCompress = [];
            let lastUpdateToCompress = lastCompressedUpdate;
            for (let j = 0; j < addedUpdates.length; ++j) {
                const updateRow = addedUpdates[j];
                const { i, f, k } = updateRow;
                if (i >= unsyncedFrom && f && f & 0x01)
                    break; // An update that need to be synced was found. Stop here and let dontCompressFrom stay.
                const entry = docsToCompress.find((entry) => cmp(entry.docId, k) === 0);
                if (entry)
                    entry.updates.push(updateRow);
                else
                    docsToCompress.push({ docId: k, updates: [updateRow] });
                lastUpdateToCompress = i;
            }
            if (lastUpdateToCompress === lastCompressedUpdate)
                return; // No updates to compress
            let p = Promise.resolve();
            for (const { docId, updates } of docsToCompress) {
                p = p.then(() => compressUpdatesForDoc(db, updatesTable, docId, updates));
            }
            return p.then(() => {
                // Update lastCompressed atomically to the value we computed.
                // Do it with respect to the case when another job was done in parallel
                // that maybe compressed one or more extra updates and updated lastCompressed
                // before us.
                return db.transaction('rw', updTbl, () => updTbl.get(0).then((current) => {
                    if (current && lastUpdateToCompress <= current.lastCompressed) {
                        // No need to update. Nothing was done, or another job did more.
                        return;
                    }
                    return updTbl.put(Object.assign(Object.assign({}, current), { lastCompressed: lastUpdateToCompress }));
                }));
            });
        });
    });
}
function compressUpdatesForDoc(db, updatesTable, parentId, addedUpdatesToCompress) {
    if (addedUpdatesToCompress.length < 1)
        throw new Error('Invalid input');
    return db.transaction('rw', updatesTable, (tx) => {
        const updTbl = tx.table(updatesTable);
        return updTbl.where({ k: parentId }).first((mainUpdate) => {
            if (!mainUpdate)
                return; // No main update found. Nothing to compress.
            const updates = [mainUpdate].concat(addedUpdatesToCompress.filter((u) => u.i !== mainUpdate.i)); // avoid duplicating the main update (can happen sometimes)
            const doc = new Y.Doc({ gc: true });
            updates.forEach((update) => {
                Y.applyUpdateV2(doc, update.u);
            });
            const compressedUpdate = Y.encodeStateAsUpdateV2(doc);
            const lastUpdate = updates.pop();
            return updTbl
                .put({
                i: lastUpdate.i,
                k: parentId,
                u: compressedUpdate,
            })
                .then(() => updTbl.bulkDelete(updates.map((update) => update.i)));
        });
    });
}

const GC_DELAY = 10000; // Delay before starting GC when DB is started
const GC_INTERVAL = 300000; // Every 5 minutes
function periodicGC(db) {
    let timer = null;
    db.on('ready', (db) => {
        if (db.tables.some(tbl => tbl.schema.yProps)) {
            const gc = () => {
                if (!db.isOpen())
                    return;
                compressYDocs(db, GC_INTERVAL).catch(err => {
                    if (err && err.name === 'DatabaseClosedError')
                        return;
                    console.debug('Error during periodic GC', err);
                }).then(() => {
                    timer = setTimeout(gc, GC_INTERVAL);
                });
            };
            timer = setTimeout(gc, GC_DELAY);
        }
    }, true);
    db.on('close', () => {
        if (timer)
            clearTimeout(timer);
        timer = null;
    });
}

let currentUpdateRow = null;
function setCurrentUpdateRow(row) {
    currentUpdateRow = row;
}

function observeYDocUpdates(provider, doc, db, parentTableName, updatesTableName, parentId) {
    let lastUpdateId = 0;
    let initial = true;
    const subscription = liveQuery(() => {
        throwIfDestroyed(doc);
        const updatesTable = db.table(updatesTableName);
        return Promise.all([
            (lastUpdateId > 0
                ? updatesTable
                    .where('i')
                    .between(lastUpdateId, Infinity, false)
                    .toArray()
                    .then((updates) => updates.filter((update) => cmp(update.k, parentId) === 0))
                : updatesTable.where({ k: parentId }).toArray()).then((updates) => {
                return updates;
            }),
            db.table(parentTableName).where(':id').equals(parentId).toArray(), // Why not just count() or get()? Because of cache only works with toArray() currently (optimization)
        ]);
    }).subscribe(([updates, parentRow]) => {
        if (updates.length > 0)
            lastUpdateId = updates[updates.length - 1].i;
        if (parentRow.length === 0) {
            // Row deleted. Destroy Y.Doc.
            doc.destroy();
            return;
        }
        throwIfDestroyed(doc);
        if (updates.length > 0) {
            Y.transact(doc, () => {
                updates.forEach((update) => {
                    try {
                        setCurrentUpdateRow(update);
                        Y.applyUpdateV2(doc, update.u);
                    }
                    finally {
                        setCurrentUpdateRow(null);
                    }
                });
            }, provider, false);
        }
        if (initial) {
            initial = false;
            doc.emit('load', [doc]);
        }
    }, (error) => {
        provider.on('error').fire(error);
    });
    const onUpdate = (update, origin) => {
        if (origin === provider)
            return; // Already applied.
        db.table(updatesTableName)
            .add({
            k: parentId,
            u: update,
            f: 1, // Flag as local update (to be included when syncing)
        })
            .then((i) => {
            // Optimization (not critical): Don't query for this update to put it back into the doc.
            // However, skip this optimization if the lastUpdateId is behind the current update.
            // In that case, next liveQuery emission will include also this update and re-apply it into doc,
            // but it will not be an issue because Y.Doc will ignore duplicate updates.
            if (i === lastUpdateId - 1)
                ++lastUpdateId;
        })
            .catch((error) => {
            provider.on('error').fire(error);
        });
    };
    const stopObserving = () => {
        subscription.unsubscribe();
        doc.off('updateV2', onUpdate);
        doc.off('destroy', stopObserving);
    };
    doc.on('updateV2', onUpdate);
    doc.on('destroy', stopObserving);
    return stopObserving;
}

function nop() { }

function promisableChain(f1, f2) {
    if (f1 === nop)
        return f2;
    return function () {
        var res = f1.apply(this, arguments);
        if (res && typeof res.then === 'function') {
            var thiz = this, i = arguments.length, args = new Array(i);
            while (i--)
                args[i] = arguments[i];
            return res.then(function () {
                return f2.apply(thiz, args);
            });
        }
        return f2.apply(this, arguments);
    };
}

function nonStoppableEventChain(f1, f2) {
    if (f1 === nop)
        return f2;
    return function () {
        f1.apply(this, arguments);
        f2.apply(this, arguments);
    };
}

const wm = new WeakMap();
function createEvents() {
    return Dexie.Events(null, 'load', 'sync', 'error');
}
class DexieYProvider {
    static getOrCreateDocument(db, table, prop, id) {
        var _a, _b;
        const docCache = getDocCache(db);
        const updatesTable = (_b = (_a = db
            .table(table)
            .schema.yProps) === null || _a === void 0 ? void 0 : _a.find((p) => p.prop === prop)) === null || _b === void 0 ? void 0 : _b.updatesTable;
        if (!updatesTable) {
            throw new Error(`Updates table for ${table}.${prop} not found`);
        }
        // Get or create the Y.Doc for the given table, prop, and id
        return getOrCreateDocument(db, docCache, table, prop, updatesTable, id);
    }
    static load(doc, options) {
        var _a;
        let p = wm.get(doc);
        if (p) {
            ++p.refCount;
            if ((options === null || options === void 0 ? void 0 : options.gracePeriod) != null &&
                p.graceTimeout < options.gracePeriod) {
                p.graceTimeout = options.gracePeriod;
            }
            if (p.graceTimer) {
                clearTimeout(p.graceTimer);
                p.graceTimer = null;
            }
        }
        else {
            p = new DexieYProvider(doc);
            p.graceTimeout = (_a = options === null || options === void 0 ? void 0 : options.gracePeriod) !== null && _a !== void 0 ? _a : -1;
            wm.set(doc, p);
        }
        return p;
    }
    static release(doc) {
        if (!doc || destroyedDocs.has(doc))
            return; // Document already destroyed.
        const p = wm.get(doc);
        if (p) {
            // There is a provider connected to the doc
            if (--p.refCount <= 0) {
                // No references to this provider anymore. Time to release it.
                if (p.graceTimeout < 0) {
                    // No grace period here or from previous release. Release immediately.
                    p._release();
                }
                else if (!p.graceTimer) {
                    p.graceTimer = setTimeout(() => {
                        p.graceTimer = null;
                        if (p.refCount === 0) {
                            // Release only if refCount is still zero
                            p._release();
                        }
                    }, p.graceTimeout // Grace period to optimize for unload/reload scenarios
                    );
                }
            }
        }
        else {
            doc.destroy();
        }
    }
    _release() {
        // Allow a listener to beforeunload event to execute while the provider and the document
        // are still alive and loaded if it needs to compute something from the full document.
        // Also, in case the event listener uses DexieYProvider.load() without calling DexieYProvider.release(),
        // it must prevent the release to happen until the provider is finally released.
        if (!this.doc)
            return;
        Promise.resolve(DexieYProvider.on('beforeunload').fire(this)).finally(() => {
            var _a;
            // Re-check that refCount is zero before actually destroying the document (which
            // leads to provider.destroy() through the destroy-event on the doc).
            if (this.refCount === 0) {
                (_a = this.doc) === null || _a === void 0 ? void 0 : _a.destroy();
            }
            // If refCount is not zero, it means that DexieYProvider.load() has been called from the listener
            // and the listener has prevented the release from happening. The listener must call DexieYProvider.release()
            // when it's done with the document.
        });
    }
    static for(doc) {
        return wm.get(doc);
    }
    static get currentUpdateRow() {
        return currentUpdateRow;
    }
    // Use a getter to avoid unhandled rejections when no one bothers about it.
    get whenLoaded() {
        if (!this._whenLoaded) {
            this._whenLoaded = new Promise((resolve, reject) => {
                if (!this.doc) {
                    reject(new Error('No Y.Doc associated with this provider'));
                    return;
                }
                if (this.doc.isLoaded)
                    resolve();
                else if (this._error)
                    reject(this._error);
                else if (destroyedDocs.has(this.doc)) {
                    reject(new Dexie.AbortError('Document was destroyed before loaded'));
                }
                else {
                    this.on('load', resolve);
                    this.on('error', reject);
                    this.doc.on('destroy', () => reject(new Dexie.AbortError('Document was destroyed before loaded')));
                }
            });
        }
        return this._whenLoaded;
    }
    // Use a getter to avoid unhandled rejections when no one bothers about it.
    get whenSynced() {
        if (!this._whenSynced) {
            this._whenSynced = new Promise((resolve, reject) => {
                if (!this.doc) {
                    reject(new Error('No Y.Doc associated with this provider'));
                    return;
                }
                if (this.doc.isSynced)
                    resolve();
                else if (this._error)
                    reject(this._error);
                else if (destroyedDocs.has(this.doc)) {
                    reject(new Dexie.AbortError('Document was destroyed before synced'));
                }
                else {
                    this.on('sync', resolve);
                    this.on('error', reject);
                    this.doc.on('destroy', () => reject(new Dexie.AbortError('Document was destroyed before synced')));
                }
            });
        }
        return this._whenSynced;
    }
    constructor(doc) {
        this.refCount = 1;
        this.cleanupHandlers = [];
        this.graceTimeout = -1;
        this.doc = null;
        this.destroyed = false;
        this.on = createEvents();
        this.doc = doc;
        this.off = (name, f) => { var _a; return (_a = this.on[name]) === null || _a === void 0 ? void 0 : _a.unsubscribe(f); };
        if ('dispose' in Symbol) {
            // @ts-ignore
            this[Symbol.dispose] = () => DexieYProvider.release(doc);
        }
        doc.on('load', () => this.on('load').fire());
        doc.on('sync', (sync) => sync !== false && this.on('sync').fire());
        doc.on('destroy', this.destroy.bind(this));
        this.on('error', (error) => {
            // In case error happens before awaiting provider.whenLoaded or provider.whenSynced.
            this._error = error;
        });
        const { db, parentTable, parentId, updatesTable } = doc.meta || {};
        if (!db || !parentTable || !updatesTable) {
            throw new Error(`Missing Dexie-related metadata in Y.Doc. Documents need to be obtained through Y.Doc properties from dexie queries.`);
        }
        // This doc is from Dexie
        if (!db.table(parentTable) || !db.table(updatesTable)) {
            throw new Error(`Table ${parentTable} or ${updatesTable} not found in db`);
        }
        throwIfDestroyed(doc);
        this.stopObserving = observeYDocUpdates(this, doc, db, parentTable, updatesTable, parentId);
        DexieYProvider.on("new").fire(this); // Allow for addons to invoke their sync- and awareness providers here.
    }
    destroy() {
        var _a, _b, _c;
        console.debug(`Y.Doc ${(_b = (_a = this.doc) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.parentId} was destroyed`);
        wm.delete(this.doc);
        this.doc = null;
        this.destroyed = true;
        this.refCount = 0;
        (_c = this.stopObserving) === null || _c === void 0 ? void 0 : _c.call(this);
        this.on = createEvents(); // Releases listeners for GC
        this.cleanupHandlers.forEach((cleanup) => cleanup());
    }
    addCleanupHandler(cleanupHandler) {
        this.cleanupHandlers.push(typeof cleanupHandler === 'function'
            ? cleanupHandler
            : () => cleanupHandler.unsubscribe());
    }
}
DexieYProvider.on = Dexie.Events(null, {
    new: [nonStoppableEventChain],
    beforeunload: [promisableChain],
});
DexieYProvider.getDocCache = getDocCache;
//
// Eliminate dual package hazard 
//
// Since we're holding static state, make sure to singletonize DexieYProvider
//
if (Dexie["DexieYProvider"]) {
    // @ts-ignore
    DexieYProvider = Dexie["DexieYProvider"] || DexieYProvider;
}
else {
    Dexie["DexieYProvider"] = DexieYProvider;
}

const YJS_MIDDLEWARE_NAME = 'yjsMiddleware';
function yDexie(dbOrOptions) {
    // This function is a placeholder for the y-dexie addon.
    // It can be used to initialize or configure the addon as needed.
    if (!('transaction' in dbOrOptions)) {
        // If db is an options object, create a configured yDexie addon that
        // could be passed to the addons array of Dexie constructor.
        const options = dbOrOptions;
        // Return a configured Dexie addon function.
        return (db) => configurableYDexie(db, options);
    }
    else {
        // If db is a Dexie instance, it is being called as an addon.
        // Do default configuration.
        return configurableYDexie(dbOrOptions, {});
    }
}
function configurableYDexie(db, options) {
    db.Table = class Table extends db.Table {
        mapToClass(constructor) {
            if (this.schema.yProps) {
                constructor = class extends constructor {
                };
                this.schema.yProps.forEach(({ prop, updatesTable }) => {
                    Object.defineProperty(constructor.prototype, prop, createYDocProperty(db, this, prop, updatesTable));
                });
            }
            const result = super.mapToClass(constructor);
            this.schema.mappedClass = constructor; // Also done in super.mapToClass but we need to set the user-provided class, not our altered class.
            return result;
        }
    };
    db.Version = class Version extends db.Version {
        _createTableSchema(name, primKey, indexes) {
            const yProps = indexes.filter((idx) => idx.type === 'Y' || idx.type === 'Y.Doc');
            indexes = indexes.filter((idx) => !yProps.includes(idx)); // Y marks just the Y.Doc type and is not an index
            const tableSchema = super._createTableSchema(name, primKey, indexes);
            if (yProps.length > 0) {
                tableSchema.yProps = yProps.map((idx) => ({
                    prop: idx.name,
                    updatesTable: `$${name}.${idx.name}_updates`,
                }));
            }
            return tableSchema;
        }
        _parseStoresSpec(stores, outSchema) {
            // Implementation for parsing stores spec
            // This is a placeholder; actual implementation would go here
            super._parseStoresSpec(stores, outSchema);
            // Generate update tables for Y.js properties
            Object.keys(stores).forEach((tableName) => {
                const tblSchema = outSchema[tableName];
                if (tblSchema) {
                    for (const yProp of tblSchema.yProps || []) {
                        super._parseStoresSpec(
                        // Add a table for each yProp containing document updates.
                        // See interface YUpdateRow { i: number, k: IndexableType, u: Uint8Array, f?: number}
                        // where
                        //   i is the auto-incremented primary key of the update table,
                        //   k is the primary key from the other table holding the document in a property.
                        //   u is the update data from Y.js
                        //   f is a flag indicating if the update comes from this client or another.
                        // Index use cases:
                        //   * Load entire document: Use index k
                        //   * After object load, observe updates on a certain document since a given revision: Use index k or i since [k+i] is not supported before Firefox 126.
                        //   * After initial sync, observe flagged updates since a given revision: Use index i and ignore unflagged.
                        //     Could be using an index [f+i] but that wouldn't gain too much and Firefox before 126 doesnt support it.
                        //     Local updates are flagged while remote updates are not.
                        //
                        { [yProp.updatesTable]: '++i,k' }, outSchema);
                    }
                }
            });
        }
        stores(schema) {
            const db = this.db;
            // This method is used to define the schema for the database.
            // It allows you to specify the tables and their indexes.
            const result = super.stores(schema);
            const dbschema = db._dbSchema;
            Object.keys(dbschema).forEach((tableName) => {
                if (dbschema[tableName].yProps) {
                    // If a table as yProps, make sure to derive a class with generated Y properties.
                    // This is done in the mapToClass method. In case user has called mapToClass already, respect mappedClass,
                    // otherwise use Object as default to create a top-level class with the generated y properties.
                    db.table(tableName).mapToClass(dbschema[tableName].mappedClass || Object);
                }
            });
            if (Object.values(dbschema).some((table) => table.yProps)) {
                db.use({
                    stack: 'dbcore',
                    name: YJS_MIDDLEWARE_NAME,
                    level: 50,
                    create: createYjsMiddleware(dbschema),
                });
            }
            else {
                db.unuse({ stack: 'dbcore', name: YJS_MIDDLEWARE_NAME });
            }
            return result;
        }
    };
    if ((options === null || options === void 0 ? void 0 : options.gc) !== false) {
        periodicGC(db);
    }
}

export { DexieYProvider, compressYDocs, yDexie as default };
//# sourceMappingURL=y-dexie.js.map
