{"version":3,"file":"y-dexie.min.js","sources":["../src/helpers/hasOwn.ts","../src/createYjsMiddleware.ts","../src/docCache.ts","../src/getOrCreateDocument.ts","../src/createYDocProperty.ts","../src/compressYDocs.ts","../src/periodicGC.ts","../src/currentUpdateRow.ts","../src/helpers/nop.ts","../src/DexieYProvider.ts","../src/observeYDocUpdates.ts","../src/helpers/nonStoppableEventChain.ts","../src/helpers/promisableChain.ts","../src/y-dexie.ts"],"sourcesContent":["const _hasOwn = {}.hasOwnProperty;\nexport const hasOwn = (obj: object, prop: PropertyKey): boolean => {\n  return _hasOwn.call(obj, prop);\n};\n","import { DBCore, DBCoreTable, DBCoreMutateResponse } from 'dexie';\nimport * as Y from 'yjs';\nimport { DbSchema } from 'dexie';\nimport { YUpdateRow } from './types/YUpdateRow';\nimport { hasOwn } from './helpers/hasOwn';\n\nconst EMPTY_ARRAY = [] as const; // Optimization of returning empty array frequently in flatMap operaion.\n\nexport function createYjsMiddleware(dbSchema: DbSchema) {\n  return (downCore: DBCore) =>\n    ({\n      ...downCore,\n      table(tableName: string) {\n        const downTable = downCore.table(tableName);\n        const dbTableSchema = dbSchema[tableName]; // DBCore don't understand Yjs specific schema - need dexie xchema\n        const { yProps } = dbTableSchema;\n        if (!yProps || yProps.length === 0) return downTable;\n        const tableMiddleware: DBCoreTable = {\n          ...downTable,\n          mutate(req): Promise<DBCoreMutateResponse> {\n            if (req.type !== 'add' && req.type !== 'put')\n              return downTable.mutate(req);\n            // From here on, req.type is \"add\":\n            let reqClone = req;\n            const updateSources = yProps\n              .map((p) => ({\n                p,\n                entries: req.values.flatMap<{\n                  // Instead of map().filter() we use flatMap() to avoid creating intermediate arrays.\n                  iter: number;\n                  u: Uint8Array;\n                }>((value, iter) => {\n                  if (!value || typeof value !== 'object')\n                    throw new TypeError(\n                      `Table ${tableName} (with Y-properties) must only contain objects`\n                    );\n                  if (!hasOwn(value, p.prop)) return [];\n                  // Clone req, req.values and each value so that we can delete yProps from being stored:\n                  if (reqClone === req)\n                    reqClone = {\n                      ...req,\n                      values: req.values.map((v) => ({ ...v })),\n                    };\n                  // Delete prop so that it isn't physically stored in DB\n                  delete reqClone.values[iter][p.prop];\n\n                  const doc = value[p.prop] as Y.Doc | undefined | null;\n                  if (doc === null)\n                    throw new TypeError(`Cannot set Y property to null`);\n                  // Allow undefined, treat it as if the object didn't have the property at all.\n                  if (doc === undefined) return EMPTY_ARRAY;\n                  // Check that the property is of type Y.Doc:\n                  if (typeof doc !== 'object' || !('whenLoaded' in doc)) {\n                    throw new TypeError(\n                      `Y properties can only be inited with an Y.Doc instance or undefined to create an empty Y.Doc`\n                    );\n                  }\n                  if (req.type === 'put')\n                    // Don't allow setting y properties on put requests\n                    throw new TypeError(\n                      `Setting ${tableName}.${p.prop} (declared as ${p.prop}:Y) is only allowed when inserting new objects using db.${tableName}.add(), not put() or update().`\n                    );\n                  if (Y.encodeStateVector(doc).length === 1) {\n                    // Document is empty and has no updates\n                    return EMPTY_ARRAY;\n                  }\n                  // Clone the Yjs state before storing it in the database\n                  return {\n                    iter,\n                    u: Y.encodeStateAsUpdateV2(doc),\n                  };\n                }),\n              }))\n              .filter(({ entries }) => entries.length > 0);\n            if (req === reqClone)\n              // No object had their Y-props in own props - no need to intercept.\n              return downTable.mutate(req);\n\n            // We have a reqClone to forward down the stack. The reqClone\n            // is a copy of req, but where some objects have their yProps deleted.\n            return downTable.mutate(reqClone).then((res) => {\n              if (updateSources.length === 0)\n                // No updates to create (but user provided empty Y.Docs so reqClone was still needed)\n                return res;\n              // For each yProp affect, write docs (monolit-updates) to their corresponding tables.\n              return Promise.all(\n                updateSources.map(({ p, entries }) => {\n                  const updatesTable = downCore.table(p.updatesTable);\n                  const updatesToInsert: Omit<YUpdateRow, 'i'>[] = entries.map(\n                    ({ iter, u }) =>\n                      ({\n                        k: res.results![iter],\n                        u,\n                        f: 1, // Flag as local update (to be included when syncing)\n                      } satisfies Omit<YUpdateRow, 'i'>)\n                  );\n                  return updatesTable.mutate({\n                    type: 'add',\n                    values: updatesToInsert,\n                    trans: req.trans,\n                  });\n                })\n              ).then(() => res);\n            });\n          },\n        };\n        return tableMiddleware;\n      },\n    } satisfies DBCore);\n}\n","import { Dexie } from 'dexie';\nimport * as Y from 'yjs';\nimport { YDocCache } from './types/YDocCache';\nimport { DexieYDocMeta } from './types/DexieYDocMeta';\n\n// The finalization registry\nconst docRegistry = new FinalizationRegistry<{cache: any, key: string}>(({cache, key}) => {\n  delete cache[key];\n});\n\n// The Y.Doc cache containing all active documents\nexport function getDocCache(db: Dexie): YDocCache {\n  return db._novip['_docCache'] ??= {\n    cache: {} as { [key: string]: WeakRef<Y.Doc>; },\n    get size() {\n      return Object.keys(this.cache).length;\n    },\n    find(table: string, primaryKey: any, ydocProp: string): Y.Doc | undefined {\n      const cacheKey = getYDocCacheKey(table, primaryKey, ydocProp);\n      const docRef = this.cache[cacheKey];\n      return docRef ? docRef.deref() : undefined;\n    },\n    add(doc: Y.Doc): void {\n      const { parentTable, parentId, parentProp } = doc.meta as DexieYDocMeta;\n      if (!parentTable || !parentProp || parentId == null)\n        throw new Error(`Missing Dexie-related metadata in Y.Doc`);\n      const cacheKey = getYDocCacheKey(parentTable, parentId, parentProp);\n      const existingDoc = this.cache[cacheKey]?.deref();\n      if (existingDoc) {\n        docRegistry.unregister(existingDoc); // Don't run garbage collection on this doc as it is being replaced.\n      }\n      this.cache[cacheKey] = new WeakRef(doc);\n      docRegistry.register(doc, { cache: this.cache, key: cacheKey }, doc);\n    },\n    delete(doc: Y.Doc): void {\n      docRegistry.unregister(doc); // Don't run garbage collection on this doc as it is being deleted here and now.\n      const cacheKey = getYDocCacheKey(doc.meta.parentTable, doc.meta.parentId, doc.meta.parentProp);\n      const cacheEntry = this.cache[cacheKey];\n      if (cacheEntry?.deref() === doc) {\n        delete this.cache[cacheKey]; // Remove the entry from the cache only if it is the same doc.\n      }\n    },\n  };\n}\n\n// Emulate a private boolean property \"destroyed\" on Y.Doc instances that we manage\n// in createYDocProperty.ts:\nexport const destroyedDocs = new WeakSet<object>();\n\nexport function throwIfDestroyed(doc: any) {\n  if (destroyedDocs.has(doc))\n    throw new Error(`Y.Doc ${doc.meta.parentId} has been destroyed`);\n}\n\nexport function getYDocCacheKey(table: string, primaryKey: any, ydocProp: string): string {\n  return `${table}[${primaryKey}].${ydocProp}`;\n}\n","import type { Dexie } from 'dexie';\nimport { destroyedDocs } from './docCache';\nimport { YDocCache } from './types/YDocCache';\nimport * as Y from 'yjs';\nimport { DexieYDocMeta } from './types/DexieYDocMeta';\n\nexport function getOrCreateDocument(\n  db: Dexie,\n  docCache: YDocCache,\n  tableName: string,\n  prop: string,\n  updatesTable: string,\n  id: any\n) {\n  let doc = docCache.find(tableName, id, prop);\n  if (doc) return doc;\n\n  doc = new Y.Doc({\n    meta: {\n      db,\n      updatesTable,\n      parentProp: prop,\n      parentTable: tableName,\n      parentId: id,\n    } satisfies DexieYDocMeta,\n  });\n\n  docCache.add(doc);\n\n  doc.on('destroy', () => {\n    destroyedDocs.add(doc);\n    docCache.delete(doc);\n  });\n\n  return doc;\n}\n","import { Dexie, Table } from 'dexie';\nimport { getDocCache } from './docCache';\nimport { getOrCreateDocument } from './getOrCreateDocument';\n\nconst { getByKeyPath } = Dexie;\n\nexport function createYDocProperty(\n  db: Dexie,\n  table: Table,\n  prop: string,\n  updatesTable: string\n) {\n  const pkKeyPath = table.schema.primKey.keyPath;\n  if (!pkKeyPath) {\n    throw new Error(\n      `Cannot create Y.Doc property for ${table.name}.${prop} because the table has no inbound primary key. See https://dexie.org/docs/inbound`\n    );\n  }\n  const docCache = getDocCache(db);\n  return {\n    set() {\n      throw new TypeError(`Y.Doc properties are read-only`);\n    },\n    get(this: object) {\n      const id = getByKeyPath(this, pkKeyPath);\n      return getOrCreateDocument(\n        db,\n        docCache,\n        table.name,\n        prop,\n        updatesTable,\n        id\n      );\n    },\n  };\n}\n","import { Dexie, cmp } from 'dexie';\nimport { YLastCompressed } from './types/YLastCompressed';\nimport { YSyncState } from './types/YSyncState';\nimport { YUpdateRow } from './types/YUpdateRow';\nimport * as Y from 'yjs';\n\n/** Go through all Y.Doc tables in the entire local db and compress updates\n *\n * @param db Dexie\n * @returns\n */\nexport function compressYDocs(db: Dexie, skipIfRecentlyDoneMillisec?: number) {\n  let p: Promise<any> = Promise.resolve();\n  for (const table of db.tables) {\n    for (const yProp of table.schema.yProps || []) {\n      p = p.then(() => compressYDocsTable(db, yProp, skipIfRecentlyDoneMillisec));\n    }\n  }\n  return p;\n}\n\n/** Compress an individual Y.Doc table */\nfunction compressYDocsTable(\n  db: Dexie,\n  { updatesTable }: { prop: string; updatesTable: string },\n  skipIfRunnedSince?: number // milliseconds\n) {\n  const updTbl = db.table(updatesTable);\n  return Promise.all([\n    // syncers (for example dexie-cloud-addon or other 3rd part syncers) They may have unsentFrom set.\n    updTbl\n      .where('i')\n      .startsWith('') // Syncers have string primary keys while updates have auto-incremented numbers.\n      .toArray(),\n\n    // lastCompressed (pointer to the last compressed update)\n    db.transaction('rw', updatesTable, () =>\n      updTbl.get(0).then((lastCompressed: YLastCompressed | undefined) => {\n        if (\n          skipIfRunnedSince &&\n          lastCompressed &&\n          lastCompressed.lastRun &&\n          lastCompressed.lastRun.getTime() > Date.now() - skipIfRunnedSince\n        ) {\n          // Skip it. It has run recently or is still running.\n          return null;\n        }\n        // isRunning might be true but we don't respect it if started before skipIfRunningSince.\n        lastCompressed = lastCompressed || { i: 0, lastCompressed: 0 };\n        return updTbl\n          .put({\n            ...lastCompressed,\n            lastRun: new Date(),\n          })\n          .then(() => lastCompressed);\n      })\n    ),\n  ]).then(([syncers, stamp]: [YSyncState[], YLastCompressed]) => {\n    if (!stamp) return; // Skip. Already running.\n    const lastCompressedUpdate = stamp.lastCompressed;\n    const unsyncedFrom = Math.min(\n      ...syncers.map((s) =>\n        Math.min(\n          s.unsentFrom || Infinity,\n          s.receivedUntil != null ? s.receivedUntil + 1 : Infinity\n        )\n      )\n    );\n    // Per updates-table:\n    // 1. Find all updates after lastCompressedId. Run toArray() on them.\n    // 2. IF there are any \"mine\" (flagged) updates AFTER unsentFrom, skip all from including this entry, else include all regardless of unsentFrom.\n    // 3. Now we know which keys have updates since last compression. We also know how far we're gonna go (max unsentFrom unless all additional updates are foreign).\n    // 4. For every key that had updates, load their main update (this is one single update per key before the lastCompressedId marker)\n    // 5. For every key that had updates: Compress main update along with additional updates until and including the number that was computed on step 2 (could be Infinity).\n    // 6. Update lastCompressedId to the i of the latest compressed entry.\n    return updTbl\n      .where('i')\n      .between(lastCompressedUpdate, Infinity, false)\n      .toArray((addedUpdates: YUpdateRow[]) => {\n        if (addedUpdates.length === 0) return; // No more updates where added\n        const docsToCompress: { docId: any; updates: YUpdateRow[] }[] = [];\n        let lastUpdateToCompress = lastCompressedUpdate;\n        for (let j = 0; j < addedUpdates.length; ++j) {\n          const updateRow = addedUpdates[j];\n          const { i, f, k } = updateRow;\n          if (i >= unsyncedFrom && f && f & 0x01) break; // An update that need to be synced was found. Stop here and let dontCompressFrom stay.\n          const entry = docsToCompress.find(\n            (entry) => cmp(entry.docId, k) === 0\n          );\n          if (entry) entry.updates.push(updateRow);\n          else docsToCompress.push({ docId: k, updates: [updateRow] });\n          lastUpdateToCompress = i;\n        }\n        if (lastUpdateToCompress === lastCompressedUpdate) return; // No updates to compress\n        let p = Promise.resolve();\n        for (const { docId, updates } of docsToCompress) {\n          p = p.then(() =>\n            compressUpdatesForDoc(db, updatesTable, docId, updates)\n          );\n        }\n        return p.then(() => {\n          // Update lastCompressed atomically to the value we computed.\n          // Do it with respect to the case when another job was done in parallel\n          // that maybe compressed one or more extra updates and updated lastCompressed\n          // before us.\n          return db.transaction('rw', updTbl, () =>\n            updTbl.get(0).then((current: YLastCompressed) => {\n              if (current && lastUpdateToCompress <= current.lastCompressed) {\n                // No need to update. Nothing was done, or another job did more.\n                return;\n              }\n              return updTbl.put({\n                ...current,\n                lastCompressed: lastUpdateToCompress,\n              });\n            })\n          );\n        });\n      });\n  });\n}\n\nexport function compressUpdatesForDoc(\n  db: Dexie,\n  updatesTable: string,\n  parentId: any,\n  addedUpdatesToCompress: YUpdateRow[]\n) {\n  if (addedUpdatesToCompress.length < 1) throw new Error('Invalid input');\n  return db.transaction('rw', updatesTable, (tx) => {\n    const updTbl = tx.table(updatesTable);\n    return updTbl.where({ k: parentId }).first((mainUpdate: YUpdateRow) => {\n      if (!mainUpdate) return; // No main update found. Nothing to compress.\n      const updates = [mainUpdate].concat(\n        addedUpdatesToCompress.filter((u) => u.i !== mainUpdate.i)\n      ); // avoid duplicating the main update (can happen sometimes)\n      const doc = new Y.Doc({ gc: true });\n      updates.forEach((update) => {\n        Y.applyUpdateV2(doc, update.u);\n      });\n      const compressedUpdate = Y.encodeStateAsUpdateV2(doc);\n      const lastUpdate = updates.pop()!;\n      return updTbl\n        .put({\n          i: lastUpdate.i,\n          k: parentId,\n          u: compressedUpdate,\n        })\n        .then(() => updTbl.bulkDelete(updates.map((update) => update.i)));\n    });\n  });\n}\n","import { Dexie } from 'dexie';\nimport { compressYDocs } from './compressYDocs';\n\nconst GC_DELAY = 10_000; // Delay before starting GC when DB is started\nconst GC_INTERVAL = 300_000; // Every 5 minutes\n\nexport function periodicGC(db: Dexie) {\n  let timer: any = null;\n  db.on(\n    'ready',\n    (db: Dexie) => {\n      if (db.tables.some(tbl => tbl.schema.yProps)) {\n        const gc = () => {\n          if (!db.isOpen()) return;\n          compressYDocs(db, GC_INTERVAL).catch(err => {\n            if (err && err.name === 'DatabaseClosedError') return;\n            console.debug('Error during periodic GC', err);\n          }).then(() => {\n            timer = setTimeout(gc, GC_INTERVAL);\n          });\n        };\n        timer = setTimeout(gc, GC_DELAY);\n      }\n    },\n    true\n  );\n  db.on('close', () => {\n    if (timer) clearTimeout(timer);\n    timer = null;\n  });\n}\n","import type { YUpdateRow } from './types/YUpdateRow';\n\nexport let currentUpdateRow: YUpdateRow | null = null;\n\nexport function setCurrentUpdateRow(row: YUpdateRow | null) {\n  currentUpdateRow = row;\n}\n","export function nop() {}","import { Dexie, DexieEvent, DexieEventSet, Unsubscribable } from 'dexie';\nimport * as Y from 'yjs';\nimport { throwIfDestroyed, getDocCache, destroyedDocs } from './docCache';\nimport { getOrCreateDocument } from './getOrCreateDocument';\nimport { observeYDocUpdates } from './observeYDocUpdates';\nimport { promisableChain } from './helpers/promisableChain';\nimport { nonStoppableEventChain } from './helpers/nonStoppableEventChain';\nimport { currentUpdateRow } from './currentUpdateRow';\nimport { Disposable } from './helpers/Disposable';\n\nconst wm = new WeakMap<any, DexieYProvider>();\n\nfunction createEvents() {\n  return (Dexie.Events as any)(null, 'load', 'sync', 'error') as DexieYProvider['on'];\n}\n\ninterface ReleaseOptions {\n  gracePeriod?: number; // Grace period to optimize for unload/reload scenarios\n}\n\nclass DexieYProvider\n{\n  refCount = 1;\n  private stopObserving: () => void;\n  private cleanupHandlers: (() => void)[] = [];\n  private graceTimer: any;\n  private graceTimeout = -1;\n  doc: Y.Doc | null = null;\n  awareness?: any;\n  private _error?: any;\n\n  private _whenLoaded: Promise<void>;\n  private _whenSynced: Promise<void>;\n\n  on: DexieEventSet & ((name: string, f: (...args: any[]) => any) => void);\n  off: (name: string, f: (...args: any[]) => any) => void;\n\n  destroyed = false;\n\n  static on = (Dexie.Events as any)(null, {\n    new: [nonStoppableEventChain],\n    beforeunload: [promisableChain],\n  }) as DexieEventSet & ((name: string, f: (...args: any[]) => any) => void) & {\n    new: DexieEvent;\n    beforeunload: DexieEvent;\n  };\n\n  static getOrCreateDocument(db: Dexie, table: string, prop: string, id: any) {\n    const docCache = getDocCache(db);\n    const updatesTable = db\n      .table(table)\n      .schema.yProps?.find((p) => p.prop === prop)?.updatesTable;\n    if (!updatesTable) {\n      throw new Error(`Updates table for ${table}.${prop} not found`);\n    }\n    // Get or create the Y.Doc for the given table, prop, and id\n    return getOrCreateDocument(db, docCache, table, prop, updatesTable, id);\n  }\n\n  static load(\n    doc: Y.Doc,\n    options?: ReleaseOptions\n  ): DexieYProvider {\n    let p = wm.get(doc);\n    if (p) {\n      ++p.refCount;\n      if (\n        options?.gracePeriod != null &&\n        p.graceTimeout < options.gracePeriod\n      ) {\n        p.graceTimeout = options.gracePeriod;\n      }\n      if (p.graceTimer) {\n        clearTimeout(p.graceTimer);\n        p.graceTimer = null;\n      }\n    } else {\n      p = new DexieYProvider(doc);\n      p.graceTimeout = options?.gracePeriod ?? -1;\n      wm.set(doc, p);\n    }\n    return p;\n  }\n\n  static release(doc: Y.Doc) {\n    if (!doc || destroyedDocs.has(doc)) return; // Document already destroyed.\n    const p = wm.get(doc);\n    if (p) {\n      // There is a provider connected to the doc\n      if (--p.refCount <= 0) {\n        // No references to this provider anymore. Time to release it.\n        if (p.graceTimeout < 0) {\n          // No grace period here or from previous release. Release immediately.\n          p._release();\n        } else if (!p.graceTimer) {\n          p.graceTimer = setTimeout(\n            () => {\n              p.graceTimer = null;\n              if (p.refCount === 0) {\n                // Release only if refCount is still zero\n                p._release();\n              }\n            },\n            p.graceTimeout // Grace period to optimize for unload/reload scenarios\n          );\n        }\n      }\n    } else {\n      doc.destroy();\n    }\n  }\n\n  private _release() {\n    // Allow a listener to beforeunload event to execute while the provider and the document\n    // are still alive and loaded if it needs to compute something from the full document.\n    // Also, in case the event listener uses DexieYProvider.load() without calling DexieYProvider.release(),\n    // it must prevent the release to happen until the provider is finally released.\n    if (!this.doc) return;\n    Promise.resolve(DexieYProvider.on('beforeunload').fire(this)).finally(\n      () => {\n        // Re-check that refCount is zero before actually destroying the document (which\n        // leads to provider.destroy() through the destroy-event on the doc).\n        if (this.refCount === 0) {\n          this.doc?.destroy();\n        }\n        // If refCount is not zero, it means that DexieYProvider.load() has been called from the listener\n        // and the listener has prevented the release from happening. The listener must call DexieYProvider.release()\n        // when it's done with the document.\n      }\n    );\n  }\n\n  static for(doc: Y.Doc): DexieYProvider | undefined {\n    return wm.get(doc);\n  }\n  static getDocCache = getDocCache;\n  static get currentUpdateRow() {\n    return currentUpdateRow;\n  }\n\n  // Use a getter to avoid unhandled rejections when no one bothers about it.\n  get whenLoaded(): Promise<void> {\n    if (!this._whenLoaded) {\n      this._whenLoaded = new Promise((resolve, reject) => {\n        if (!this.doc) {\n          reject(new Error('No Y.Doc associated with this provider'));\n          return;\n        }\n        if (this.doc.isLoaded) resolve();\n        else if (this._error) reject(this._error);\n        else if (destroyedDocs.has(this.doc)) {\n          reject(new Dexie.AbortError('Document was destroyed before loaded'));\n        } else {\n          this.on('load', resolve);\n          this.on('error', reject);\n          this.doc.on('destroy', () =>\n            reject(new Dexie.AbortError('Document was destroyed before loaded'))\n          );\n        }\n      });\n    }\n    return this._whenLoaded;\n  }\n\n  // Use a getter to avoid unhandled rejections when no one bothers about it.\n  get whenSynced(): Promise<void> {\n    if (!this._whenSynced) {\n      this._whenSynced = new Promise((resolve, reject) => {\n        if (!this.doc) {\n          reject(new Error('No Y.Doc associated with this provider'));\n          return;\n        }\n        if (this.doc.isSynced) resolve();\n        else if (this._error) reject(this._error);\n        else if (destroyedDocs.has(this.doc)) {\n          reject(new Dexie.AbortError('Document was destroyed before synced'));\n        } else {\n          this.on('sync', resolve);\n          this.on('error', reject);\n          this.doc.on('destroy', () =>\n            reject(new Dexie.AbortError('Document was destroyed before synced'))\n          );\n        }\n      });\n    }\n    return this._whenSynced;\n  }\n\n  constructor(doc: Y.Doc) {\n    this.on = createEvents();\n    this.doc = doc;\n    this.off = (name: string, f: Function) => this.on[name]?.unsubscribe(f);\n    if ('dispose' in Symbol) {\n      // @ts-ignore\n      this[Symbol.dispose] = () => DexieYProvider.release(doc);\n    }\n    doc.on('load', () => this.on('load').fire());\n    doc.on('sync', (sync) => sync !== false && this.on('sync').fire());\n    doc.on('destroy', this.destroy.bind(this));\n    this.on('error', (error) => {\n      // In case error happens before awaiting provider.whenLoaded or provider.whenSynced.\n      this._error = error;\n    });\n\n    const { db, parentTable, parentId, updatesTable } =\n      (doc as Y.Doc).meta || {};\n    if (!db || !parentTable || !updatesTable) {\n      throw new Error(\n        `Missing Dexie-related metadata in Y.Doc. Documents need to be obtained through Y.Doc properties from dexie queries.`\n      );\n    }\n    // This doc is from Dexie\n    if (!db.table(parentTable) || !db.table(updatesTable)) {\n      throw new Error(\n        `Table ${parentTable} or ${updatesTable} not found in db`\n      );\n    }\n    throwIfDestroyed(doc);\n    this.stopObserving = observeYDocUpdates(\n      this,\n      doc,\n      db,\n      parentTable,\n      updatesTable,\n      parentId\n    );\n    DexieYProvider.on(\"new\").fire(this); // Allow for addons to invoke their sync- and awareness providers here.\n  }\n\n  destroy() {\n    console.debug(`Y.Doc ${this.doc?.meta?.parentId} was destroyed`);\n    wm.delete(this.doc);\n    this.doc = null;\n    this.destroyed = true;\n    this.refCount = 0;\n    this.stopObserving?.();\n    this.on = createEvents(); // Releases listeners for GC\n    this.cleanupHandlers.forEach((cleanup) => cleanup());\n  }\n\n  addCleanupHandler(cleanupHandler: (() => void) | Unsubscribable) {\n    this.cleanupHandlers.push(\n      typeof cleanupHandler === 'function'\n        ? cleanupHandler\n        : () => cleanupHandler.unsubscribe()\n    );\n  }\n}\n\n//\n// Support `using DexieYProvider.load();` syntax\n//\n// Extend DexieYProvider with Disposable interface if Symbol.dispose is supported.\n// (At runtime, this[Symbol.dispose] is created in the constructor, so we indeed implement Disposable interface)\ninterface DexieYProvider extends Disposable {}\n\n//\n// Eliminate dual package hazard \n//\n// Since we're holding static state, make sure to singletonize DexieYProvider\n//\nif (Dexie[\"DexieYProvider\"]) {\n  // @ts-ignore\n  DexieYProvider = Dexie[\"DexieYProvider\"] || DexieYProvider;\n} else {\n  Dexie[\"DexieYProvider\"] = DexieYProvider;\n}\n\nexport { DexieYProvider };\n","import type { Dexie } from 'dexie';\nimport * as Y from 'yjs';\nimport { YUpdateRow } from './types/YUpdateRow';\nimport type { EntityTable } from 'dexie';\nimport { throwIfDestroyed } from './docCache';\nimport { liveQuery } from 'dexie';\nimport { cmp } from 'dexie';\nimport { setCurrentUpdateRow } from './currentUpdateRow';\nimport type { DexieYProvider } from './DexieYProvider';\n\nexport function observeYDocUpdates(\n  provider: DexieYProvider,\n  doc: Y.Doc,\n  db: Dexie,\n  parentTableName: string,\n  updatesTableName: string,\n  parentId: any\n): () => void {\n  let lastUpdateId = 0;\n  let initial = true;\n  const subscription = liveQuery(() => {\n    throwIfDestroyed(doc);\n    const updatesTable = db.table(updatesTableName) as EntityTable<\n      YUpdateRow,\n      'i'\n    >;\n    return Promise.all([\n      (lastUpdateId > 0\n        ? updatesTable\n            .where('i')\n            .between(lastUpdateId, Infinity, false)\n            .toArray()\n            .then((updates) =>\n              updates.filter((update) => cmp(update.k, parentId) === 0)\n            )\n        : updatesTable.where({ k: parentId }).toArray()\n      ).then((updates) => {\n        return updates;\n      }),\n      db.table(parentTableName).where(':id').equals(parentId).toArray(), // Why not just count() or get()? Because of cache only works with toArray() currently (optimization)\n    ]);\n  }).subscribe(\n    ([updates, parentRow]) => {\n      if (updates.length > 0) lastUpdateId = updates[updates.length - 1].i;\n      if (parentRow.length === 0) {\n        // Row deleted. Destroy Y.Doc.\n        doc.destroy();\n        return;\n      }\n      throwIfDestroyed(doc);\n      if (updates.length > 0) {\n        Y.transact(\n          doc,\n          () => {\n            updates.forEach((update) => {\n              try {\n                setCurrentUpdateRow(update);\n                Y.applyUpdateV2(doc, update.u);\n              } finally {\n                setCurrentUpdateRow(null);\n              }\n            });\n          },\n          provider,\n          false\n        );\n      }\n      if (initial) {\n        initial = false;\n        doc.emit('load', [doc]);\n      }\n    },\n    (error) => {\n      provider.on('error').fire(error);\n    }\n  );\n\n  const onUpdate = (update: Uint8Array, origin: any) => {\n    if (origin === provider) return; // Already applied.\n    db.table(updatesTableName)\n      .add({\n        k: parentId,\n        u: update,\n        f: 1, // Flag as local update (to be included when syncing)\n      } satisfies Omit<YUpdateRow, 'i'>)\n      .then((i: number) => {\n        // Optimization (not critical): Don't query for this update to put it back into the doc.\n        // However, skip this optimization if the lastUpdateId is behind the current update.\n        // In that case, next liveQuery emission will include also this update and re-apply it into doc,\n        // but it will not be an issue because Y.Doc will ignore duplicate updates.\n        if (i === lastUpdateId - 1) ++lastUpdateId;\n      })\n      .catch((error) => {\n        provider.on('error').fire(error);\n      });\n  };\n\n  const stopObserving = () => {\n    subscription.unsubscribe();\n    doc.off('updateV2', onUpdate);\n    doc.off('destroy', stopObserving);\n  };\n\n  doc.on('updateV2', onUpdate);\n  doc.on('destroy', stopObserving);\n\n  return stopObserving;\n}\n","import { nop } from \"./nop\";\n\nexport function nonStoppableEventChain(f1: Function, f2: Function) {\n    if (f1 === nop) return f2;\n    return function () {\n        f1.apply(this, arguments);\n        f2.apply(this, arguments);\n    };\n}\n","import { nop } from \"./nop\";\n\nexport function promisableChain(f1, f2) {\n    if (f1 === nop) return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this,\n                i = arguments.length,\n                args = new Array(i);\n            while (i--) args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n","import { DbSchema, Dexie, ExtendableVersion, IndexSpec, TableSchema } from 'dexie';\nimport { createYjsMiddleware } from './createYjsMiddleware';\nimport { createYDocProperty } from './createYDocProperty';\nimport { periodicGC } from './periodicGC';\n\nconst YJS_MIDDLEWARE_NAME = 'yjsMiddleware';\n\nexport interface YDexieOptions {\n  gc?: boolean; // Enable or disable garbage collection for Y.js documents.\n}\n\nexport { compressYDocs } from './compressYDocs';\nexport { DexieYProvider } from './DexieYProvider';\nexport * from './types';\n\nexport default function yDexie(dbOrOptions: Dexie | YDexieOptions) {\n  // This function is a placeholder for the y-dexie addon.\n  // It can be used to initialize or configure the addon as needed.\n  if (!('transaction' in dbOrOptions)) {\n    // If db is an options object, create a configured yDexie addon that\n    // could be passed to the addons array of Dexie constructor.\n    const options = dbOrOptions;\n    // Return a configured Dexie addon function.\n    return (db: Dexie) => configurableYDexie(db, options);\n  } else {\n    // If db is a Dexie instance, it is being called as an addon.\n    // Do default configuration.\n    return configurableYDexie(dbOrOptions, {});\n  }\n}\n\nfunction configurableYDexie(db: Dexie, options: YDexieOptions) {\n  db.Table = class Table extends (db.Table as (new() => Dexie.Table<any>)) {\n    mapToClass(constructor: Function) {\n      if (this.schema.yProps) {\n        constructor = class extends (constructor as any) {};\n        this.schema.yProps.forEach(({prop, updatesTable}) => {\n          Object.defineProperty(constructor.prototype, prop, createYDocProperty(db, this, prop, updatesTable));\n        });\n      }\n      const result = super.mapToClass(constructor);\n      this.schema.mappedClass = constructor; // Also done in super.mapToClass but we need to set the user-provided class, not our altered class.\n      return result;\n    }\n  };\n\n  db.Version = class Version extends (db.Version as (new() => ExtendableVersion)) {\n    _createTableSchema(\n      name: string,\n      primKey: IndexSpec,\n      indexes: IndexSpec[]\n    ): TableSchema {\n      const yProps = indexes.filter(\n        (idx) => idx.type === 'Y' || idx.type === 'Y.Doc'\n      );\n      indexes = indexes.filter((idx) => !yProps.includes(idx)); // Y marks just the Y.Doc type and is not an index\n      const tableSchema = super._createTableSchema(\n        name,\n        primKey,\n        indexes\n      ) as TableSchema;\n      if (yProps.length > 0) {\n        tableSchema.yProps = yProps.map((idx) => ({\n          prop: idx.name,\n          updatesTable: `$${name}.${idx.name}_updates`,\n        }));\n      }\n      return tableSchema;\n    }\n\n    _parseStoresSpec(\n      stores: { [tableName: string]: string | null },\n      outSchema: DbSchema\n    ): void {\n      // Implementation for parsing stores spec\n      // This is a placeholder; actual implementation would go here\n      super._parseStoresSpec(stores, outSchema);\n\n      // Generate update tables for Y.js properties\n      Object.keys(stores).forEach((tableName) => {\n        const tblSchema = outSchema[tableName];\n        if (tblSchema) {\n          for (const yProp of tblSchema.yProps || []) {\n            super._parseStoresSpec(\n              // Add a table for each yProp containing document updates.\n              // See interface YUpdateRow { i: number, k: IndexableType, u: Uint8Array, f?: number}\n              // where\n              //   i is the auto-incremented primary key of the update table,\n              //   k is the primary key from the other table holding the document in a property.\n              //   u is the update data from Y.js\n              //   f is a flag indicating if the update comes from this client or another.\n              // Index use cases:\n              //   * Load entire document: Use index k\n              //   * After object load, observe updates on a certain document since a given revision: Use index k or i since [k+i] is not supported before Firefox 126.\n              //   * After initial sync, observe flagged updates since a given revision: Use index i and ignore unflagged.\n              //     Could be using an index [f+i] but that wouldn't gain too much and Firefox before 126 doesnt support it.\n              //     Local updates are flagged while remote updates are not.\n              //\n              { [yProp.updatesTable]: '++i,k' },\n              outSchema\n            );\n          }\n        }\n      });\n    }\n\n    stores(schema: { [tableName: string]: string | null }) {\n      const db = this.db as Dexie;\n      // This method is used to define the schema for the database.\n      // It allows you to specify the tables and their indexes.\n      const result = super.stores(schema);\n      const dbschema = db._dbSchema;\n      Object.keys(dbschema).forEach((tableName) => {\n        if (dbschema[tableName].yProps) {\n          // If a table as yProps, make sure to derive a class with generated Y properties.\n          // This is done in the mapToClass method. In case user has called mapToClass already, respect mappedClass,\n          // otherwise use Object as default to create a top-level class with the generated y properties.\n          db.table(tableName).mapToClass(\n            dbschema[tableName].mappedClass || Object\n          );\n        }\n      });\n      if (Object.values(dbschema).some((table) => table.yProps)) {\n        db.use({\n          stack: 'dbcore',\n          name: YJS_MIDDLEWARE_NAME,\n          level: 50,\n          create: createYjsMiddleware(dbschema),\n        });\n      } else {\n        db.unuse({ stack: 'dbcore', name: YJS_MIDDLEWARE_NAME });\n      }\n\n      return result;\n    }\n  };\n\n  if (options?.gc !== false) {\n    periodicGC(db);\n  }\n}\n"],"names":["_hasOwn","hasOwnProperty","hasOwn","obj","prop","call","EMPTY_ARRAY","docRegistry","FinalizationRegistry","cache","key","getDocCache","db","_a","_b","_novip","size","Object","keys","this","length","find","table","primaryKey","ydocProp","cacheKey","getYDocCacheKey","docRef","deref","undefined","add","doc","parentTable","parentId","parentProp","meta","Error","existingDoc","unregister","WeakRef","register","cacheEntry","destroyedDocs","WeakSet","throwIfDestroyed","has","getOrCreateDocument","docCache","tableName","updatesTable","id","Y","Doc","on","delete","getByKeyPath","Dexie","compressYDocs","skipIfRecentlyDoneMillisec","p","Promise","resolve","tables","yProp","schema","yProps","then","compressYDocsTable","skipIfRunnedSince","updTbl","all","where","startsWith","toArray","transaction","get","lastCompressed","lastRun","getTime","Date","now","i","put","assign","syncers","stamp","lastCompressedUpdate","unsyncedFrom","Math","min","map","s","unsentFrom","Infinity","receivedUntil","between","addedUpdates","docsToCompress","lastUpdateToCompress","j","updateRow","f","k","entry","cmp","docId","updates","push","compressUpdatesForDoc","current","addedUpdatesToCompress","tx","first","mainUpdate","concat","filter","u","gc","forEach","update","applyUpdateV2","compressedUpdate","encodeStateAsUpdateV2","lastUpdate","pop","bulkDelete","GC_DELAY","GC_INTERVAL","currentUpdateRow","setCurrentUpdateRow","row","nop","wm","WeakMap","createEvents","Events","DexieYProvider","load","options","refCount","gracePeriod","graceTimeout","graceTimer","clearTimeout","set","release","_release","setTimeout","destroy","fire","finally","whenLoaded","_whenLoaded","reject","isLoaded","_error","AbortError","whenSynced","_whenSynced","isSynced","constructor","cleanupHandlers","destroyed","off","name","unsubscribe","Symbol","dispose","sync","bind","error","stopObserving","provider","parentTableName","updatesTableName","lastUpdateId","initial","subscription","liveQuery","equals","subscribe","parentRow","transact","emit","onUpdate","origin","catch","observeYDocUpdates","_c","cleanup","addCleanupHandler","cleanupHandler","new","f1","f2","apply","arguments","beforeunload","res","thiz","args","Array","YJS_MIDDLEWARE_NAME","yDexie","dbOrOptions","configurableYDexie","Table","mapToClass","defineProperty","prototype","pkKeyPath","primKey","keyPath","TypeError","createYDocProperty","result","super","mappedClass","Version","_createTableSchema","indexes","idx","type","includes","tableSchema","_parseStoresSpec","stores","outSchema","tblSchema","dbschema","_dbSchema","dbSchema","values","some","use","stack","level","create","downCore","downTable","dbTableSchema","mutate","req","reqClone","updateSources","entries","flatMap","value","iter","v","encodeStateVector","updatesToInsert","results","trans","unuse","timer","tbl","isOpen","err","periodicGC"],"mappings":"4EAAA,MAAMA,EAAU,CAAE,EAACC,eACNC,EAAS,CAACC,EAAaC,IAC3BJ,EAAQK,KAAKF,EAAKC,GCIrBE,EAAc,GCApB,MAAMC,EAAc,IAAIC,sBAAgD,EAAEC,QAAOC,iBACxED,EAAMC,EAAI,IAIb,SAAUC,EAAYC,WAC1B,OAA4B,QAA5BC,GAAAC,EAAOF,EAAGG,QAAkB,iBAAA,IAAAF,EAAAA,EAAAC,EAAA,UAAM,CAChCL,MAAO,CAAwC,EAC/C,QAAIO,GACF,OAAOC,OAAOC,KAAKC,KAAKV,OAAOW,MAChC,EACD,IAAAC,CAAKC,EAAeC,EAAiBC,GACnC,MAAMC,EAAWC,EAAgBJ,EAAOC,EAAYC,GAC9CG,EAASR,KAAKV,MAAMgB,GAC1B,OAAOE,EAASA,EAAOC,aAAUC,CAClC,EACD,GAAAC,CAAIC,SACF,MAAMC,YAAEA,EAAWC,SAAEA,EAAQC,WAAEA,GAAeH,EAAII,KAClD,IAAKH,IAAgBE,GAA0B,MAAZD,EACjC,MAAM,IAAIG,MAAM,2CAClB,MAAMX,EAAWC,EAAgBM,EAAaC,EAAUC,GAClDG,EAAkC,QAApBxB,EAAAM,KAAKV,MAAMgB,UAAS,IAAAZ,OAAA,EAAAA,EAAEe,QACtCS,GACF9B,EAAY+B,WAAWD,GAEzBlB,KAAKV,MAAMgB,GAAY,IAAIc,QAAQR,GACnCxB,EAAYiC,SAAST,EAAK,CAAEtB,MAAOU,KAAKV,MAAOC,IAAKe,GAAYM,EACjE,EACD,OAAOA,GACLxB,EAAY+B,WAAWP,GACvB,MAAMN,EAAWC,EAAgBK,EAAII,KAAKH,YAAaD,EAAII,KAAKF,SAAUF,EAAII,KAAKD,YAC7EO,EAAatB,KAAKV,MAAMgB,IAC1BgB,aAAA,EAAAA,EAAYb,WAAYG,UACnBZ,KAAKV,MAAMgB,EAErB,EAEL,CAIO,MAAMiB,EAAgB,IAAIC,QAE3B,SAAUC,EAAiBb,GAC/B,GAAIW,EAAcG,IAAId,GACpB,MAAM,IAAIK,MAAM,SAASL,EAAII,KAAKF,8BACtC,UAEgBP,EAAgBJ,EAAeC,EAAiBC,GAC9D,MAAO,GAAGF,KAASC,MAAeC,GACpC,CClDgB,SAAAsB,EACdlC,EACAmC,EACAC,EACA5C,EACA6C,EACAC,GAEA,IAAInB,EAAMgB,EAAS1B,KAAK2B,EAAWE,EAAI9C,GACvC,OAAI2B,IAEJA,EAAM,IAAIoB,EAAEC,IAAI,CACdjB,KAAM,CACJvB,KACAqC,eACAf,WAAY9B,EACZ4B,YAAagB,EACbf,SAAUiB,KAIdH,EAASjB,IAAIC,GAEbA,EAAIsB,GAAG,WAAW,KAChBX,EAAcZ,IAAIC,GAClBgB,EAASO,OAAOvB,EAAI,IAGfA,EACT,CC/BA,MAAMwB,aAAEA,GAAiBC,ECOT,SAAAC,EAAc7C,EAAW8C,GACvC,IAAIC,EAAkBC,QAAQC,UAC9B,IAAK,MAAMvC,KAASV,EAAGkD,OACrB,IAAK,MAAMC,KAASzC,EAAM0C,OAAOC,QAAU,GACzCN,EAAIA,EAAEO,MAAK,IAAMC,EAAmBvD,EAAImD,EAAOL,KAGnD,OAAOC,CACT,CAGA,SAASQ,EACPvD,GACAqC,aAAEA,GACFmB,GAEA,MAAMC,EAASzD,EAAGU,MAAM2B,GACxB,OAAOW,QAAQU,IAAI,CAEjBD,EACGE,MAAM,KACNC,WAAW,IACXC,UAGH7D,EAAG8D,YAAY,KAAMzB,GAAc,IACjCoB,EAAOM,IAAI,GAAGT,MAAMU,GAEhBR,GACAQ,GACAA,EAAeC,SACfD,EAAeC,QAAQC,UAAYC,KAAKC,MAAQZ,EAGzC,MAGTQ,EAAiBA,GAAkB,CAAEK,EAAG,EAAGL,eAAgB,GACpDP,EACJa,IAAGjE,OAAAkE,OAAAlE,OAAAkE,OAAA,CAAA,EACCP,GACH,CAAAC,QAAS,IAAIE,QAEdb,MAAK,IAAMU,WAGjBV,MAAK,EAAEkB,EAASC,MACjB,IAAKA,EAAO,OACZ,MAAMC,EAAuBD,EAAMT,eAC7BW,EAAeC,KAAKC,OACrBL,EAAQM,KAAKC,GACdH,KAAKC,IACHE,EAAEC,YAAcC,IACG,MAAnBF,EAAEG,cAAwBH,EAAEG,cAAgB,EAAID,QAWtD,OAAOxB,EACJE,MAAM,KACNwB,QAAQT,EAAsBO,KAAU,GACxCpB,SAASuB,IACR,GAA4B,IAAxBA,EAAa5E,OAAc,OAC/B,MAAM6E,EAA0D,GAChE,IAAIC,EAAuBZ,EAC3B,IAAK,IAAIa,EAAI,EAAGA,EAAIH,EAAa5E,SAAU+E,EAAG,CAC5C,MAAMC,EAAYJ,EAAaG,IACzBlB,EAAEA,EAACoB,EAAEA,EAACC,EAAEA,GAAMF,EACpB,GAAInB,GAAKM,GAAgBc,GAAS,EAAJA,EAAU,MACxC,MAAME,EAAQN,EAAe5E,MAC1BkF,GAAkC,IAAxBC,EAAID,EAAME,MAAOH,KAE1BC,EAAOA,EAAMG,QAAQC,KAAKP,GACzBH,EAAeU,KAAK,CAAEF,MAAOH,EAAGI,QAAS,CAACN,KAC/CF,EAAuBjB,CACxB,CACD,GAAIiB,IAAyBZ,EAAsB,OACnD,IAAI3B,EAAIC,QAAQC,UAChB,IAAK,MAAM4C,MAAEA,EAAKC,QAAEA,KAAaT,EAC/BtC,EAAIA,EAAEO,MAAK,IACT0C,EAAsBhG,EAAIqC,EAAcwD,EAAOC,KAGnD,OAAO/C,EAAEO,MAAK,IAKLtD,EAAG8D,YAAY,KAAML,GAAQ,IAClCA,EAAOM,IAAI,GAAGT,MAAM2C,IAClB,KAAIA,GAAWX,GAAwBW,EAAQjC,gBAI/C,OAAOP,EAAOa,IACTjE,OAAAkE,OAAAlE,OAAAkE,OAAA,CAAA,EAAA0B,IACHjC,eAAgBsB,IAChB,OAGN,GACF,GAER,CAEM,SAAUU,EACdhG,EACAqC,EACAhB,EACA6E,GAEA,GAAIA,EAAuB1F,OAAS,EAAG,MAAM,IAAIgB,MAAM,iBACvD,OAAOxB,EAAG8D,YAAY,KAAMzB,GAAe8D,IACzC,MAAM1C,EAAS0C,EAAGzF,MAAM2B,GACxB,OAAOoB,EAAOE,MAAM,CAAE+B,EAAGrE,IAAY+E,OAAOC,IAC1C,IAAKA,EAAY,OACjB,MAAMP,EAAU,CAACO,GAAYC,OAC3BJ,EAAuBK,QAAQC,GAAMA,EAAEnC,IAAMgC,EAAWhC,KAEpDlD,EAAM,IAAIoB,EAAEC,IAAI,CAAEiE,IAAI,IAC5BX,EAAQY,SAASC,IACfpE,EAAEqE,cAAczF,EAAKwF,EAAOH,EAAE,IAEhC,MAAMK,EAAmBtE,EAAEuE,sBAAsB3F,GAC3C4F,EAAajB,EAAQkB,MAC3B,OAAOvD,EACJa,IAAI,CACHD,EAAG0C,EAAW1C,EACdqB,EAAGrE,EACHmF,EAAGK,IAEJvD,MAAK,IAAMG,EAAOwD,WAAWnB,EAAQhB,KAAK6B,GAAWA,EAAOtC,MAAI,GACnE,GAEN,CCpJA,MAAM6C,EAAW,IACXC,EAAc,ICFb,IAAIC,EAAsC,KAE3C,SAAUC,EAAoBC,GAClCF,EAAmBE,CACrB,CCNM,SAAUC,IAAG,CCUnB,MAAMC,EAAK,IAAIC,QAEf,SAASC,IACP,OAAQ9E,EAAM+E,OAAe,KAAM,OAAQ,OAAQ,QACrD,CAMA,MAAMC,EA2BJ,0BAAO1F,CAAoBlC,EAAWU,EAAelB,EAAc8C,WACjE,MAAMH,EAAWpC,EAAYC,GACvBqC,EAEwC,QAFzBnC,EAEL,QAFKD,EAAAD,EAClBU,MAAMA,GACN0C,OAAOC,cAAM,IAAApD,OAAA,EAAAA,EAAEQ,MAAMsC,GAAMA,EAAEvD,OAASA,WAAK,IAAAU,OAAA,EAAAA,EAAEmC,aAChD,IAAKA,EACH,MAAM,IAAIb,MAAM,qBAAqBd,KAASlB,eAGhD,OAAO0C,EAAoBlC,EAAImC,EAAUzB,EAAOlB,EAAM6C,EAAcC,EACrE,CAED,WAAOuF,CACL1G,EACA2G,SAEA,IAAI/E,EAAIyE,EAAGzD,IAAI5C,GAkBf,OAjBI4B,KACAA,EAAEgF,SAEsB,OAAxBD,eAAAA,EAASE,cACTjF,EAAEkF,aAAeH,EAAQE,cAEzBjF,EAAEkF,aAAeH,EAAQE,aAEvBjF,EAAEmF,aACJC,aAAapF,EAAEmF,YACfnF,EAAEmF,WAAa,QAGjBnF,EAAI,IAAI6E,EAAezG,GACvB4B,EAAEkF,aAAuC,QAAxBhI,EAAA6H,aAAA,EAAAA,EAASE,mBAAe,IAAA/H,EAAAA,GAAC,EAC1CuH,EAAGY,IAAIjH,EAAK4B,IAEPA,CACR,CAED,cAAOsF,CAAQlH,GACb,IAAKA,GAAOW,EAAcG,IAAId,GAAM,OACpC,MAAM4B,EAAIyE,EAAGzD,IAAI5C,GACb4B,IAEIA,EAAEgF,UAAY,IAEdhF,EAAEkF,aAAe,EAEnBlF,EAAEuF,WACQvF,EAAEmF,aACZnF,EAAEmF,WAAaK,YACb,KACExF,EAAEmF,WAAa,KACI,IAAfnF,EAAEgF,UAEJhF,EAAEuF,UACH,GAEHvF,EAAEkF,gBAKR9G,EAAIqH,SAEP,CAEO,QAAAF,GAKD/H,KAAKY,KACV6B,QAAQC,QAAQ2E,EAAenF,GAAG,gBAAgBgG,KAAKlI,OAAOmI,SAC5D,WAGwB,IAAlBnI,KAAKwH,WACG,QAAV9H,EAAAM,KAAKY,WAAK,IAAAlB,GAAAA,EAAAuI,UACX,GAMN,CAED,UAAO,CAAIrH,GACT,OAAOqG,EAAGzD,IAAI5C,EACf,CAED,2BAAWiG,GACT,OAAOA,CACR,CAGD,cAAIuB,GAoBF,OAnBKpI,KAAKqI,cACRrI,KAAKqI,YAAc,IAAI5F,SAAQ,CAACC,EAAS4F,KAClCtI,KAAKY,IAINZ,KAAKY,IAAI2H,SAAU7F,IACd1C,KAAKwI,OAAQF,EAAOtI,KAAKwI,QACzBjH,EAAcG,IAAI1B,KAAKY,KAC9B0H,EAAO,IAAIjG,EAAMoG,WAAW,0CAE5BzI,KAAKkC,GAAG,OAAQQ,GAChB1C,KAAKkC,GAAG,QAASoG,GACjBtI,KAAKY,IAAIsB,GAAG,WAAW,IACrBoG,EAAO,IAAIjG,EAAMoG,WAAW,4CAX9BH,EAAO,IAAIrH,MAAM,0CAalB,KAGEjB,KAAKqI,WACb,CAGD,cAAIK,GAoBF,OAnBK1I,KAAK2I,cACR3I,KAAK2I,YAAc,IAAIlG,SAAQ,CAACC,EAAS4F,KAClCtI,KAAKY,IAINZ,KAAKY,IAAIgI,SAAUlG,IACd1C,KAAKwI,OAAQF,EAAOtI,KAAKwI,QACzBjH,EAAcG,IAAI1B,KAAKY,KAC9B0H,EAAO,IAAIjG,EAAMoG,WAAW,0CAE5BzI,KAAKkC,GAAG,OAAQQ,GAChB1C,KAAKkC,GAAG,QAASoG,GACjBtI,KAAKY,IAAIsB,GAAG,WAAW,IACrBoG,EAAO,IAAIjG,EAAMoG,WAAW,4CAX9BH,EAAO,IAAIrH,MAAM,0CAalB,KAGEjB,KAAK2I,WACb,CAED,WAAAE,CAAYjI,GAtKZZ,KAAQwH,SAAG,EAEHxH,KAAe8I,gBAAmB,GAElC9I,KAAY0H,cAAI,EACxB1H,KAAGY,IAAiB,KAUpBZ,KAAS+I,WAAG,EAwJV/I,KAAKkC,GAAKiF,IACVnH,KAAKY,IAAMA,EACXZ,KAAKgJ,IAAM,CAACC,EAAc/D,KAAe,IAAAxF,EAAC,OAAa,QAAbA,EAAAM,KAAKkC,GAAG+G,UAAK,IAAAvJ,OAAA,EAAAA,EAAEwJ,YAAYhE,EAAE,EACnE,YAAaiE,SAEfnJ,KAAKmJ,OAAOC,SAAW,IAAM/B,EAAeS,QAAQlH,IAEtDA,EAAIsB,GAAG,QAAQ,IAAMlC,KAAKkC,GAAG,QAAQgG,SACrCtH,EAAIsB,GAAG,QAASmH,IAAkB,IAATA,GAAkBrJ,KAAKkC,GAAG,QAAQgG,SAC3DtH,EAAIsB,GAAG,UAAWlC,KAAKiI,QAAQqB,KAAKtJ,OACpCA,KAAKkC,GAAG,SAAUqH,IAEhBvJ,KAAKwI,OAASe,CAAK,IAGrB,MAAM9J,GAAEA,EAAEoB,YAAEA,EAAWC,SAAEA,EAAQgB,aAAEA,GAChClB,EAAcI,MAAQ,GACzB,IAAKvB,IAAOoB,IAAgBiB,EAC1B,MAAM,IAAIb,MACR,uHAIJ,IAAKxB,EAAGU,MAAMU,KAAiBpB,EAAGU,MAAM2B,GACtC,MAAM,IAAIb,MACR,SAASJ,QAAkBiB,qBAG/BL,EAAiBb,GACjBZ,KAAKwJ,cChNO,SACdC,EACA7I,EACAnB,EACAiK,EACAC,EACA7I,GAEA,IAAI8I,EAAe,EACfC,GAAU,EACd,MAAMC,EAAeC,GAAU,KAC7BtI,EAAiBb,GACjB,MAAMkB,EAAerC,EAAGU,MAAMwJ,GAI9B,OAAOlH,QAAQU,IAAI,EAChByG,EAAe,EACZ9H,EACGsB,MAAM,KACNwB,QAAQgF,EAAclF,KAAU,GAChCpB,UACAP,MAAMwC,GACLA,EAAQS,QAAQI,GAAuC,IAA5Bf,EAAIe,EAAOjB,EAAGrE,OAE7CgB,EAAasB,MAAM,CAAE+B,EAAGrE,IAAYwC,WACtCP,MAAMwC,GACCA,IAET9F,EAAGU,MAAMuJ,GAAiBtG,MAAM,OAAO4G,OAAOlJ,GAAUwC,WACxD,IACD2G,WACD,EAAE1E,EAAS2E,MACL3E,EAAQtF,OAAS,IAAG2J,EAAerE,EAAQA,EAAQtF,OAAS,GAAG6D,GAC1C,IAArBoG,EAAUjK,QAKdwB,EAAiBb,GACb2E,EAAQtF,OAAS,GACnB+B,EAAEmI,SACAvJ,GACA,KACE2E,EAAQY,SAASC,IACf,IACEU,EAAoBV,GACpBpE,EAAEqE,cAAczF,EAAKwF,EAAOH,EAC7B,CAAS,QACRa,EAAoB,KACrB,IACD,GAEJ2C,GACA,GAGAI,IACFA,GAAU,EACVjJ,EAAIwJ,KAAK,OAAQ,CAACxJ,MAvBlBA,EAAIqH,SAwBL,IAEFsB,IACCE,EAASvH,GAAG,SAASgG,KAAKqB,EAAM,IAI9Bc,EAAW,CAACjE,EAAoBkE,KAChCA,IAAWb,GACfhK,EAAGU,MAAMwJ,GACNhJ,IAAI,CACHwE,EAAGrE,EACHmF,EAAGG,EACHlB,EAAG,IAEJnC,MAAMe,IAKDA,IAAM8F,EAAe,KAAKA,CAAY,IAE3CW,OAAOhB,IACNE,EAASvH,GAAG,SAASgG,KAAKqB,EAAM,GAChC,EAGAC,EAAgB,KACpBM,EAAaZ,cACbtI,EAAIoI,IAAI,WAAYqB,GACpBzJ,EAAIoI,IAAI,UAAWQ,EAAc,EAMnC,OAHA5I,EAAIsB,GAAG,WAAYmI,GACnBzJ,EAAIsB,GAAG,UAAWsH,GAEXA,CACT,CD+GyBgB,CACnBxK,KACAY,EACAnB,EACAoB,EACAiB,EACAhB,GAEFuG,EAAenF,GAAG,OAAOgG,KAAKlI,KAC/B,CAED,OAAAiI,SAEEhB,EAAG9E,OAAOnC,KAAKY,KACfZ,KAAKY,IAAM,KACXZ,KAAK+I,WAAY,EACjB/I,KAAKwH,SAAW,EACE,QAAlBiD,EAAAzK,KAAKwJ,qBAAa,IAAAiB,GAAAA,EAAAvL,KAAAc,MAClBA,KAAKkC,GAAKiF,IACVnH,KAAK8I,gBAAgB3C,SAASuE,GAAYA,KAC3C,CAED,iBAAAC,CAAkBC,GAChB5K,KAAK8I,gBAAgBtD,KACO,mBAAnBoF,EACHA,EACA,IAAMA,EAAe1B,cAE5B,EA/MM7B,EAAAnF,GAAMG,EAAM+E,OAAe,KAAM,CACtCyD,IAAK,CEtCO,SAAuBC,EAAcC,GACjD,OAAID,IAAO9D,EAAY+D,EAChB,WACHD,EAAGE,MAAMhL,KAAMiL,WACfF,EAAGC,MAAMhL,KAAMiL,UACnB,CACJ,GFiCIC,aAAc,CGvCF,SAAgBJ,EAAIC,GAChC,OAAID,IAAO9D,EAAY+D,EAChB,WACH,IAAII,EAAML,EAAGE,MAAMhL,KAAMiL,WACzB,GAAIE,GAA2B,mBAAbA,EAAIpI,KAAqB,CAIvC,IAHA,IAAIqI,EAAOpL,KACP8D,EAAImH,UAAUhL,OACdoL,EAAO,IAAIC,MAAMxH,GACdA,KAAKuH,EAAKvH,GAAKmH,UAAUnH,GAChC,OAAOqH,EAAIpI,MAAK,WACZ,OAAOgI,EAAGC,MAAMI,EAAMC,EAC1B,GACH,CACD,OAAON,EAAGC,MAAMhL,KAAMiL,UAC1B,CACJ,KHsHS5D,EAAW7H,YAAGA,EA8HnB6C,EAAsB,eAExBgF,EAAiBhF,EAAsB,gBAAKgF,EAE5ChF,EAAsB,eAAIgF,EIpQ5B,MAAMkE,EAAsB,gBAUJ,SAAAC,EAAOC,GAG7B,GAAM,gBAAiBA,EASrB,OAAOC,EAAmBD,EAAa,CAAA,GATJ,CAGnC,MAAMlE,EAAUkE,EAEhB,OAAQhM,GAAciM,EAAmBjM,EAAI8H,EAC9C,CAKH,CAEA,SAASmE,EAAmBjM,EAAW8H,GACrC9H,EAAGkM,MAAQ,cAAqBlM,EAAGkM,MACjC,UAAAC,CAAW/C,GACL7I,KAAK6C,OAAOC,SACd+F,EAAc,cAAeA,IAC7B7I,KAAK6C,OAAOC,OAAOqD,SAAQ,EAAElH,OAAM6C,mBACjChC,OAAO+L,eAAehD,EAAYiD,UAAW7M,ET/BjD,SACJQ,EACAU,EACAlB,EACA6C,GAEA,MAAMiK,EAAY5L,EAAM0C,OAAOmJ,QAAQC,QACvC,IAAKF,EACH,MAAM,IAAI9K,MACR,oCAAoCd,EAAM8I,QAAQhK,sFAGtD,MAAM2C,EAAWpC,EAAYC,GAC7B,MAAO,CACL,GAAAoI,GACE,MAAM,IAAIqE,UAAU,iCACrB,EACD,GAAA1I,GACE,MAAMzB,EAAKK,EAAapC,KAAM+L,GAC9B,OAAOpK,EACLlC,EACAmC,EACAzB,EAAM8I,KACNhK,EACA6C,EACAC,EAEH,EAEL,CSE6DoK,CAAmB1M,EAAIO,KAAMf,EAAM6C,GAAc,KAGxG,MAAMsK,EAASC,MAAMT,WAAW/C,GAEhC,OADA7I,KAAK6C,OAAOyJ,YAAczD,EACnBuD,CACR,GAGH3M,EAAG8M,QAAU,cAAuB9M,EAAG8M,QACrC,kBAAAC,CACEvD,EACA+C,EACAS,GAEA,MAAM3J,EAAS2J,EAAQzG,QACpB0G,GAAqB,MAAbA,EAAIC,MAA6B,UAAbD,EAAIC,OAEnCF,EAAUA,EAAQzG,QAAQ0G,IAAS5J,EAAO8J,SAASF,KACnD,MAAMG,EAAcR,MAAMG,mBACxBvD,EACA+C,EACAS,GAQF,OANI3J,EAAO7C,OAAS,IAClB4M,EAAY/J,OAASA,EAAOyB,KAAKmI,IAAS,CACxCzN,KAAMyN,EAAIzD,KACVnH,aAAc,IAAImH,KAAQyD,EAAIzD,oBAG3B4D,CACR,CAED,gBAAAC,CACEC,EACAC,GAIAX,MAAMS,iBAAiBC,EAAQC,GAG/BlN,OAAOC,KAAKgN,GAAQ5G,SAAStE,IAC3B,MAAMoL,EAAYD,EAAUnL,GAC5B,GAAIoL,EACF,IAAK,MAAMrK,KAASqK,EAAUnK,QAAU,GACtCuJ,MAAMS,iBAeJ,CAAE,CAAClK,EAAMd,cAAe,SACxBkL,EAGL,GAEJ,CAED,MAAAD,CAAOlK,GACL,MAAMpD,EAAKO,KAAKP,GAGV2M,EAASC,MAAMU,OAAOlK,GACtBqK,EAAWzN,EAAG0N,UZvGpB,IAA8BC,EY6H9B,OArBAtN,OAAOC,KAAKmN,GAAU/G,SAAStE,IACzBqL,EAASrL,GAAWiB,QAItBrD,EAAGU,MAAM0B,GAAW+J,WAClBsB,EAASrL,GAAWyK,aAAexM,OAEtC,IAECA,OAAOuN,OAAOH,GAAUI,MAAMnN,GAAUA,EAAM2C,SAChDrD,EAAG8N,IAAI,CACLC,MAAO,SACPvE,KAAMsC,EACNkC,MAAO,GACPC,QZvH0BN,EYuHEF,EZtH5BS,GACL7N,OAAAkE,OAAAlE,OAAAkE,OAAA,CAAA,EACI2J,GAAQ,CACX,KAAAxN,CAAM0B,GACJ,MAAM+L,EAAYD,EAASxN,MAAM0B,GAC3BgM,EAAgBT,EAASvL,IACzBiB,OAAEA,GAAW+K,EACnB,OAAK/K,GAA4B,IAAlBA,EAAO7C,OAEjBH,OAAAkE,OAAAlE,OAAAkE,OAAA,CAAA,EAAA4J,GACH,CAAA,MAAAE,CAAOC,GACL,GAAiB,QAAbA,EAAIpB,MAA+B,QAAboB,EAAIpB,KAC5B,OAAOiB,EAAUE,OAAOC,GAE1B,IAAIC,EAAWD,EACf,MAAME,EAAgBnL,EACnByB,KAAK/B,IAAO,CACXA,IACA0L,QAASH,EAAIV,OAAOc,SAIjB,CAACC,EAAOC,KACT,IAAKD,GAA0B,iBAAVA,EACnB,MAAM,IAAIlC,UACR,SAASrK,mDAEb,IAAK9C,EAAOqP,EAAO5L,EAAEvD,MAAO,MAAO,GAE/B+O,IAAaD,IACfC,EAAQlO,OAAAkE,OAAAlE,OAAAkE,OAAA,GACH+J,GACH,CAAAV,OAAQU,EAAIV,OAAO9I,KAAK+J,oBAAYA,eAGjCN,EAASX,OAAOgB,GAAM7L,EAAEvD,MAE/B,MAAM2B,EAAMwN,EAAM5L,EAAEvD,MACpB,GAAY,OAAR2B,EACF,MAAM,IAAIsL,UAAU,iCAEtB,QAAYxL,IAARE,EAAmB,OAAOzB,EAE9B,GAAmB,iBAARyB,KAAsB,eAAgBA,GAC/C,MAAM,IAAIsL,UACR,gGAGJ,GAAiB,QAAb6B,EAAIpB,KAEN,MAAM,IAAIT,UACR,WAAWrK,KAAaW,EAAEvD,qBAAqBuD,EAAEvD,+DAA+D4C,mCAEpH,OAAwC,IAApCG,EAAEuM,kBAAkB3N,GAAKX,OAEpBd,EAGF,CACLkP,OACApI,EAAGjE,EAAEuE,sBAAsB3F,GAC5B,QAGJoF,QAAO,EAAGkI,aAAcA,EAAQjO,OAAS,IAC5C,OAAI8N,IAAQC,EAEHJ,EAAUE,OAAOC,GAInBH,EAAUE,OAAOE,GAAUjL,MAAMoI,GACT,IAAzB8C,EAAchO,OAETkL,EAEF1I,QAAQU,IACb8K,EAAc1J,KAAI,EAAG/B,IAAG0L,cACtB,MAAMpM,EAAe6L,EAASxN,MAAMqC,EAAEV,cAChC0M,EAA2CN,EAAQ3J,KACvD,EAAG8J,OAAMpI,QACN,CACCd,EAAGgG,EAAIsD,QAASJ,GAChBpI,IACAf,EAAG,MAGT,OAAOpD,EAAagM,OAAO,CACzBnB,KAAM,MACNU,OAAQmB,EACRE,MAAOX,EAAIW,OACX,KAEJ3L,MAAK,IAAMoI,KAEhB,IAxFwCyC,CA2F5C,OYuBCnO,EAAGkP,MAAM,CAAEnB,MAAO,SAAUvE,KAAMsC,IAG7Ba,CACR,IAGiB,KAAhB7E,aAAO,EAAPA,EAASrB,KPnIT,SAAqBzG,GACzB,IAAImP,EAAa,KACjBnP,EAAGyC,GACD,SACCzC,IACC,GAAIA,EAAGkD,OAAO2K,MAAKuB,GAAOA,EAAIhM,OAAOC,SAAS,CAC5C,MAAMoD,EAAK,KACJzG,EAAGqP,UACRxM,EAAc7C,EAAImH,GAAa2D,OAAMwE,KAC/BA,GAAOA,EAAI9F,IAC+B,IAC7ClG,MAAK,KACN6L,EAAQ5G,WAAW9B,EAAIU,EAAY,GACnC,EAEJgI,EAAQ5G,WAAW9B,EAAIS,EACxB,KAEH,GAEFlH,EAAGyC,GAAG,SAAS,KACT0M,GAAOhH,aAAagH,GACxBA,EAAQ,IAAI,GAEhB,CO4GII,CAAWvP,EAEf"}