import {
  Dexie,
  PropModification,
  RangeSet,
  cmp,
  import_wrapper_default,
  liveQuery
} from "./chunk-IJKYOAY4.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var min = (a2, b) => a2 < b ? a2 : b;
var max = (a2, b) => a2 > b ? a2 : b;
var isNaN2 = Number.isNaN;
var isNegativeZero = (n2) => n2 !== 0 ? n2 < 0 : 1 / n2 < 0;

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/set.js
var create = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i2 = 0; i2 < src.length; i2++) {
    dest.push(src[i2]);
  }
};
var from2 = Array.from;
var every = (arr, f2) => {
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (!f2(arr[i2], i2, arr)) {
      return false;
    }
  }
  return true;
};
var some = (arr, f2) => {
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (f2(arr[i2], i2, arr)) {
      return true;
    }
  }
  return false;
};
var unfold = (len, f2) => {
  const array = new Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    array[i2] = f2(i2, array);
  }
  return array;
};
var isArray = Array.isArray;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s2) => s2.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s2) => s2.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s2, separator) => trimLeft(s2.replace(fromCamelCaseRegex, (match2) => `${separator}${toLowerCase(match2)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i2 = 0; i2 < len; i2++) {
    buf[i2] = /** @type {number} */
    encodedString.codePointAt(i2);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}
var repeat = (source, n2) => unfold(n2, () => source).join("");

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
    len += encoder.bufs[i2].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i2 = 0; i2 < encoder.bufs.length; i2++) {
    const d2 = encoder.bufs[i2];
    uint8arr.set(d2, curPos);
    curPos += d2.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i2 = 0; i2 < written; i2++) {
      write(encoder, _strBuffer[i2]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i2 = 0; i2 < len; i2++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i2)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeBinaryEncoder = (encoder, append2) => writeUint8Array(encoder, toUint8Array(append2));
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var writeBigUint64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigUint64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i2 = 0; i2 < data.length; i2++) {
          writeAny(encoder, data[i2]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder, keys2.length);
        for (let i2 = 0; i2 < keys2.length; i2++) {
          const key = keys2[i2];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v2) {
    if (this.s === v2) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v2);
      this.s = v2;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v2) {
    if (this.s === v2) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v2;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v2) {
    if (this.diff === v2 - this.s) {
      this.s = v2;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v2 - this.s;
      this.s = v2;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// node_modules/lib0/error.js
var create2 = (s2) => new Error(s2);
var methodUnimplemented = () => {
  throw create2("Method unimplemented");
};
var unexpectedCase = () => {
  throw create2("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create2("Unexpected end of array");
var errorIntegerOutOfRange = create2("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array<Buf>} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r2 = decoder.arr[decoder.pos++];
    num = num + (r2 & BITS7) * mult;
    mult *= 128;
    if (r2 < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r2 = decoder.arr[decoder.pos++];
  let num = r2 & BITS6;
  let mult = 64;
  const sign = (r2 & BIT7) > 0 ? -1 : 1;
  if ((r2 & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r2 = decoder.arr[decoder.pos++];
    num = num + (r2 & BITS7) * mult;
    mult *= 128;
    if (r2 < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readBigUint64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigUint64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i2 = 0; i2 < len; i2++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i2 = 0; i2 < len; i2++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d2, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
    d3.__proto__ = b2;
  } || function(d3, b2) {
    for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
  };
  return extendStatics(d2, b);
};
function __extends(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g2.next = verb(0), g2["throw"] = verb(1), g2["return"] = verb(2), typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2) return o2;
  var i2 = m2.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from4, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from4.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from4)) {
      if (!ar) ar = Array.prototype.slice.call(from4, 0, i2);
      ar[i2] = from4[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from4));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f2) {
    return function(v2) {
      return Promise.resolve(v2).then(f2, reject);
    };
  }
  function verb(n2, f2) {
    if (g2[n2]) {
      i2[n2] = function(v2) {
        return new Promise(function(a2, b) {
          q2.push([n2, v2, a2, b]) > 1 || resume(n2, v2);
        });
      };
      if (f2) i2[n2] = f2(i2[n2]);
    }
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = (function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = (function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  })();
  return Subscription2;
})();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args2)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args2)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = (function() {
  return createNotification("C", void 0, void 0);
})();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = (function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
})(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = (function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
})();
var SafeSubscriber = (function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
})(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = (function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
})();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x2) {
  return x2;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = (function() {
  function Observable3(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable3.prototype.lift = function(operator) {
    var observable2 = new Observable3();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable3.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable3.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable3.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable3.prototype[observable] = function() {
    return this;
  };
  Observable3.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable3.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x2) {
        return value = x2;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable3.create = function(subscribe) {
    return new Observable3(subscribe);
  };
  return Observable3;
})();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
})(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = (function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
})(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args2)));
  },
  cancelAnimationFrame: function() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args2)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id2 = 0;
    var run = function() {
      if (!subscriber.closed) {
        id2 = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id2 = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id2) {
        animationFrameProvider.cancelAnimationFrame(id2);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = (function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
})(Observable);
var AnonymousSubject = (function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = (function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = (function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy2 = _buffer.slice();
    for (var i2 = 0; i2 < copy2.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy2[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last4 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now; i2 += 2) {
        last4 = i2;
      }
      last4 && _buffer.splice(0, last4 + 1);
    }
  };
  return ReplaySubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = (function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
})(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = (function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
})(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args2 = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args2[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args2)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args2)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = (function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id2 = this.id;
    var scheduler = this.scheduler;
    if (id2 != null) {
      this.id = this.recycleAsyncId(scheduler, id2, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id2;
    }
    if (id2 != null) {
      intervalProvider.clearInterval(id2);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id2 = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id2 != null) {
        this.id = this.recycleAsyncId(scheduler, id2, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
})(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args2 = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args2[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args2)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = (function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    var actions = scheduler.actions;
    if (id2 != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
      immediateProvider.clearImmediate(id2);
      if (scheduler._scheduled === id2) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = (function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
})();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = (function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
})(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = (function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = (function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = (function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = (function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id2, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id2, delay2);
    }
    var actions = scheduler.actions;
    if (id2 != null && id2 === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id2) {
      animationFrameProvider.cancelAnimationFrame(id2);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = (function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
})(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = (function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
})(AsyncScheduler);
var VirtualAction = (function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id2, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a2, b) {
    if (a2.delay === b.delay) {
      if (a2.index === b.index) {
        return 0;
      } else if (a2.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
})(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last2(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args2) {
  return isFunction(last2(args2)) ? args2.pop() : void 0;
}
function popScheduler(args2) {
  return isScheduler(last2(args2)) ? args2.pop() : void 0;
}
function popNumber(args2, defaultValue) {
  return typeof last2(args2) === "number" ? args2.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = (function(x2) {
  return x2 && typeof x2.length === "number" && typeof x2 !== "function";
});

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat3) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat3 === void 0) {
    repeat3 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat3) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat3) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from3(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args2);
  return from3(args2, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = (function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
})();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray2 = Array.isArray;
function callOrApply(fn, args2) {
  return isArray2(args2) ? fn.apply(void 0, __spreadArray([], __read(args2))) : fn(args2);
}
function mapOneOrManyArgs(fn) {
  return map(function(args2) {
    return callOrApply(fn, args2);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray3 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args2) {
  if (args2.length === 1) {
    var first_1 = args2[0];
    if (isArray3(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys2 = getKeys(first_1);
      return {
        args: keys2.map(function(key) {
          return first_1[key];
        }),
        keys: keys2
      };
    }
  }
  return { args: args2, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys2, values) {
  return keys2.reduce(function(result, key, i2) {
    return result[key] = values[i2], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args2);
  var resultSelector = popResultSelector(args2);
  var _a = argsArgArrayOrObject(args2), observables = _a.args, keys2 = _a.keys;
  if (observables.length === 0) {
    return from3([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys2 ? function(values) {
    return createObject(keys2, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length2 = observables.length;
      var values = new Array(length2);
      var active = length2;
      var remainingFirstValues = length2;
      var _loop_1 = function(i3) {
        maybeSchedule(scheduler, function() {
          var source = from3(observables[i3], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i3] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i2 = 0; i2 < length2; i2++) {
        _loop_1(i2);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a2, i2) {
      return map(function(b, ii) {
        return resultSelector(a2, b, i2, ii);
      })(innerFrom(project(a2, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  return concatAll()(from3(args2, popScheduler(args2)));
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i];
      }
      return subscriber.next(1 < args2.length ? args2 : args2[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n2 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args2 = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args2[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args2);
  var concurrent = popNumber(args2, Infinity);
  var sources = args2;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from3(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/ignoreElements.js
function ignoreElements() {
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, noop));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mapTo.js
function mapTo(value) {
  return map(function() {
    return value;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/delayWhen.js
function delayWhen(delayDurationSelector, subscriptionDelay) {
  if (subscriptionDelay) {
    return function(source) {
      return concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));
    };
  }
  return mergeMap(function(value, index) {
    return innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/delay.js
function delay(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  var duration = timer(due, scheduler);
  return delayWhen(function() {
    return duration;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a2, b) {
  return a2 === b;
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args2 = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args2[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args2)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/skip.js
function skip(count2) {
  return filter(function(_2, index) {
    return count2 <= index;
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/lib0/map.js
var create3 = () => /* @__PURE__ */ new Map();
var copy = (m2) => {
  const r2 = create3();
  m2.forEach((v2, k2) => {
    r2.set(k2, v2);
  });
  return r2;
};
var setIfUndefined = (map4, key, createT) => {
  let set = map4.get(key);
  if (set === void 0) {
    map4.set(key, set = createT());
  }
  return set;
};
var map2 = (m2, f2) => {
  const res = [];
  for (const [key, value] of m2) {
    res.push(f2(value, key));
  }
  return res;
};
var any = (m2, f2) => {
  for (const [key, value] of m2) {
    if (f2(value, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create3();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f2) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create
    ).add(f2);
    return f2;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f2) {
    const _f = (...args2) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f2(...args2);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f2) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f2);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create3()).values()).forEach((f2) => f2(...args2));
  }
  destroy() {
    this._observers = create3();
  }
};
var Observable2 = class {
  constructor() {
    this._observers = create3();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f2) {
    setIfUndefined(this._observers, name, create).add(f2);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f2) {
    const _f = (...args2) => {
      this.off(name, _f);
      f2(...args2);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f2) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f2);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from2((this._observers.get(name) || create3()).values()).forEach((f2) => f2(...args2));
  }
  destroy() {
    this._observers = create3();
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = "10000000-1000-4000-8000" + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c2) => (c2 ^ uint32() & 15 >> c2 / 4).toString(16)
);

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/promise.js
var create4 = (f2) => (
  /** @type {Promise<T>} */
  new Promise(f2)
);
var all = Promise.all.bind(Promise);

// node_modules/lib0/conditions.js
var undefinedToNull = (v2) => v2 === void 0 ? null : v2;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e2) {
}
var varStorage = _localStorage;

// node_modules/lib0/trait/equality.js
var EqualityTraitSymbol = /* @__PURE__ */ Symbol("Equality");
var equals = (a2, b) => a2 === b || !!a2?.[EqualityTraitSymbol]?.(b) || false;

// node_modules/lib0/object.js
var isObject = (o2) => typeof o2 === "object";
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f2) => {
  for (const key in obj) {
    f2(obj[key], key);
  }
};
var size = (obj) => keys(obj).length;
var isEmpty2 = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every3 = (obj, f2) => {
  for (const key in obj) {
    if (!f2(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a2, b) => a2 === b || size(a2) === size(b) && every3(a2, (val, key) => (val !== void 0 || hasProperty(b, key)) && equals(b[key], val));
var freeze = Object.freeze;
var deepFreeze = (o2) => {
  for (const key in o2) {
    const c2 = o2[key];
    if (typeof c2 === "object" || typeof c2 === "function") {
      deepFreeze(o2[key]);
    }
  }
  return freeze(o2);
};

// node_modules/lib0/function.js
var callAll = (fs, args2, i2 = 0) => {
  try {
    for (; i2 < fs.length; i2++) {
      fs[i2](...args2);
    }
  } finally {
    if (i2 < fs.length) {
      callAll(fs, args2, i2 + 1);
    }
  }
};
var equalityDeep = (a2, b) => {
  if (a2 === b) {
    return true;
  }
  if (a2 == null || b == null || a2.constructor !== b.constructor && (a2.constructor || Object) !== (b.constructor || Object)) {
    return false;
  }
  if (a2[EqualityTraitSymbol] != null) {
    return a2[EqualityTraitSymbol](b);
  }
  switch (a2.constructor) {
    case ArrayBuffer:
      a2 = new Uint8Array(a2);
      b = new Uint8Array(b);
    // eslint-disable-next-line no-fallthrough
    case Uint8Array: {
      if (a2.byteLength !== b.byteLength) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (a2[i2] !== b[i2]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a2.size !== b.size) {
        return false;
      }
      for (const value of a2) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a2.size !== b.size) {
        return false;
      }
      for (const key of a2.keys()) {
        if (!b.has(key) || !equalityDeep(a2.get(key), b.get(key))) {
          return false;
        }
      }
      break;
    }
    case void 0:
    case Object:
      if (size(a2) !== size(b)) {
        return false;
      }
      for (const key in a2) {
        if (!hasProperty(a2, key) || !equalityDeep(a2[key], b[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a2.length !== b.length) {
        return false;
      }
      for (let i2 = 0; i2 < a2.length; i2++) {
        if (!equalityDeep(a2[i2], b[i2])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create3();
      const pargs = process.argv;
      let currParamName = null;
      for (let i2 = 0; i2 < pargs.length; i2++) {
        const parg = pargs[i2];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create3();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create3();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
!hasConf("no-color") && (!isNode || process.stdout.isTTY) && (!isNode || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);

// node_modules/lib0/prng.js
var bool = (gen) => gen.next() >= 0.5;
var int53 = (gen, min3, max3) => floor(gen.next() * (max3 + 1 - min3) + min3);
var int32 = (gen, min3, max3) => floor(gen.next() * (max3 + 1 - min3) + min3);
var int31 = (gen, min3, max3) => int32(gen, min3, max3);
var letter = (gen) => fromCharCode(int31(gen, 97, 122));
var word = (gen, minLen = 0, maxLen = 20) => {
  const len = int31(gen, minLen, maxLen);
  let str = "";
  for (let i2 = 0; i2 < len; i2++) {
    str += letter(gen);
  }
  return str;
};
var oneOf = (gen, array) => array[int31(gen, 0, array.length - 1)];

// node_modules/lib0/schema.js
var schemaSymbol = /* @__PURE__ */ Symbol("0schema");
var ValidationError = class {
  constructor() {
    this._rerrs = [];
  }
  /**
   * @param {string?} path
   * @param {string} expected
   * @param {string} has
   * @param {string?} message
   */
  extend(path, expected, has, message = null) {
    this._rerrs.push({ path, expected, has, message });
  }
  toString() {
    const s2 = [];
    for (let i2 = this._rerrs.length - 1; i2 > 0; i2--) {
      const r2 = this._rerrs[i2];
      s2.push(repeat(" ", (this._rerrs.length - i2) * 2) + `${r2.path != null ? `[${r2.path}] ` : ""}${r2.has} doesn't match ${r2.expected}. ${r2.message}`);
    }
    return s2.join("\n");
  }
};
var shapeExtends = (a2, b) => {
  if (a2 === b) return true;
  if (a2 == null || b == null || a2.constructor !== b.constructor) return false;
  if (a2[EqualityTraitSymbol]) return equals(a2, b);
  if (isArray(a2)) {
    return every(
      a2,
      (aitem) => some(b, (bitem) => shapeExtends(aitem, bitem))
    );
  } else if (isObject(a2)) {
    return every3(
      a2,
      (aitem, akey) => shapeExtends(aitem, b[akey])
    );
  }
  return false;
};
var Schema = class {
  // this.shape must not be defined on Schema. Otherwise typecheck on metatypes (e.g. $$object) won't work as expected anymore
  /**
   * If true, the more things are added to the shape the more objects this schema will accept (e.g.
   * union). By default, the more objects are added, the the fewer objects this schema will accept.
   * @protected
   */
  static _dilutes = false;
  /**
   * @param {Schema<any>} other
   */
  extends(other) {
    let [a2, b] = [
      /** @type {any} */
      this.shape,
      /** @type {any} */
      other.shape
    ];
    if (
      /** @type {typeof Schema<any>} */
      this.constructor._dilutes
    ) [b, a2] = [a2, b];
    return shapeExtends(a2, b);
  }
  /**
   * Overwrite this when necessary. By default, we only check the `shape` property which every shape
   * should have.
   * @param {Schema<any>} other
   */
  equals(other) {
    return this.constructor === other.constructor && equalityDeep(this.shape, other.shape);
  }
  [schemaSymbol]() {
    return true;
  }
  /**
   * @param {object} other
   */
  [EqualityTraitSymbol](other) {
    return this.equals(
      /** @type {any} */
      other
    );
  }
  /**
   * Use `schema.validate(obj)` with a typed parameter that is already of typed to be an instance of
   * Schema. Validate will check the structure of the parameter and return true iff the instance
   * really is an instance of Schema.
   *
   * @param {T} o
   * @return {boolean}
   */
  validate(o2) {
    return this.check(o2);
  }
  /* c8 ignore start */
  /**
   * Similar to validate, but this method accepts untyped parameters.
   *
   * @param {any} _o
   * @param {ValidationError} [_err]
   * @return {_o is T}
   */
  check(_o, _err) {
    methodUnimplemented();
  }
  /* c8 ignore stop */
  /**
   * @type {Schema<T?>}
   */
  get nullable() {
    return $union(this, $null);
  }
  /**
   * @type {$Optional<Schema<T>>}
   */
  get optional() {
    return new $Optional(
      /** @type {Schema<T>} */
      this
    );
  }
  /**
   * Cast a variable to a specific type. Returns the casted value, or throws an exception otherwise.
   * Use this if you know that the type is of a specific type and you just want to convince the type
   * system.
   *
   * **Do not rely on these error messages!**
   * Performs an assertion check only if not in a production environment.
   *
   * @template OO
   * @param {OO} o
   * @return {Extract<OO, T> extends never ? T : (OO extends Array<never> ? T : Extract<OO,T>)}
   */
  cast(o2) {
    assert(o2, this);
    return (
      /** @type {any} */
      o2
    );
  }
  /**
   * EXPECTO PATRONUM!! 
   * This function protects against type errors. Though it may not work in the real world.
   *
   * "After all this time?"
   * "Always." - Snape, talking about type safety
   *
   * Ensures that a variable is a a specific type. Returns the value, or throws an exception if the assertion check failed.
   * Use this if you know that the type is of a specific type and you just want to convince the type
   * system.
   *
   * Can be useful when defining lambdas: `s.lambda(s.$number, s.$void).expect((n) => n + 1)`
   *
   * **Do not rely on these error messages!**
   * Performs an assertion check if not in a production environment.
   *
   * @param {T} o
   * @return {o extends T ? T : never}
   */
  expect(o2) {
    assert(o2, this);
    return o2;
  }
};
var $ConstructedBy = class extends Schema {
  /**
   * @param {C} c
   * @param {((o:Instance<C>)=>boolean)|null} check
   */
  constructor(c2, check) {
    super();
    this.shape = c2;
    this._c = check;
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is C extends ((...args:any[]) => infer T) ? T : (C extends (new (...args:any[]) => any) ? InstanceType<C> : never)} o
   */
  check(o2, err = void 0) {
    const c2 = o2?.constructor === this.shape && (this._c == null || this._c(o2));
    !c2 && err?.extend(null, this.shape.name, o2?.constructor.name, o2?.constructor !== this.shape ? "Constructor match failed" : "Check failed");
    return c2;
  }
};
var $constructedBy = (c2, check = null) => new $ConstructedBy(c2, check);
var $$constructedBy = $constructedBy($ConstructedBy);
var $Custom = class extends Schema {
  /**
   * @param {(o:any) => boolean} check
   */
  constructor(check) {
    super();
    this.shape = check;
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is any}
   */
  check(o2, err) {
    const c2 = this.shape(o2);
    !c2 && err?.extend(null, "custom prop", o2?.constructor.name, "failed to check custom prop");
    return c2;
  }
};
var $custom = (check) => new $Custom(check);
var $$custom = $constructedBy($Custom);
var $Literal = class extends Schema {
  /**
   * @param {Array<T>} literals
   */
  constructor(literals) {
    super();
    this.shape = literals;
  }
  /**
   *
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is T}
   */
  check(o2, err) {
    const c2 = this.shape.some((a2) => a2 === o2);
    !c2 && err?.extend(null, this.shape.join(" | "), o2.toString());
    return c2;
  }
};
var $literal = (...literals) => new $Literal(literals);
var $$literal = $constructedBy($Literal);
var _regexEscape = (
  /** @type {any} */
  RegExp.escape || /** @type {(str:string) => string} */
  ((str) => str.replace(/[().|&,$^[\]]/g, (s2) => "\\" + s2))
);
var _schemaStringTemplateToRegex = (s2) => {
  if ($string.check(s2)) {
    return [_regexEscape(s2)];
  }
  if ($$literal.check(s2)) {
    return (
      /** @type {Array<string|number>} */
      s2.shape.map((v2) => v2 + "")
    );
  }
  if ($$number.check(s2)) {
    return ["[+-]?\\d+.?\\d*"];
  }
  if ($$string.check(s2)) {
    return [".*"];
  }
  if ($$union.check(s2)) {
    return s2.shape.map(_schemaStringTemplateToRegex).flat(1);
  }
  unexpectedCase();
};
var $StringTemplate = class extends Schema {
  /**
   * @param {T} shape
   */
  constructor(shape) {
    super();
    this.shape = shape;
    this._r = new RegExp("^" + shape.map(_schemaStringTemplateToRegex).map((opts) => `(${opts.join("|")})`).join("") + "$");
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is CastStringTemplateArgsToTemplate<T>}
   */
  check(o2, err) {
    const c2 = this._r.exec(o2) != null;
    !c2 && err?.extend(null, this._r.toString(), o2.toString(), "String doesn't match string template.");
    return c2;
  }
};
var $$stringTemplate = $constructedBy($StringTemplate);
var isOptionalSymbol = /* @__PURE__ */ Symbol("optional");
var $Optional = class extends Schema {
  /**
   * @param {S} shape
   */
  constructor(shape) {
    super();
    this.shape = shape;
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is (Unwrap<S>|undefined)}
   */
  check(o2, err) {
    const c2 = o2 === void 0 || this.shape.check(o2);
    !c2 && err?.extend(null, "undefined (optional)", "()");
    return c2;
  }
  get [isOptionalSymbol]() {
    return true;
  }
};
var $$optional = $constructedBy($Optional);
var $Never = class extends Schema {
  /**
   * @param {any} _o
   * @param {ValidationError} [err]
   * @return {_o is never}
   */
  check(_o, err) {
    err?.extend(null, "never", typeof _o);
    return false;
  }
};
var $never = new $Never();
var $$never = $constructedBy($Never);
var $Object = class _$Object extends Schema {
  /**
   * @param {S} shape
   * @param {boolean} partial
   */
  constructor(shape, partial = false) {
    super();
    this.shape = shape;
    this._isPartial = partial;
  }
  static _dilutes = true;
  /**
   * @type {Schema<Partial<$ObjectToType<S>>>}
   */
  get partial() {
    return new _$Object(this.shape, true);
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is $ObjectToType<S>}
   */
  check(o2, err) {
    if (o2 == null) {
      err?.extend(null, "object", "null");
      return false;
    }
    return every3(this.shape, (vv, vk) => {
      const c2 = this._isPartial && !hasProperty(o2, vk) || vv.check(o2[vk], err);
      !c2 && err?.extend(vk.toString(), vv.toString(), typeof o2[vk], "Object property does not match");
      return c2;
    });
  }
};
var $object = (def) => (
  /** @type {any} */
  new $Object(def)
);
var $$object = $constructedBy($Object);
var $objectAny = $custom((o2) => o2 != null && (o2.constructor === Object || o2.constructor == null));
var $Record = class extends Schema {
  /**
   * @param {Keys} keys
   * @param {Values} values
   */
  constructor(keys2, values) {
    super();
    this.shape = {
      keys: keys2,
      values
    };
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is { [key in Unwrap<Keys>]: Unwrap<Values> }}
   */
  check(o2, err) {
    return o2 != null && every3(o2, (vv, vk) => {
      const ck = this.shape.keys.check(vk, err);
      !ck && err?.extend(vk + "", "Record", typeof o2, ck ? "Key doesn't match schema" : "Value doesn't match value");
      return ck && this.shape.values.check(vv, err);
    });
  }
};
var $record = (keys2, values) => new $Record(keys2, values);
var $$record = $constructedBy($Record);
var $Tuple = class extends Schema {
  /**
   * @param {S} shape
   */
  constructor(shape) {
    super();
    this.shape = shape;
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is { [K in keyof S]: S[K] extends Schema<infer Type> ? Type : never }}
   */
  check(o2, err) {
    return o2 != null && every3(this.shape, (vv, vk) => {
      const c2 = (
        /** @type {Schema<any>} */
        vv.check(o2[vk], err)
      );
      !c2 && err?.extend(vk.toString(), "Tuple", typeof vv);
      return c2;
    });
  }
};
var $tuple = (...def) => new $Tuple(def);
var $$tuple = $constructedBy($Tuple);
var $Array = class extends Schema {
  /**
   * @param {Array<S>} v
   */
  constructor(v2) {
    super();
    this.shape = v2.length === 1 ? v2[0] : new $Union(v2);
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is Array<S extends Schema<infer T> ? T : never>} o
   */
  check(o2, err) {
    const c2 = isArray(o2) && every(o2, (oi) => this.shape.check(oi));
    !c2 && err?.extend(null, "Array", "");
    return c2;
  }
};
var $array = (...def) => new $Array(def);
var $$array = $constructedBy($Array);
var $arrayAny = $custom((o2) => isArray(o2));
var $InstanceOf = class extends Schema {
  /**
   * @param {new (...args:any) => T} constructor
   * @param {((o:T) => boolean)|null} check
   */
  constructor(constructor, check) {
    super();
    this.shape = constructor;
    this._c = check;
  }
  /**
   * @param {any} o
   * @param {ValidationError} err
   * @return {o is T}
   */
  check(o2, err) {
    const c2 = o2 instanceof this.shape && (this._c == null || this._c(o2));
    !c2 && err?.extend(null, this.shape.name, o2?.constructor.name);
    return c2;
  }
};
var $instanceOf = (c2, check = null) => new $InstanceOf(c2, check);
var $$instanceOf = $constructedBy($InstanceOf);
var $$schema = $instanceOf(Schema);
var $Lambda = class extends Schema {
  /**
   * @param {Args} args
   */
  constructor(args2) {
    super();
    this.len = args2.length - 1;
    this.args = $tuple(...args2.slice(-1));
    this.res = args2[this.len];
  }
  /**
   * @param {any} f
   * @param {ValidationError} err
   * @return {f is _LArgsToLambdaDef<Args>}
   */
  check(f2, err) {
    const c2 = f2.constructor === Function && f2.length <= this.len;
    !c2 && err?.extend(null, "function", typeof f2);
    return c2;
  }
};
var $$lambda = $constructedBy($Lambda);
var $function = $custom((o2) => typeof o2 === "function");
var $Intersection = class extends Schema {
  /**
   * @param {T} v
   */
  constructor(v2) {
    super();
    this.shape = v2;
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is Intersect<UnwrapArray<T>>}
   */
  check(o2, err) {
    const c2 = every(this.shape, (check) => check.check(o2, err));
    !c2 && err?.extend(null, "Intersectinon", typeof o2);
    return c2;
  }
};
var $$intersect = $constructedBy($Intersection, (o2) => o2.shape.length > 0);
var $Union = class extends Schema {
  static _dilutes = true;
  /**
   * @param {Array<Schema<S>>} v
   */
  constructor(v2) {
    super();
    this.shape = v2;
  }
  /**
   * @param {any} o
   * @param {ValidationError} [err]
   * @return {o is S}
   */
  check(o2, err) {
    const c2 = some(this.shape, (vv) => vv.check(o2, err));
    err?.extend(null, "Union", typeof o2);
    return c2;
  }
};
var $union = (...schemas) => schemas.findIndex(($s) => $$union.check($s)) >= 0 ? $union(...schemas.map(($s) => $($s)).map(($s) => $$union.check($s) ? $s.shape : [$s]).flat(1)) : schemas.length === 1 ? schemas[0] : new $Union(schemas);
var $$union = (
  /** @type {Schema<$Union<any>>} */
  $constructedBy($Union)
);
var _t = () => true;
var $any = $custom(_t);
var $$any = (
  /** @type {Schema<Schema<any>>} */
  $constructedBy($Custom, (o2) => o2.shape === _t)
);
var $bigint = $custom((o2) => typeof o2 === "bigint");
var $$bigint = (
  /** @type {Schema<Schema<BigInt>>} */
  $custom((o2) => o2 === $bigint)
);
var $symbol = $custom((o2) => typeof o2 === "symbol");
var $$symbol = (
  /** @type {Schema<Schema<Symbol>>} */
  $custom((o2) => o2 === $symbol)
);
var $number = $custom((o2) => typeof o2 === "number");
var $$number = (
  /** @type {Schema<Schema<number>>} */
  $custom((o2) => o2 === $number)
);
var $string = $custom((o2) => typeof o2 === "string");
var $$string = (
  /** @type {Schema<Schema<string>>} */
  $custom((o2) => o2 === $string)
);
var $boolean = $custom((o2) => typeof o2 === "boolean");
var $$boolean = (
  /** @type {Schema<Schema<Boolean>>} */
  $custom((o2) => o2 === $boolean)
);
var $undefined = $literal(void 0);
var $$undefined = (
  /** @type {Schema<Schema<undefined>>} */
  $constructedBy($Literal, (o2) => o2.shape.length === 1 && o2.shape[0] === void 0)
);
var $void = $literal(void 0);
var $null = $literal(null);
var $$null = (
  /** @type {Schema<Schema<null>>} */
  $constructedBy($Literal, (o2) => o2.shape.length === 1 && o2.shape[0] === null)
);
var $uint8Array = $constructedBy(Uint8Array);
var $$uint8Array = (
  /** @type {Schema<Schema<Uint8Array>>} */
  $constructedBy($ConstructedBy, (o2) => o2.shape === Uint8Array)
);
var $primitive = $union($number, $string, $null, $undefined, $bigint, $boolean, $symbol);
var $json = (() => {
  const $jsonArr = (
    /** @type {$Array<$any>} */
    $array($any)
  );
  const $jsonRecord = (
    /** @type {$Record<$string,$any>} */
    $record($string, $any)
  );
  const $json2 = $union($number, $string, $null, $boolean, $jsonArr, $jsonRecord);
  $jsonArr.shape = $json2;
  $jsonRecord.shape.values = $json2;
  return $json2;
})();
var $ = (o2) => {
  if ($$schema.check(o2)) {
    return (
      /** @type {any} */
      o2
    );
  } else if ($objectAny.check(o2)) {
    const o22 = {};
    for (const k2 in o2) {
      o22[k2] = $(o2[k2]);
    }
    return (
      /** @type {any} */
      $object(o22)
    );
  } else if ($arrayAny.check(o2)) {
    return (
      /** @type {any} */
      $union(...o2.map($))
    );
  } else if ($primitive.check(o2)) {
    return (
      /** @type {any} */
      $literal(o2)
    );
  } else if ($function.check(o2)) {
    return (
      /** @type {any} */
      $constructedBy(
        /** @type {any} */
        o2
      )
    );
  }
  unexpectedCase();
};
var assert = production ? () => {
} : (o2, schema) => {
  const err = new ValidationError();
  if (!schema.check(o2, err)) {
    throw create2(`Expected value to be of type ${schema.constructor.name}.
${err.toString()}`);
  }
};
var PatternMatcher = class {
  /**
   * @param {Schema<State>} [$state]
   */
  constructor($state) {
    this.patterns = [];
    this.$state = $state;
  }
  /**
   * @template P
   * @template R
   * @param {P} pattern
   * @param {(o:NoInfer<Unwrap<ReadSchema<P>>>,s:State)=>R} handler
   * @return {PatternMatcher<State,Patterns|Pattern<Unwrap<ReadSchema<P>>,R>>}
   */
  if(pattern, handler) {
    this.patterns.push({ if: $(pattern), h: handler });
    return this;
  }
  /**
   * @template R
   * @param {(o:any,s:State)=>R} h
   */
  else(h2) {
    return this.if($any, h2);
  }
  /**
   * @return {State extends undefined
   *   ? <In extends Unwrap<Patterns['if']>>(o:In,state?:undefined)=>PatternMatchResult<Patterns,In>
   *   : <In extends Unwrap<Patterns['if']>>(o:In,state:State)=>PatternMatchResult<Patterns,In>}
   */
  done() {
    return (
      /** @type {any} */
      (o2, s2) => {
        for (let i2 = 0; i2 < this.patterns.length; i2++) {
          const p2 = this.patterns[i2];
          if (p2.if.check(o2)) {
            return p2.h(o2, s2);
          }
        }
        throw create2("Unhandled pattern");
      }
    );
  }
};
var match = (state) => new PatternMatcher(
  /** @type {any} */
  state
);
var _random = (
  /** @type {any} */
  match(
    /** @type {Schema<prng.PRNG>} */
    $any
  ).if($$number, (_o, gen) => int53(gen, MIN_SAFE_INTEGER, MAX_SAFE_INTEGER)).if($$string, (_o, gen) => word(gen)).if($$boolean, (_o, gen) => bool(gen)).if($$bigint, (_o, gen) => BigInt(int53(gen, MIN_SAFE_INTEGER, MAX_SAFE_INTEGER))).if($$union, (o2, gen) => random(gen, oneOf(gen, o2.shape))).if($$object, (o2, gen) => {
    const res = {};
    for (const k2 in o2.shape) {
      let prop = o2.shape[k2];
      if ($$optional.check(prop)) {
        if (bool(gen)) {
          continue;
        }
        prop = prop.shape;
      }
      res[k2] = _random(prop, gen);
    }
    return res;
  }).if($$array, (o2, gen) => {
    const arr = [];
    const n2 = int32(gen, 0, 42);
    for (let i2 = 0; i2 < n2; i2++) {
      arr.push(random(gen, o2.shape));
    }
    return arr;
  }).if($$literal, (o2, gen) => {
    return oneOf(gen, o2.shape);
  }).if($$null, (o2, gen) => {
    return null;
  }).if($$lambda, (o2, gen) => {
    const res = random(gen, o2.res);
    return () => res;
  }).if($$any, (o2, gen) => random(gen, oneOf(gen, [
    $number,
    $string,
    $null,
    $undefined,
    $bigint,
    $boolean,
    $array($number),
    $record($union("a", "b", "c"), $number)
  ]))).if($$record, (o2, gen) => {
    const res = {};
    const keysN = int53(gen, 0, 3);
    for (let i2 = 0; i2 < keysN; i2++) {
      const key = random(gen, o2.shape.keys);
      const val = random(gen, o2.shape.values);
      res[key] = val;
    }
    return res;
  }).done()
);
var random = (gen, schema) => (
  /** @type {any} */
  _random($(schema), gen)
);

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var $fragment = $custom((el) => el.nodeType === DOCUMENT_FRAGMENT_NODE);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var $element = $custom((el) => el.nodeType === ELEMENT_NODE);
var $text = $custom((el) => el.nodeType === TEXT_NODE);
var mapToStyleString = (m2) => map2(m2, (value, key) => `${key}:${value};`).join("");
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;
var $node = $custom((el) => el.nodeType === DOCUMENT_NODE);

// node_modules/lib0/eventloop.js
var createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
var Timeout = createTimeoutClass(clearTimeout);
var Interval = createTimeoutClass(clearInterval);
var Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== "undefined" && cancelAnimationFrame(arg));
var Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== "undefined" && cancelIdleCallback(arg));

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  if (args2.length === 1 && args2[0]?.constructor === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i2 = 0;
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (arg === void 0) {
      break;
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      break;
    }
  }
  if (i2 > 0) {
    logArgs.push(strBuilder.join(""));
  }
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var lastLoggingTime = getUnixTime();

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  if (args2.length === 1 && args2[0]?.constructor === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create3();
  let logArgs = [];
  let i2 = 0;
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i2 > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i2 > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i2 < args2.length; i2++) {
    const arg = args2[i2];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var warn = (...args2) => {
  console.warn(...computeLoggingArgs(args2));
  args2.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create();

// node_modules/lib0/iterator.js
var createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
var iteratorFilter = (iterator2, filter2) => createIterator(() => {
  let res;
  do {
    res = iterator2.next();
  } while (!res.done && !filter2(res.value));
  return res;
});
var iteratorMap = (iterator2, fmap) => createIterator(() => {
  const { done, value } = iterator2.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f2) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  if (structs != null) {
    const lastStruct = structs[structs.length - 1];
    const clockState = lastStruct.id.clock + lastStruct.length;
    for (let i2 = 0, del = deletes[i2]; i2 < deletes.length && del.clock < clockState; del = deletes[++i2]) {
      iterateStructs(transaction, structs, del.clock, del.len, f2);
    }
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a2, b) => a2.clock - b.clock);
    let i2, j2;
    for (i2 = 1, j2 = 1; i2 < dels.length; i2++) {
      const left = dels[j2 - 1];
      const right = dels[i2];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j2 < i2) {
          dels[j2] = right;
        }
        j2++;
      }
    }
    dels.length = j2;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i2 = dssI + 1; i2 < dss.length; i2++) {
          appendTo(dels, dss[i2].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length2) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length2));
};
var createDeleteSet = () => new DeleteSet();
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from2(ds.clients.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i2 = 0; i2 < len; i2++) {
      const item = dsitems[i2];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i3 = 0; i3 < numberOfDeletes; i3++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numClients; i2++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i3 = 0; i3 < numberOfDeletes; i3++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class _Doc extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.isDestroyed = false;
    this.whenLoaded = create4((resolve) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from2(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f2, origin = null) {
    return transact(this, f2, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type = setIfUndefined(this.share, name, () => {
      const t2 = new TypeConstructor();
      t2._integrate(this, null);
      return t2;
    });
    const Constr = type.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t2 = new TypeConstructor();
        t2._map = type._map;
        type._map.forEach(
          /** @param {Item?} n */
          (n2) => {
            for (; n2 !== null; n2 = n2.left) {
              n2.parent = t2;
            }
          }
        );
        t2._start = type._start;
        for (let n2 = t2._start; n2 !== null; n2 = n2.right) {
          n2.parent = t2;
        }
        t2._length = type._length;
        this.share.set(name, t2);
        t2._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t2
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    this.isDestroyed = true;
    from2(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    writeVarString(this.restEncoder, s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s2) {
    this.stringEncoder.write(s2);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i2 = startNewStructs + 1; i2 < structs.length; i2++) {
    structs[i2].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from2(sm.entries()).sort((a2, b) => b[0] - a2[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create3();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i3] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i3] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // left
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i3] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a2, b) => a2 - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const inapplicableItems = clientsStructRefs.get(client);
      if (inapplicableItems) {
        inapplicableItems.i--;
        restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));
        clientsStructRefs.delete(client);
        inapplicableItems.i = 0;
        inapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c2) => c2 !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry2 = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry2 = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry2) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f2) => eventHandler.l.push(f2);
var removeEventHandlerListener = (eventHandler, f2) => {
  const l2 = eventHandler.l;
  const len = l2.length;
  eventHandler.l = l2.filter((g2) => f2 !== g2);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a2, b) => a2 === b || a2 !== null && b !== null && a2.client === b.client && a2.clock === b.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type) => {
  for (const [key, value] of type.doc.share.entries()) {
    if (value === type) {
      return key;
    }
  }
  throw unexpectedCase();
};
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find2 = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find2
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f2) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f2(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type, parentSub) => {
  const item = type._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type, create).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i2 = pos;
  for (; i2 > 0; right = left, left = structs[--i2 - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i2;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i2) => {
  if (i2 < transactionCleanups.length) {
    const transaction = transactionCleanups[i2];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events2, type) => {
          if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
            events2 = events2.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events2.forEach((event) => {
              event.currentTarget = type;
              event._path = null;
            });
            events2.sort((event1, event2) => event1.path.length - event2.path.length);
            fs.push(() => {
              callEventHandlerListeners(type._dEH, events2, transaction);
            });
          }
        });
        fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
        fs.push(() => {
          if (transaction._needFormattingCleanup) {
            cleanupYTextAfterTransaction(transaction);
          }
        });
      });
      callAll(fs, []);
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i3 = structs.length - 1; i3 >= firstChangePos; ) {
            i3 -= 1 + tryToMergeWithLefts(structs, i3);
          }
        }
      });
      for (let i3 = mergeStructs.length - 1; i3 >= 0; i3--) {
        const { client, clock } = mergeStructs[i3].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i2 + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i2 + 1);
      }
    }
  }
};
var transact = (doc2, f2, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f2(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i2 = 0; i2 < numOfStateUpdates; i2++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i3 = 0; i3 < numberOfStructs; i3++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {
  const encoder = new YEncoder();
  const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);
  let curr = updateDecoder.curr;
  if (curr !== null) {
    let size2 = 0;
    let currClient = curr.id.client;
    let stopCounting = curr.id.clock !== 0;
    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;
    for (; curr !== null; curr = updateDecoder.next()) {
      if (currClient !== curr.id.client) {
        if (currClock !== 0) {
          size2++;
          writeVarUint(encoder.restEncoder, currClient);
          writeVarUint(encoder.restEncoder, currClock);
        }
        currClient = curr.id.client;
        currClock = 0;
        stopCounting = curr.id.clock !== 0;
      }
      if (curr.constructor === Skip) {
        stopCounting = true;
      }
      if (!stopCounting) {
        currClock = curr.id.clock + curr.length;
      }
    }
    if (currClock !== 0) {
      size2++;
      writeVarUint(encoder.restEncoder, currClient);
      writeVarUint(encoder.restEncoder, currClock);
    }
    const enc = createEncoder();
    writeVarUint(enc, size2);
    writeBinaryEncoder(enc, encoder.restEncoder);
    encoder.restEncoder = enc;
    return encoder.toUint8Array();
  } else {
    writeVarUint(encoder.restEncoder, 0);
    return encoder.toUint8Array();
  }
};
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i2 = 0; i2 < lazyWriter.clientStructs.length; i2++) {
    const partStructs = lazyWriter.clientStructs[i2];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create2(errorComputeChanges);
      }
      const keys2 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys2.set(key, { action, oldValue });
        }
      });
      this._keys = keys2;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create2(errorComputeChanges);
      }
      const target = this.target;
      const added = create();
      const deleted = create();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path.unshift(child._item.parentSub);
    } else {
      let i2 = 0;
      let c2 = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c2 !== child._item && c2 !== null) {
        if (!c2.deleted && c2.countable) {
          i2 += c2.length;
        }
        c2 = c2.right;
      }
      path.unshift(i2);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path;
};
var warnPrematureAccess = () => {
  warn("Invalid access: Add Yjs type to a document before reading data.");
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p2, index) {
    p2.marker = true;
    this.p = p2;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p2, index) => {
  marker.p.marker = false;
  marker.p = p2;
  p2.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p2, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a2, b) => a2.timestamp < b.timestamp ? a2 : b);
    overwriteMarker(marker, p2, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p2, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a2, b) => abs(index - a2.index) < abs(index - b.index) ? a2 : b);
  let p2 = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p2 = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p2.right !== null && pindex < index) {
    if (!p2.deleted && p2.countable) {
      if (index < pindex + p2.length) {
        break;
      }
      pindex += p2.length;
    }
    p2 = p2.right;
  }
  while (p2.left !== null && pindex > index) {
    p2 = p2.left;
    if (!p2.deleted && p2.countable) {
      pindex -= p2.length;
    }
  }
  while (p2.left !== null && p2.left.id.client === p2.id.client && p2.left.id.clock + p2.left.length === p2.id.clock) {
    p2 = p2.left;
    if (!p2.deleted && p2.countable) {
      pindex -= p2.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p2.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p2, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p2, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len) => {
  for (let i2 = searchMarker.length - 1; i2 >= 0; i2--) {
    const m2 = searchMarker[i2];
    if (len > 0) {
      let p2 = m2.p;
      p2.marker = false;
      while (p2 && (p2.deleted || !p2.countable)) {
        p2 = p2.left;
        if (p2 && !p2.deleted && p2.countable) {
          m2.index -= p2.length;
        }
      }
      if (p2 === null || p2.marker === true) {
        searchMarker.splice(i2, 1);
        continue;
      }
      m2.p = p2;
      p2.marker = true;
    }
    if (index < m2.index || len > 0 && index === m2.index) {
      m2.index = max(index, m2.index + len);
    }
  }
};
var callTypeObservers = (type, transaction, event) => {
  const changedType = type;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type, () => []).push(event);
    if (type._item === null) {
      break;
    }
    type = /** @type {AbstractType<any>} */
    type._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y2, item) {
    this.doc = y2;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n2 = this._start;
    while (n2 !== null && n2.deleted) {
      n2 = n2.right;
    }
    return n2;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f2) {
    addEventHandlerListener(this._eH, f2);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f2) {
    addEventHandlerListener(this._dEH, f2);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f2) {
    removeEventHandlerListener(this._eH, f2);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f2) {
    removeEventHandlerListener(this._dEH, f2);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type, start, end) => {
  type.doc ?? warnPrematureAccess();
  if (start < 0) {
    start = type._length + start;
  }
  if (end < 0) {
    end = type._length + end;
  }
  let len = end - start;
  const cs = [];
  let n2 = type._start;
  while (n2 !== null && len > 0) {
    if (n2.countable && !n2.deleted) {
      const c2 = n2.content.getContent();
      if (c2.length <= start) {
        start -= c2.length;
      } else {
        for (let i2 = start; i2 < c2.length && len > 0; i2++) {
          cs.push(c2[i2]);
          len--;
        }
        start = 0;
      }
    }
    n2 = n2.right;
  }
  return cs;
};
var typeListToArray = (type) => {
  type.doc ?? warnPrematureAccess();
  const cs = [];
  let n2 = type._start;
  while (n2 !== null) {
    if (n2.countable && !n2.deleted) {
      const c2 = n2.content.getContent();
      for (let i2 = 0; i2 < c2.length; i2++) {
        cs.push(c2[i2]);
      }
    }
    n2 = n2.right;
  }
  return cs;
};
var typeListForEach = (type, f2) => {
  let index = 0;
  let n2 = type._start;
  type.doc ?? warnPrematureAccess();
  while (n2 !== null) {
    if (n2.countable && !n2.deleted) {
      const c2 = n2.content.getContent();
      for (let i2 = 0; i2 < c2.length; i2++) {
        f2(c2[i2], index++, type);
      }
    }
    n2 = n2.right;
  }
};
var typeListMap = (type, f2) => {
  const result = [];
  typeListForEach(type, (c2, i2) => {
    result.push(f2(c2, i2, type));
  });
  return result;
};
var typeListCreateIterator = (type) => {
  let n2 = type._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n2 !== null && n2.deleted) {
          n2 = n2.right;
        }
        if (n2 === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n2.content.getContent();
        currentContentIndex = 0;
        n2 = n2.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type, index) => {
  type.doc ?? warnPrematureAccess();
  const marker = findMarker(type, index);
  let n2 = type._start;
  if (marker !== null) {
    n2 = marker.p;
    index -= marker.index;
  }
  for (; n2 !== null; n2 = n2.right) {
    if (!n2.deleted && n2.countable) {
      if (index < n2.length) {
        return n2.content.getContent()[index];
      }
      index -= n2.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c2) => {
    if (c2 === null) {
      jsonContent.push(c2);
    } else {
      switch (c2.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c2);
          break;
        default:
          packJsonContent();
          switch (c2.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c2
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c2
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c2 instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c2));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create2("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n2 = parent._start;
  if (marker !== null) {
    n2 = marker.p;
    index -= marker.index;
    if (index === 0) {
      n2 = n2.prev;
      index += n2 && n2.countable && !n2.deleted ? n2.length : 0;
    }
  }
  for (; n2 !== null; n2 = n2.right) {
    if (!n2.deleted && n2.countable) {
      if (index <= n2.length) {
        if (index < n2.length) {
          getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + index));
        }
        break;
      }
      index -= n2.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n2, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n2 = marker.p;
  if (n2) {
    while (n2.right) {
      n2 = n2.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n2, content);
};
var typeListDelete = (transaction, parent, index, length2) => {
  if (length2 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length2;
  const marker = findMarker(parent, index);
  let n2 = parent._start;
  if (marker !== null) {
    n2 = marker.p;
    index -= marker.index;
  }
  for (; n2 !== null && index > 0; n2 = n2.right) {
    if (!n2.deleted && n2.countable) {
      if (index < n2.length) {
        getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + index));
      }
      index -= n2.length;
    }
  }
  while (length2 > 0 && n2 !== null) {
    if (!n2.deleted) {
      if (length2 < n2.length) {
        getItemCleanStart(transaction, createID(n2.id.client, n2.id.clock + length2));
      }
      n2.delete(transaction);
      length2 -= n2.length;
    }
    n2 = n2.right;
  }
  if (length2 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length2
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c2 = parent._map.get(key);
  if (c2 !== void 0) {
    c2.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
      case Date:
      case BigInt:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  parent.doc ?? warnPrematureAccess();
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent.doc ?? warnPrematureAccess();
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  parent.doc ?? warnPrematureAccess();
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot) => {
  const res = {};
  parent._map.forEach((value, key) => {
    let v2 = value;
    while (v2 !== null && (!snapshot.sv.has(v2.id.client) || v2.id.clock >= (snapshot.sv.get(v2.id.client) || 0))) {
      v2 = v2.left;
    }
    if (v2 !== null && isVisible(v2, snapshot)) {
      res[key] = v2.content.getContent()[v2.length - 1];
    }
  });
  return res;
};
var createMapIterator = (type) => {
  type.doc ?? warnPrematureAccess();
  return iteratorFilter(
    type._map.entries(),
    /** @param {any} entry */
    (entry) => !entry[1].deleted
  );
};
var YArrayEvent = class extends YEvent {
};
var YArray = class _YArray extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a2 = new _YArray();
    a2.push(items);
    return a2;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _YArray();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const arr = new _YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length2 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length2);
      });
    } else {
      this._prelimContent.splice(index, length2);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c2) => c2 instanceof AbstractType ? c2.toJSON() : c2);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f2) {
    return typeListMap(
      this,
      /** @type {any} */
      f2
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    typeListForEach(this, f2);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class _YMap extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new _YMap();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const map4 = new _YMap();
    this.forEach((value, key) => {
      map4.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map4;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    this.doc ?? warnPrematureAccess();
    const map4 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v2 = item.content.getContent()[item.length - 1];
        map4[key] = v2 instanceof AbstractType ? v2.toJSON() : v2;
      }
    });
    return map4;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => v2[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => v2[1].content.getContent()[v2[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this),
      /** @param {any} v */
      (v2) => (
        /** @type {any} */
        [v2[0], v2[1].content.getContent()[v2[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    this.doc ?? warnPrematureAccess();
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f2(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map4) {
          typeMapDelete(transaction, map4, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a2, b) => a2 === b || typeof a2 === "object" && typeof b === "object" && a2 && b && equalFlat(a2, b);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ] ?? null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    )) ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = currPos.currentAttributes.get(key) ?? null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length2, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop: while (currPos.right !== null && (length2 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
    if (!currPos.right.deleted) {
      switch (currPos.right.content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            currPos.right.content
          );
          const attr = attributes[key];
          if (attr !== void 0) {
            if (equalAttrs(attr, value)) {
              negatedAttributes.delete(key);
            } else {
              if (length2 === 0) {
                break iterationLoop;
              }
              negatedAttributes.set(key, value);
            }
            currPos.right.delete(transaction);
          } else {
            currPos.currentAttributes.set(key, value);
          }
          break;
        }
        default:
          if (length2 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
          }
          length2 -= currPos.right.length;
          break;
      }
    }
    currPos.forward();
  }
  if (length2 > 0) {
    let newlines = "";
    for (; length2 > 0; length2--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  let end = start;
  const endFormats = create3();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = startAttributes.get(key) ?? null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type._start
      );
      let end = type._start;
      let startAttributes = create3();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t2) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t2, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length2) => {
  const startLength = length2;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length2 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length2 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length2));
          }
          length2 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length2);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y2 = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y2, (transaction) => {
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty2(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op) delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = currentAttributes.get(key) ?? null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, oldAttributes.get(key) ?? null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = currentAttributes.get(key) ?? null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class _YText extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    try {
      this._pending.forEach((f2) => f2());
    } catch (e2) {
      console.error(e2);
    }
    this._pending = null;
  }
  _copy() {
    return new _YText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const text2 = new _YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    this.doc ?? warnPrematureAccess();
    let str = "";
    let n2 = this._start;
    while (n2 !== null) {
      if (!n2.deleted && n2.countable && n2.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n2.content.str;
      }
      n2 = n2.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {Array<any>} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i2 = 0; i2 < delta.length; i2++) {
          const op = delta[i2];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i2 === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    this.doc ?? warnPrematureAccess();
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n2 = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n2 !== null) {
        if (isVisible(n2, snapshot) || prevSnapshot !== void 0 && isVisible(n2, prevSnapshot)) {
          switch (n2.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n2, snapshot)) {
                if (cur === void 0 || cur.user !== n2.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n2.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n2, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n2.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n2.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n2.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n2.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n2, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n2.content
                );
              }
              break;
          }
        }
        n2 = n2.right;
      }
      packStr();
    };
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v2, k2) => {
            attributes[k2] = v2;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes) {
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length2) {
    if (length2 === 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index, true), length2);
      });
    } else {
      this._pending.push(() => this.delete(index, length2));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length2, attributes) {
    if (length2 === 0) {
      return;
    }
    const y2 = this.doc;
    if (y2 !== null) {
      transact(y2, (transaction) => {
        const pos = findPosition(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length2, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length2, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f2 = () => true) {
    this._filter = f2;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
    root.doc ?? warnPrematureAccess();
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n2 = this._currentNode;
    let type = n2 && n2.content && /** @type {any} */
    n2.content.type;
    if (n2 !== null && (!this._firstCall || n2.deleted || !this._filter(type))) {
      do {
        type = /** @type {any} */
        n2.content.type;
        if (!n2.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
          n2 = type._start;
        } else {
          while (n2 !== null) {
            const nxt = n2.next;
            if (nxt !== null) {
              n2 = nxt;
              break;
            } else if (n2.parent === this._root) {
              n2 = null;
            } else {
              n2 = /** @type {AbstractType<any>} */
              n2.parent._item;
            }
          }
        }
      } while (n2 !== null && (n2.deleted || !this._filter(
        /** @type {ContentType} */
        n2.content.type
      )));
    }
    this._firstCall = false;
    if (n2 === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n2;
    return { value: (
      /** @type {any} */
      n2.content.type
    ), done: false };
  }
};
var YXmlFragment = class _YXmlFragment extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first2 = this._first;
    return first2 ? first2.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new _YXmlFragment();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const el = new _YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    this.doc ?? warnPrematureAccess();
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter2) {
    return new YXmlTreeWalker(this, filter2);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator2 = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next = iterator2.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from2(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create2("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length2 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length2);
      });
    } else {
      this._prelimContent.splice(index, length2);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f2) {
    typeListForEach(this, f2);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class _YXmlElement extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n2 = this._item ? this._item.next : null;
    return n2 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n2.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n2 = this._item ? this._item.prev : null;
    return n2 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n2.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y2, item) {
    super._integrate(y2, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new _YXmlElement(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new _YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      el.setAttribute(
        key,
        /** @type {any} */
        value
      );
    });
    el.insert(0, this.toArray().map((v2) => v2 instanceof AbstractType ? v2.clone() : v2));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys2 = [];
    for (const key in attrs) {
      keys2.push(key);
    }
    keys2.sort();
    const keysLen = keys2.length;
    for (let i2 = 0; i2 < keysLen; i2++) {
      const key = keys2[i2];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot) {
    return (
      /** @type {any} */
      snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with which the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class _YXmlHook extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new _YXmlHook(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const el = new _YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class _YXmlText extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n2 = this._item ? this._item.next : null;
    return n2 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n2.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n2 = this._item ? this._item.prev : null;
    return n2 ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n2.content.type
    ) : null;
  }
  _copy() {
    return new _YXmlText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const text2 = new _YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a2, b) => a2.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a2, b) => a2.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i2 = 0; i2 < nestedNodes.length; i2++) {
        const node = nestedNodes[i2];
        str += `<${node.nodeName}`;
        for (let j2 = 0; j2 < node.attrs.length; j2++) {
          const attr = node.attrs[j2];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i2 = nestedNodes.length - 1; i2 >= 0; i2--) {
        str += `</${nestedNodes[i2].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length2) {
    this.id = id2;
    this.length = length2;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} whether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class _ContentBinary {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new _ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class _ContentDeleted {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new _ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new _ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class _ContentDoc {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class _ContentEmbed {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new _ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class _ContentFormat {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new _ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p2 = (
      /** @type {YText} */
      item.parent
    );
    p2._searchMarker = null;
    p2._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class _ContentJSON {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new _ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new _ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i2 = offset; i2 < len; i2++) {
      const c2 = this.arr[i2];
      encoder.writeString(c2 === void 0 ? "undefined" : JSON.stringify(c2));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i2 = 0; i2 < len; i2++) {
    const c2 = decoder.readString();
    if (c2 === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c2));
    }
  }
  return new ContentJSON(cs);
};
var isDevMode = getVariable("node_env") === "development";
var ContentAny = class _ContentAny {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
    isDevMode && deepFreeze(arr);
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new _ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new _ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i2 = offset; i2 < len; i2++) {
      const c2 = this.arr[i2];
      encoder.writeAny(c2);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i2 = 0; i2 < len; i2++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class _ContentString {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new _ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new _ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "";
      right.str = "" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class _ContentType {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type) {
    this.type = type;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new _ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var Item = class _Item extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === _Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      } else if (this.right && this.right.constructor === _Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o2;
        if (left !== null) {
          o2 = left.right;
        } else if (this.parentSub !== null) {
          o2 = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o2 !== null && o2.left !== null) {
            o2 = o2.left;
          }
        } else {
          o2 = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o2 !== null && o2 !== this.right) {
          itemsBeforeOrigin.add(o2);
          conflictingItems.add(o2);
          if (compareIDs(this.origin, o2.origin)) {
            if (o2.id.client < this.id.client) {
              left = o2;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o2.rightOrigin)) {
              break;
            }
          } else if (o2.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o2.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o2.origin))) {
              left = o2;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o2 = o2.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r2;
        if (this.parentSub !== null) {
          r2 = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r2 !== null && r2.left !== null) {
            r2 = r2.left;
          }
        } else {
          r2 = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r2;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n2 = this.right;
    while (n2 !== null && n2.deleted) {
      n2 = n2.right;
    }
    return n2;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n2 = this.left;
    while (n2 !== null && n2.deleted) {
      n2 = n2.left;
    }
    return n2;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// node_modules/y-dexie/dist/y-dexie.js
var _hasOwn = {}.hasOwnProperty;
var docRegistry = new FinalizationRegistry(({ cache, key }) => {
  delete cache[key];
});
function getDocCache(db) {
  var _a;
  var _b;
  return (_a = (_b = db._novip)["_docCache"]) !== null && _a !== void 0 ? _a : _b["_docCache"] = {
    cache: {},
    get size() {
      return Object.keys(this.cache).length;
    },
    find(table, primaryKey, ydocProp) {
      const cacheKey = getYDocCacheKey(table, primaryKey, ydocProp);
      const docRef = this.cache[cacheKey];
      return docRef ? docRef.deref() : void 0;
    },
    add(doc2) {
      var _a2;
      const { parentTable, parentId, parentProp } = doc2.meta;
      if (!parentTable || !parentProp || parentId == null)
        throw new Error(`Missing Dexie-related metadata in Y.Doc`);
      const cacheKey = getYDocCacheKey(parentTable, parentId, parentProp);
      const existingDoc = (_a2 = this.cache[cacheKey]) === null || _a2 === void 0 ? void 0 : _a2.deref();
      if (existingDoc) {
        docRegistry.unregister(existingDoc);
      }
      this.cache[cacheKey] = new WeakRef(doc2);
      docRegistry.register(doc2, { cache: this.cache, key: cacheKey }, doc2);
    },
    delete(doc2) {
      docRegistry.unregister(doc2);
      const cacheKey = getYDocCacheKey(doc2.meta.parentTable, doc2.meta.parentId, doc2.meta.parentProp);
      const cacheEntry = this.cache[cacheKey];
      if ((cacheEntry === null || cacheEntry === void 0 ? void 0 : cacheEntry.deref()) === doc2) {
        delete this.cache[cacheKey];
      }
    }
  };
}
var destroyedDocs = /* @__PURE__ */ new WeakSet();
function throwIfDestroyed(doc2) {
  if (destroyedDocs.has(doc2))
    throw new Error(`Y.Doc ${doc2.meta.parentId} has been destroyed`);
}
function getYDocCacheKey(table, primaryKey, ydocProp) {
  return `${table}[${primaryKey}].${ydocProp}`;
}
function getOrCreateDocument(db, docCache, tableName, prop, updatesTable, id2) {
  let doc2 = docCache.find(tableName, id2, prop);
  if (doc2)
    return doc2;
  doc2 = new Doc({
    meta: {
      db,
      updatesTable,
      parentProp: prop,
      parentTable: tableName,
      parentId: id2
    }
  });
  docCache.add(doc2);
  doc2.on("destroy", () => {
    destroyedDocs.add(doc2);
    docCache.delete(doc2);
  });
  return doc2;
}
var { getByKeyPath } = Dexie;
var currentUpdateRow = null;
function setCurrentUpdateRow(row) {
  currentUpdateRow = row;
}
function observeYDocUpdates(provider, doc2, db, parentTableName, updatesTableName, parentId) {
  let lastUpdateId = 0;
  let initial = true;
  const subscription = liveQuery(() => {
    throwIfDestroyed(doc2);
    const updatesTable = db.table(updatesTableName);
    return Promise.all([
      (lastUpdateId > 0 ? updatesTable.where("i").between(lastUpdateId, Infinity, false).toArray().then((updates) => updates.filter((update) => cmp(update.k, parentId) === 0)) : updatesTable.where({ k: parentId }).toArray()).then((updates) => {
        return updates;
      }),
      db.table(parentTableName).where(":id").equals(parentId).toArray()
      // Why not just count() or get()? Because of cache only works with toArray() currently (optimization)
    ]);
  }).subscribe(([updates, parentRow]) => {
    if (updates.length > 0)
      lastUpdateId = updates[updates.length - 1].i;
    if (parentRow.length === 0) {
      doc2.destroy();
      return;
    }
    throwIfDestroyed(doc2);
    if (updates.length > 0) {
      transact(doc2, () => {
        updates.forEach((update) => {
          try {
            setCurrentUpdateRow(update);
            applyUpdateV2(doc2, update.u);
          } finally {
            setCurrentUpdateRow(null);
          }
        });
      }, provider, false);
    }
    if (initial) {
      initial = false;
      doc2.emit("load", [doc2]);
    }
  }, (error) => {
    provider.on("error").fire(error);
  });
  const onUpdate = (update, origin) => {
    if (origin === provider)
      return;
    db.table(updatesTableName).add({
      k: parentId,
      u: update,
      f: 1
      // Flag as local update (to be included when syncing)
    }).then((i2) => {
      if (i2 === lastUpdateId - 1)
        ++lastUpdateId;
    }).catch((error) => {
      provider.on("error").fire(error);
    });
  };
  const stopObserving = () => {
    subscription.unsubscribe();
    doc2.off("updateV2", onUpdate);
    doc2.off("destroy", stopObserving);
  };
  doc2.on("updateV2", onUpdate);
  doc2.on("destroy", stopObserving);
  return stopObserving;
}
function nop2() {
}
function promisableChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res && typeof res.then === "function") {
      var thiz = this, i2 = arguments.length, args2 = new Array(i2);
      while (i2--)
        args2[i2] = arguments[i2];
      return res.then(function() {
        return f2.apply(thiz, args2);
      });
    }
    return f2.apply(this, arguments);
  };
}
function nonStoppableEventChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    f1.apply(this, arguments);
    f2.apply(this, arguments);
  };
}
var wm = /* @__PURE__ */ new WeakMap();
function createEvents() {
  return Dexie.Events(null, "load", "sync", "error");
}
var DexieYProvider = class _DexieYProvider {
  static getOrCreateDocument(db, table, prop, id2) {
    var _a, _b;
    const docCache = getDocCache(db);
    const updatesTable = (_b = (_a = db.table(table).schema.yProps) === null || _a === void 0 ? void 0 : _a.find((p2) => p2.prop === prop)) === null || _b === void 0 ? void 0 : _b.updatesTable;
    if (!updatesTable) {
      throw new Error(`Updates table for ${table}.${prop} not found`);
    }
    return getOrCreateDocument(db, docCache, table, prop, updatesTable, id2);
  }
  static load(doc2, options) {
    var _a;
    let p2 = wm.get(doc2);
    if (p2) {
      ++p2.refCount;
      if ((options === null || options === void 0 ? void 0 : options.gracePeriod) != null && p2.graceTimeout < options.gracePeriod) {
        p2.graceTimeout = options.gracePeriod;
      }
      if (p2.graceTimer) {
        clearTimeout(p2.graceTimer);
        p2.graceTimer = null;
      }
    } else {
      p2 = new _DexieYProvider(doc2);
      p2.graceTimeout = (_a = options === null || options === void 0 ? void 0 : options.gracePeriod) !== null && _a !== void 0 ? _a : -1;
      wm.set(doc2, p2);
    }
    return p2;
  }
  static release(doc2) {
    if (!doc2 || destroyedDocs.has(doc2))
      return;
    const p2 = wm.get(doc2);
    if (p2) {
      if (--p2.refCount <= 0) {
        if (p2.graceTimeout < 0) {
          p2._release();
        } else if (!p2.graceTimer) {
          p2.graceTimer = setTimeout(
            () => {
              p2.graceTimer = null;
              if (p2.refCount === 0) {
                p2._release();
              }
            },
            p2.graceTimeout
            // Grace period to optimize for unload/reload scenarios
          );
        }
      }
    } else {
      doc2.destroy();
    }
  }
  _release() {
    if (!this.doc)
      return;
    Promise.resolve(_DexieYProvider.on("beforeunload").fire(this)).finally(() => {
      var _a;
      if (this.refCount === 0) {
        (_a = this.doc) === null || _a === void 0 ? void 0 : _a.destroy();
      }
    });
  }
  static for(doc2) {
    return wm.get(doc2);
  }
  static get currentUpdateRow() {
    return currentUpdateRow;
  }
  // Use a getter to avoid unhandled rejections when no one bothers about it.
  get whenLoaded() {
    if (!this._whenLoaded) {
      this._whenLoaded = new Promise((resolve, reject) => {
        if (!this.doc) {
          reject(new Error("No Y.Doc associated with this provider"));
          return;
        }
        if (this.doc.isLoaded)
          resolve();
        else if (this._error)
          reject(this._error);
        else if (destroyedDocs.has(this.doc)) {
          reject(new Dexie.AbortError("Document was destroyed before loaded"));
        } else {
          this.on("load", resolve);
          this.on("error", reject);
          this.doc.on("destroy", () => reject(new Dexie.AbortError("Document was destroyed before loaded")));
        }
      });
    }
    return this._whenLoaded;
  }
  // Use a getter to avoid unhandled rejections when no one bothers about it.
  get whenSynced() {
    if (!this._whenSynced) {
      this._whenSynced = new Promise((resolve, reject) => {
        if (!this.doc) {
          reject(new Error("No Y.Doc associated with this provider"));
          return;
        }
        if (this.doc.isSynced)
          resolve();
        else if (this._error)
          reject(this._error);
        else if (destroyedDocs.has(this.doc)) {
          reject(new Dexie.AbortError("Document was destroyed before synced"));
        } else {
          this.on("sync", resolve);
          this.on("error", reject);
          this.doc.on("destroy", () => reject(new Dexie.AbortError("Document was destroyed before synced")));
        }
      });
    }
    return this._whenSynced;
  }
  constructor(doc2) {
    this.refCount = 1;
    this.cleanupHandlers = [];
    this.graceTimeout = -1;
    this.doc = null;
    this.destroyed = false;
    this.on = createEvents();
    this.doc = doc2;
    this.off = (name, f2) => {
      var _a;
      return (_a = this.on[name]) === null || _a === void 0 ? void 0 : _a.unsubscribe(f2);
    };
    if ("dispose" in Symbol) {
      this[Symbol.dispose] = () => _DexieYProvider.release(doc2);
    }
    doc2.on("load", () => this.on("load").fire());
    doc2.on("sync", (sync2) => sync2 !== false && this.on("sync").fire());
    doc2.on("destroy", this.destroy.bind(this));
    this.on("error", (error) => {
      this._error = error;
    });
    const { db, parentTable, parentId, updatesTable } = doc2.meta || {};
    if (!db || !parentTable || !updatesTable) {
      throw new Error(`Missing Dexie-related metadata in Y.Doc. Documents need to be obtained through Y.Doc properties from dexie queries.`);
    }
    if (!db.table(parentTable) || !db.table(updatesTable)) {
      throw new Error(`Table ${parentTable} or ${updatesTable} not found in db`);
    }
    throwIfDestroyed(doc2);
    this.stopObserving = observeYDocUpdates(this, doc2, db, parentTable, updatesTable, parentId);
    _DexieYProvider.on("new").fire(this);
  }
  destroy() {
    var _a, _b, _c;
    console.debug(`Y.Doc ${(_b = (_a = this.doc) === null || _a === void 0 ? void 0 : _a.meta) === null || _b === void 0 ? void 0 : _b.parentId} was destroyed`);
    wm.delete(this.doc);
    this.doc = null;
    this.destroyed = true;
    this.refCount = 0;
    (_c = this.stopObserving) === null || _c === void 0 ? void 0 : _c.call(this);
    this.on = createEvents();
    this.cleanupHandlers.forEach((cleanup) => cleanup());
  }
  addCleanupHandler(cleanupHandler) {
    this.cleanupHandlers.push(typeof cleanupHandler === "function" ? cleanupHandler : () => cleanupHandler.unsubscribe());
  }
};
DexieYProvider.on = Dexie.Events(null, {
  new: [nonStoppableEventChain],
  beforeunload: [promisableChain]
});
DexieYProvider.getDocCache = getDocCache;
if (Dexie["DexieYProvider"]) {
  DexieYProvider = Dexie["DexieYProvider"] || DexieYProvider;
} else {
  Dexie["DexieYProvider"] = DexieYProvider;
}

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable2 {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i2 = 0; i2 < clients.length; i2++) {
    const clientID = clients[i2];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder = createEncoder();
  writeVarUint(encoder, len);
  for (let i2 = 0; i2 < len; i2++) {
    const clientID = clients[i2];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint(encoder, clientID);
    writeVarUint(encoder, clock);
    writeVarString(encoder, JSON.stringify(state));
  }
  return toUint8Array(encoder);
};
var applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = createDecoder(update);
  const timestamp2 = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder);
  for (let i2 = 0; i2 < len; i2++) {
    const clientID = readVarUint(decoder);
    let clock = readVarUint(decoder);
    const state = JSON.parse(readVarString(decoder));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp2
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// node_modules/dexie-cloud-addon/dist/modern/dexie-cloud-addon.js
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __awaiter2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __values2(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
  if (m2) return m2.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await2(v2) {
  return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
}
function __asyncGenerator2(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f2) {
    return function(v2) {
      return Promise.resolve(v2).then(f2, reject);
    };
  }
  function verb(n2, f2) {
    if (g2[n2]) {
      i2[n2] = function(v2) {
        return new Promise(function(a2, b) {
          q2.push([n2, v2, a2, b]) > 1 || resume(n2, v2);
        });
      };
      if (f2) i2[n2] = f2(i2[n2]);
    }
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncValues2(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function assert2(b) {
  if (!b)
    throw new Error("Assertion Failed");
}
var _hasOwn2 = {}.hasOwnProperty;
function hasOwn(obj, prop) {
  return _hasOwn2.call(obj, prop);
}
function setByKeyPath(obj, keyPath, value) {
  if (!obj || keyPath === void 0)
    return;
  if ("isFrozen" in Object && Object.isFrozen(obj))
    return;
  if (typeof keyPath !== "string" && "length" in keyPath) {
    assert2(typeof value !== "string" && "length" in value);
    for (var i2 = 0, l2 = keyPath.length; i2 < l2; ++i2) {
      setByKeyPath(obj, keyPath[i2], value[i2]);
    }
  } else {
    var period = keyPath.indexOf(".");
    if (period !== -1) {
      var currentKeyPath = keyPath.substr(0, period);
      var remainingKeyPath = keyPath.substr(period + 1);
      if (remainingKeyPath === "")
        if (value === void 0) {
          if (Array.isArray(obj)) {
            if (!isNaN(parseInt(currentKeyPath)))
              obj.splice(parseInt(currentKeyPath), 1);
          } else
            delete obj[currentKeyPath];
        } else
          obj[currentKeyPath] = value;
      else {
        var innerObj = obj[currentKeyPath];
        if (!innerObj || !hasOwn(obj, currentKeyPath))
          innerObj = obj[currentKeyPath] = {};
        setByKeyPath(innerObj, remainingKeyPath, value);
      }
    } else {
      if (value === void 0) {
        if (Array.isArray(obj) && !isNaN(parseInt(keyPath)))
          obj.splice(keyPath, 1);
        else
          delete obj[keyPath];
      } else
        obj[keyPath] = value;
    }
  }
}
var randomString$1 = typeof self !== "undefined" && typeof crypto !== "undefined" ? (bytes, randomFill = crypto.getRandomValues.bind(crypto)) => {
  const buf = new Uint8Array(bytes);
  randomFill(buf);
  return self.btoa(String.fromCharCode.apply(null, buf));
} : typeof Buffer !== "undefined" ? (bytes, randomFill = simpleRandomFill) => {
  const buf = Buffer.alloc(bytes);
  randomFill(buf);
  return buf.toString("base64");
} : () => {
  throw new Error("No implementation of randomString was found");
};
function simpleRandomFill(buf) {
  for (let i2 = 0; i2 < buf.length; ++i2) {
    buf[i2] = Math.floor(Math.random() * 256);
  }
}
function isValidSyncableID(id2) {
  if (typeof id2 === "string")
    return true;
  if (Array.isArray(id2) && id2.some((key) => isValidSyncableID(key)) && id2.every(isValidSyncableIDPart))
    return true;
  return false;
}
function isValidSyncableIDPart(part) {
  return typeof part === "string" || typeof part === "number" || Array.isArray(part) && part.every(isValidSyncableIDPart);
}
function isValidAtID(id2, idPrefix) {
  return !idPrefix || typeof id2 === "string" && id2.startsWith(idPrefix);
}
function applyOperation(target, table, op) {
  const tbl = target[table] || (target[table] = {});
  const keys2 = op.keys.map((key) => typeof key === "string" ? key : JSON.stringify(key));
  switch (op.type) {
    case "insert":
    // TODO: Don't treat insert and upsert the same?
    case "upsert":
      keys2.forEach((key, idx) => {
        tbl[key] = {
          type: "ups",
          val: op.values[idx]
        };
      });
      break;
    case "update":
    case "modify": {
      keys2.forEach((key, idx) => {
        const changeSpec = op.type === "update" ? op.changeSpecs[idx] : op.changeSpec;
        const entry = tbl[key];
        if (!entry) {
          tbl[key] = {
            type: "upd",
            mod: changeSpec
          };
        } else {
          switch (entry.type) {
            case "ups":
              for (const [propPath, value] of Object.entries(changeSpec)) {
                setByKeyPath(entry.val, propPath, value);
              }
              break;
            case "del":
              break;
            case "upd":
              Object.assign(entry.mod, changeSpec);
              break;
          }
        }
      });
      break;
    }
    case "delete":
      keys2.forEach((key) => {
        tbl[key] = {
          type: "del"
        };
      });
      break;
  }
  return target;
}
function applyOperations(target, ops) {
  for (const { table, muts } of ops) {
    for (const mut of muts) {
      applyOperation(target, table, mut);
    }
  }
}
function subtractChanges(target, changesToSubtract) {
  for (const [table, mutationSet] of Object.entries(changesToSubtract)) {
    for (const [key, mut] of Object.entries(mutationSet)) {
      switch (mut.type) {
        case "ups":
          {
            const targetMut = target[table]?.[key];
            if (targetMut) {
              switch (targetMut.type) {
                case "ups":
                  delete target[table][key];
                  break;
                case "del":
                  break;
                case "upd":
                  delete target[table][key];
                  break;
              }
            }
          }
          break;
        case "del":
          delete target[table]?.[key];
          break;
        case "upd": {
          const targetMut = target[table]?.[key];
          if (targetMut) {
            switch (targetMut.type) {
              case "ups":
                for (const [propPath, value] of Object.entries(mut.mod)) {
                  setByKeyPath(targetMut.val, propPath, value);
                }
                break;
              case "del":
                break;
              case "upd":
                for (const propPath of Object.keys(mut.mod)) {
                  delete targetMut.mod[propPath];
                }
                break;
            }
          }
          break;
        }
      }
    }
  }
}
function toDBOperationSet(inSet, txid) {
  const map4 = {};
  for (const [table, ops] of Object.entries(inSet)) {
    for (const [key, op] of Object.entries(ops)) {
      const mapEntry = map4[table] || (map4[table] = {});
      const ops2 = mapEntry[op.type] || (mapEntry[op.type] = []);
      ops2.push({ key, ...op });
    }
  }
  const result = [];
  for (const [table, ops] of Object.entries(map4)) {
    const resultEntry = {
      table,
      muts: []
    };
    for (const [optype, muts] of Object.entries(ops)) {
      switch (optype) {
        case "ups": {
          const op = {
            type: "upsert",
            keys: muts.map((mut) => mut.key),
            values: muts.map((mut) => mut.val),
            txid
          };
          resultEntry.muts.push(op);
          break;
        }
        case "upd": {
          const op = {
            type: "update",
            keys: muts.map((mut) => mut.key),
            changeSpecs: muts.map((mut) => mut.mod),
            txid
          };
          resultEntry.muts.push(op);
          break;
        }
        case "del": {
          const op = {
            type: "delete",
            keys: muts.map((mut) => mut.key),
            txid
          };
          resultEntry.muts.push(op);
          break;
        }
      }
    }
    result.push(resultEntry);
  }
  return result;
}
function getDbNameFromDbUrl(dbUrl) {
  const url = new URL(dbUrl);
  return url.pathname === "/" ? url.hostname.split(".")[0] : url.pathname.split("/")[1];
}
function encodeYMessage(msg) {
  const encoder = new Encoder();
  writeVarString(encoder, msg.type);
  if ("table" in msg)
    writeVarString(encoder, msg.table);
  if ("prop" in msg)
    writeVarString(encoder, msg.prop);
  switch (msg.type) {
    case "u-ack":
    case "u-reject":
      writeBigUint64(encoder, BigInt(msg.i));
      break;
    case "outdated-server-rev":
      break;
    case "y-complete-sync-done":
      writeVarString(encoder, msg.yServerRev);
      break;
    default:
      writeAny(encoder, msg.k);
      switch (msg.type) {
        case "aware":
          writeVarUint8Array(encoder, msg.u);
          break;
        case "doc-open":
          writeAny(encoder, msg.serverRev);
          writeAny(encoder, msg.sv);
          break;
        case "doc-close":
          break;
        case "sv":
          writeVarUint8Array(encoder, msg.sv);
          break;
        case "u-c":
          writeVarUint8Array(encoder, msg.u);
          writeBigUint64(encoder, BigInt(msg.i));
          break;
        case "u-s":
          writeVarUint8Array(encoder, msg.u);
          writeVarString(encoder, msg.r || "");
          break;
      }
  }
  return toUint8Array(encoder);
}
function decodeYMessage(a2) {
  const decoder = new Decoder(a2);
  const type = readVarString(decoder);
  if (type === "outdated-server-rev") {
    return { type };
  }
  if (type === "y-complete-sync-done") {
    return { type, yServerRev: readVarString(decoder) };
  }
  const table = readVarString(decoder);
  const prop = readVarString(decoder);
  switch (type) {
    case "u-ack":
    case "u-reject":
      return {
        type,
        table,
        prop,
        i: Number(readBigUint64(decoder))
      };
    default: {
      const k2 = readAny(decoder);
      switch (type) {
        case "in-sync":
          return { type, table, prop, k: k2 };
        case "aware":
          return {
            type,
            table,
            prop,
            k: k2,
            u: readVarUint8Array(decoder)
          };
        case "doc-open":
          return {
            type,
            table,
            prop,
            k: k2,
            serverRev: readAny(decoder),
            sv: readAny(decoder)
          };
        case "doc-close":
          return { type, table, prop, k: k2 };
        case "sv":
          return {
            type,
            table,
            prop,
            k: k2,
            sv: readVarUint8Array(decoder)
          };
        case "u-c":
          return {
            type,
            table,
            prop,
            k: k2,
            u: readVarUint8Array(decoder),
            i: Number(readBigUint64(decoder))
          };
        case "u-s":
          return {
            type,
            table,
            prop,
            k: k2,
            u: readVarUint8Array(decoder),
            r: decoder.pos < decoder.arr.length && readVarString(decoder) || void 0
          };
        default:
          throw new TypeError(`Unknown message type: ${type}`);
      }
    }
  }
}
async function asyncIterablePipeline(source, ...stages) {
  let result = source();
  for (let i2 = 0; i2 < stages.length; i2++) {
    result = stages[i2](result);
  }
  for await (const chunk of result) {
  }
}
async function* consumeChunkedBinaryStream(source) {
  let state = 0;
  let sizeBuf = new Uint8Array(4);
  let sizeBufPos = 0;
  let bufs = [];
  let len = 0;
  for await (const chunk of source) {
    const dw = new DataView(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    let pos = 0;
    while (pos < chunk.byteLength) {
      switch (state) {
        case 0:
          if (pos + 4 > chunk.byteLength) {
            for (const b of chunk.slice(pos)) {
              if (sizeBufPos === 4)
                break;
              sizeBuf[sizeBufPos++] = b;
              ++pos;
            }
            if (sizeBufPos < 4) {
              break;
            }
          } else if (sizeBufPos > 0 && sizeBufPos < 4) {
            for (const b of chunk.slice(pos, pos + 4 - sizeBufPos)) {
              sizeBuf[sizeBufPos++] = b;
              ++pos;
            }
          }
        // Intentional fall-through...
        case 1:
          len = sizeBufPos === 4 ? new DataView(sizeBuf.buffer, 0, 4).getUint32(0, false) : dw.getUint32(pos, false);
          if (sizeBufPos)
            sizeBufPos = 0;
          else
            pos += 4;
        // else pos is not yet forwarded - that's why we do it now
        // Intentional fall-through...
        case 2:
          if (pos >= chunk.byteLength) {
            state = 2;
            break;
          }
          if (pos + len > chunk.byteLength) {
            bufs.push(chunk.slice(pos));
            len -= chunk.byteLength - pos;
            state = 2;
            pos = chunk.byteLength;
          } else {
            if (bufs.length > 0) {
              const concats = new Uint8Array(bufs.reduce((p3, c2) => p3 + c2.byteLength, len));
              let p2 = 0;
              for (const buf of bufs) {
                concats.set(buf, p2);
                p2 += buf.byteLength;
              }
              concats.set(chunk.slice(pos, pos + len), p2);
              bufs = [];
              yield concats;
            } else {
              yield chunk.slice(pos, pos + len);
            }
            pos += len;
            state = 0;
          }
          break;
      }
    }
  }
}
function getFetchResponseBodyGenerator(res) {
  return async function* () {
    if (!res.body)
      throw new Error("Response body is not readable");
    const reader = res.body.getReader();
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done)
          return;
        yield value;
      }
    } finally {
      reader.releaseLock();
    }
  };
}
var hasComplainedAboutSyncEvent = false;
function registerSyncEvent(db, purpose) {
  return __awaiter2(this, void 0, void 0, function* () {
    try {
      const sw = yield navigator.serviceWorker.ready;
      if (purpose === "push" && sw.sync) {
        yield sw.sync.register(`dexie-cloud:${db.name}`);
      }
      if (sw.active) {
        sw.active.postMessage({
          type: "dexie-cloud-sync",
          dbName: db.name,
          purpose
        });
      } else {
        throw new Error(`Failed to trigger sync - there's no active service worker`);
      }
      return;
    } catch (e2) {
      if (!hasComplainedAboutSyncEvent) {
        console.debug(`Dexie Cloud: Could not register sync event`, e2);
        hasComplainedAboutSyncEvent = true;
      }
    }
  });
}
function registerPeriodicSyncEvent(db) {
  return __awaiter2(this, void 0, void 0, function* () {
    var _a;
    try {
      const { periodicSync } = yield navigator.serviceWorker.ready;
      if (periodicSync) {
        try {
          yield periodicSync.register(`dexie-cloud:${db.name}`, (_a = db.cloud.options) === null || _a === void 0 ? void 0 : _a.periodicSync);
          console.debug(`Dexie Cloud: Successfully registered periodicsync event for ${db.name}`);
        } catch (e2) {
          console.debug(`Dexie Cloud: Failed to register periodic sync. Your PWA must be installed to allow background sync.`, e2);
        }
      } else {
        console.debug(`Dexie Cloud: periodicSync not supported.`);
      }
    } catch (e2) {
      console.debug(`Dexie Cloud: Could not register periodicSync for ${db.name}`, e2);
    }
  });
}
function triggerSync(db, purpose) {
  if (db.cloud.usingServiceWorker) {
    console.debug("registering sync event");
    registerSyncEvent(db, purpose);
  } else {
    db.localSyncEvent.next({ purpose });
  }
}
var hasArrayBufferFromBase64 = "fromBase64" in Uint8Array;
var hasArrayBufferToBase64 = "toBase64" in Uint8Array.prototype;
var b64decode = typeof Buffer !== "undefined" ? (base64) => Buffer.from(base64, "base64") : hasArrayBufferFromBase64 ? (
  // @ts-ignore: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/fromBase64
  (base64) => Uint8Array.fromBase64(base64)
) : (base64) => {
  const binary_string = atob(base64);
  const len = binary_string.length;
  const bytes = new Uint8Array(len);
  for (var i2 = 0; i2 < len; i2++) {
    bytes[i2] = binary_string.charCodeAt(i2);
  }
  return bytes;
};
var b64encode = typeof Buffer !== "undefined" ? (b) => {
  if (ArrayBuffer.isView(b)) {
    return Buffer.from(b.buffer, b.byteOffset, b.byteLength).toString("base64");
  } else {
    return Buffer.from(b).toString("base64");
  }
} : hasArrayBufferToBase64 ? (b) => {
  const u8a = ArrayBuffer.isView(b) ? b : new Uint8Array(b);
  return u8a.toBase64();
} : (b) => {
  const u8a = ArrayBuffer.isView(b) ? b : new Uint8Array(b);
  const CHUNK_SIZE = 4096;
  const strs = [];
  for (let i2 = 0, l2 = u8a.length; i2 < l2; i2 += CHUNK_SIZE) {
    const chunk = u8a.subarray(i2, i2 + CHUNK_SIZE);
    strs.push(String.fromCharCode.apply(null, chunk));
  }
  return btoa(strs.join(""));
};
var TokenErrorResponseError = class extends Error {
  constructor({ title, message, messageCode, messageParams }) {
    super(message);
    this.name = "TokenErrorResponseError";
    this.title = title;
    this.messageCode = messageCode;
    this.messageParams = messageParams;
  }
};
function interactWithUser(userInteraction, req) {
  return new Promise((resolve, reject) => {
    const interactionProps = Object.assign(Object.assign({ submitLabel: "Submit", cancelLabel: "Cancel" }, req), { onSubmit: (res) => {
      userInteraction.next(void 0);
      resolve(res);
    }, onCancel: () => {
      userInteraction.next(void 0);
      reject(new import_wrapper_default.AbortError("User cancelled"));
    } });
    userInteraction.next(interactionProps);
  });
}
function alertUser(userInteraction, title, ...alerts) {
  return interactWithUser(userInteraction, {
    type: "message-alert",
    title,
    alerts,
    fields: {},
    submitLabel: "OK",
    cancelLabel: null
  });
}
function promptForEmail(userInteraction, title, emailHint) {
  return __awaiter2(this, void 0, void 0, function* () {
    let email = emailHint || "";
    while (!email || !/^[\w-+.]+@([\w-]+\.)+[\w-]{2,10}(\sas\s[\w-+.]+@([\w-]+\.)+[\w-]{2,10})?$/.test(email)) {
      email = (yield interactWithUser(userInteraction, {
        type: "email",
        title,
        alerts: email ? [
          {
            type: "error",
            messageCode: "INVALID_EMAIL",
            message: "Please enter a valid email address",
            messageParams: {}
          }
        ] : [],
        fields: {
          email: {
            type: "email",
            placeholder: "you@somedomain.com"
          }
        }
      })).email;
    }
    return email;
  });
}
function promptForOTP(userInteraction, email, alert) {
  return __awaiter2(this, void 0, void 0, function* () {
    const alerts = [
      {
        type: "info",
        messageCode: "OTP_SENT",
        message: `A One-Time password has been sent to {email}`,
        messageParams: { email }
      }
    ];
    if (alert) {
      alerts.push(alert);
    }
    const { otp } = yield interactWithUser(userInteraction, {
      type: "otp",
      title: "Enter OTP",
      alerts,
      fields: {
        otp: {
          type: "otp",
          label: "OTP",
          placeholder: "Paste OTP here"
        }
      }
    });
    return otp;
  });
}
function confirmLogout(userInteraction, currentUserId, numUnsyncedChanges) {
  return __awaiter2(this, void 0, void 0, function* () {
    const alerts = [
      {
        type: "warning",
        messageCode: "LOGOUT_CONFIRMATION",
        message: `{numUnsyncedChanges} unsynced changes will get lost!
                Logout anyway?`,
        messageParams: {
          currentUserId,
          numUnsyncedChanges: numUnsyncedChanges.toString()
        }
      }
    ];
    return yield interactWithUser(userInteraction, {
      type: "logout-confirmation",
      title: "Confirm Logout",
      alerts,
      fields: {},
      submitLabel: "Confirm logout",
      cancelLabel: "Cancel"
    }).then(() => true).catch(() => false);
  });
}
function loadAccessToken(db) {
  return __awaiter2(this, void 0, void 0, function* () {
    var _a, _b, _c;
    const currentUser = yield db.getCurrentUser();
    const { accessToken, accessTokenExpiration, refreshToken, refreshTokenExpiration, claims } = currentUser;
    if (!accessToken)
      return null;
    const expTime = (_a = accessTokenExpiration === null || accessTokenExpiration === void 0 ? void 0 : accessTokenExpiration.getTime()) !== null && _a !== void 0 ? _a : Infinity;
    if (expTime > Date.now() && (((_b = currentUser.license) === null || _b === void 0 ? void 0 : _b.status) || "ok") === "ok") {
      return currentUser;
    }
    if (!refreshToken) {
      throw new Error(`Refresh token missing`);
    }
    const refreshExpTime = (_c = refreshTokenExpiration === null || refreshTokenExpiration === void 0 ? void 0 : refreshTokenExpiration.getTime()) !== null && _c !== void 0 ? _c : Infinity;
    if (refreshExpTime <= Date.now()) {
      throw new Error(`Refresh token has expired`);
    }
    const refreshedLogin = yield refreshAccessToken(db.cloud.options.databaseUrl, currentUser);
    yield db.table("$logins").update(claims.sub, {
      accessToken: refreshedLogin.accessToken,
      accessTokenExpiration: refreshedLogin.accessTokenExpiration,
      claims: refreshedLogin.claims,
      license: refreshedLogin.license,
      data: refreshedLogin.data
    });
    return refreshedLogin;
  });
}
function authenticate(url, context2, fetchToken, userInteraction, hints) {
  return __awaiter2(this, void 0, void 0, function* () {
    if (context2.accessToken && context2.accessTokenExpiration.getTime() > Date.now()) {
      return context2;
    } else if (context2.refreshToken && (!context2.refreshTokenExpiration || context2.refreshTokenExpiration.getTime() > Date.now())) {
      return yield refreshAccessToken(url, context2);
    } else {
      return yield userAuthenticate(context2, fetchToken, userInteraction, hints);
    }
  });
}
function refreshAccessToken(url, login2) {
  return __awaiter2(this, void 0, void 0, function* () {
    if (!login2.refreshToken)
      throw new Error(`Cannot refresh token - refresh token is missing.`);
    if (!login2.nonExportablePrivateKey)
      throw new Error(`login.nonExportablePrivateKey is missing - cannot sign refresh token without a private key.`);
    const time_stamp = Date.now();
    const signing_algorithm = "RSASSA-PKCS1-v1_5";
    const textEncoder = new TextEncoder();
    const data = textEncoder.encode(login2.refreshToken + time_stamp);
    const binarySignature = yield crypto.subtle.sign(signing_algorithm, login2.nonExportablePrivateKey, data);
    const signature = b64encode(binarySignature);
    const tokenRequest = {
      grant_type: "refresh_token",
      refresh_token: login2.refreshToken,
      scopes: ["ACCESS_DB"],
      signature,
      signing_algorithm,
      time_stamp
    };
    const res = yield fetch(`${url}/token`, {
      body: JSON.stringify(tokenRequest),
      method: "post",
      headers: { "Content-Type": "application/json" },
      mode: "cors"
    });
    if (res.status !== 200)
      throw new Error(`RefreshToken: Status ${res.status} from ${url}/token`);
    const response = yield res.json();
    if (response.type === "error") {
      throw new TokenErrorResponseError(response);
    }
    login2.accessToken = response.accessToken;
    login2.accessTokenExpiration = response.accessTokenExpiration ? new Date(response.accessTokenExpiration) : void 0;
    login2.claims = response.claims;
    login2.license = {
      type: response.userType,
      status: response.claims.license || "ok"
    };
    if (response.evalDaysLeft != null) {
      login2.license.evalDaysLeft = response.evalDaysLeft;
    }
    if (response.userValidUntil != null) {
      login2.license.validUntil = new Date(response.userValidUntil);
    }
    if (response.data) {
      login2.data = response.data;
    }
    return login2;
  });
}
function userAuthenticate(context2, fetchToken, userInteraction, hints) {
  return __awaiter2(this, void 0, void 0, function* () {
    if (!crypto.subtle) {
      if (typeof location !== "undefined" && location.protocol === "http:") {
        throw new Error(`Dexie Cloud Addon needs to use WebCrypto, but your browser has disabled it due to being served from an insecure location. Please serve it from https or http://localhost:<port> (See https://stackoverflow.com/questions/46670556/how-to-enable-crypto-subtle-for-unsecure-origins-in-chrome/46671627#46671627)`);
      } else {
        throw new Error(`This browser does not support WebCrypto.`);
      }
    }
    const { privateKey, publicKey } = yield crypto.subtle.generateKey(
      {
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: "SHA-256" }
      },
      false,
      // Non-exportable...
      ["sign", "verify"]
    );
    if (!privateKey || !publicKey)
      throw new Error(`Could not generate RSA keypair`);
    context2.nonExportablePrivateKey = privateKey;
    const publicKeySPKI = yield crypto.subtle.exportKey("spki", publicKey);
    const publicKeyPEM = spkiToPEM(publicKeySPKI);
    context2.publicKey = publicKey;
    try {
      const response2 = yield fetchToken({
        public_key: publicKeyPEM,
        hints
      });
      if (response2.type === "error") {
        throw new TokenErrorResponseError(response2);
      }
      if (response2.type !== "tokens")
        throw new Error(`Unexpected response type from token endpoint: ${response2.type}`);
      context2.accessToken = response2.accessToken;
      context2.accessTokenExpiration = new Date(response2.accessTokenExpiration);
      context2.refreshToken = response2.refreshToken;
      if (response2.refreshTokenExpiration) {
        context2.refreshTokenExpiration = new Date(response2.refreshTokenExpiration);
      }
      context2.userId = response2.claims.sub;
      context2.email = response2.claims.email;
      context2.name = response2.claims.name;
      context2.claims = response2.claims;
      context2.license = {
        type: response2.userType,
        status: response2.claims.license || "ok"
      };
      context2.data = response2.data;
      if (response2.evalDaysLeft != null) {
        context2.license.evalDaysLeft = response2.evalDaysLeft;
      }
      if (response2.userValidUntil != null) {
        context2.license.validUntil = new Date(response2.userValidUntil);
      }
      if (response2.alerts && response2.alerts.length > 0) {
        yield interactWithUser(userInteraction, {
          type: "message-alert",
          title: "Authentication Alert",
          fields: {},
          alerts: response2.alerts
        });
      }
      return context2;
    } catch (error) {
      if (error instanceof TokenErrorResponseError) {
        yield alertUser(userInteraction, error.title, {
          type: "error",
          messageCode: error.messageCode,
          message: error.message,
          messageParams: {}
        });
        throw error;
      }
      let message = `We're having a problem authenticating right now.`;
      console.error(`Error authenticating`, error);
      if (error instanceof TypeError) {
        const isOffline = typeof navigator !== void 0 && !navigator.onLine;
        if (isOffline) {
          message = `You seem to be offline. Please connect to the internet and try again.`;
        } else if (import_wrapper_default.debug || typeof location !== "undefined" && (location.hostname === "localhost" || location.hostname === "127.0.0.1")) {
          message = `Could not connect to server. Please verify that your origin '${location.origin}' is whitelisted using \`npx dexie-cloud whitelist\``;
        } else {
          message = `Could not connect to server. Please verify the connection.`;
        }
        yield alertUser(userInteraction, "Authentication Failed", {
          type: "error",
          messageCode: "GENERIC_ERROR",
          message,
          messageParams: {}
        }).catch(() => {
        });
      }
      throw error;
    }
  });
}
function spkiToPEM(keydata) {
  const keydataB64 = b64encode(keydata);
  const keydataB64Pem = formatAsPem(keydataB64);
  return keydataB64Pem;
}
function formatAsPem(str) {
  let finalString = "-----BEGIN PUBLIC KEY-----\n";
  while (str.length > 0) {
    finalString += str.substring(0, 64) + "\n";
    str = str.substring(64);
  }
  finalString = finalString + "-----END PUBLIC KEY-----";
  return finalString;
}
var wm$2 = /* @__PURE__ */ new WeakMap();
var AuthPersistedContext = class _AuthPersistedContext {
  constructor(db, userLogin) {
    wm$2.set(this, db);
    Object.assign(this, userLogin);
  }
  static load(db, userId) {
    return db.table("$logins").get(userId).then((userLogin) => new _AuthPersistedContext(db, userLogin || {
      userId,
      claims: {
        sub: userId
      },
      lastLogin: /* @__PURE__ */ new Date(0)
    }));
  }
  save() {
    return __awaiter2(this, void 0, void 0, function* () {
      const db = wm$2.get(this);
      db.table("$logins").put(this);
    });
  }
};
var UNAUTHORIZED_USER = {
  userId: "unauthorized",
  name: "Unauthorized",
  claims: {
    sub: "unauthorized"
  },
  lastLogin: /* @__PURE__ */ new Date(0)
};
try {
  Object.freeze(UNAUTHORIZED_USER);
  Object.freeze(UNAUTHORIZED_USER.claims);
} catch (_a) {
}
function waitUntil(o2, predicate) {
  return firstValueFrom(from3(o2).pipe(filter(predicate)));
}
function logout(db) {
  return __awaiter2(this, void 0, void 0, function* () {
    const numUnsyncedChanges = yield _logout(db);
    if (numUnsyncedChanges) {
      if (yield confirmLogout(db.cloud.userInteraction, db.cloud.currentUserId, numUnsyncedChanges)) {
        yield _logout(db, { deleteUnsyncedData: true });
      } else {
        throw new Error(`User cancelled logout due to unsynced changes`);
      }
    }
  });
}
function _logout(db_1) {
  return __awaiter2(this, arguments, void 0, function* (db, { deleteUnsyncedData = false } = {}) {
    const [numUnsynced, loggedOut] = yield db.dx.transaction("rw", db.dx.tables, (tx) => __awaiter2(this, void 0, void 0, function* () {
      const idbtrans = tx.idbtrans;
      idbtrans.disableChangeTracking = true;
      idbtrans.disableAccessControl = true;
      const mutationTables = tx.storeNames.filter((tableName) => tableName.endsWith("_mutations"));
      const unsyncCounts = yield Promise.all(mutationTables.map((mutationTable) => tx.table(mutationTable).count()));
      const sumUnSynced = unsyncCounts.reduce((a2, b) => a2 + b, 0);
      if (sumUnSynced > 0 && !deleteUnsyncedData) {
        return [sumUnSynced, false];
      }
      db.$syncState.delete("syncState");
      for (const table of db.dx.tables) {
        if (table.name !== "$jobs" && table.name !== "$syncState") {
          table.clear();
        }
      }
      return [sumUnSynced, true];
    }));
    if (loggedOut) {
      yield waitUntil(db.cloud.currentUser, (user) => user.userId === UNAUTHORIZED_USER.userId);
      yield db.cloud.sync({ purpose: "pull", wait: true });
    }
    return numUnsynced;
  });
}
var HttpError = class extends Error {
  constructor(res, message) {
    super(message || `${res.status} ${res.statusText}`);
    this.httpStatus = res.status;
  }
  get name() {
    return "HttpError";
  }
};
function otpFetchTokenCallback(db) {
  const { userInteraction } = db.cloud;
  return function otpAuthenticate(_a) {
    return __awaiter2(this, arguments, void 0, function* ({ public_key, hints }) {
      var _b;
      let tokenRequest;
      const url = (_b = db.cloud.options) === null || _b === void 0 ? void 0 : _b.databaseUrl;
      if (!url)
        throw new Error(`No database URL given.`);
      if ((hints === null || hints === void 0 ? void 0 : hints.grant_type) === "demo") {
        const demo_user = yield promptForEmail(userInteraction, "Enter a demo user email", (hints === null || hints === void 0 ? void 0 : hints.email) || (hints === null || hints === void 0 ? void 0 : hints.userId));
        tokenRequest = {
          demo_user,
          grant_type: "demo",
          scopes: ["ACCESS_DB"],
          public_key
        };
      } else if ((hints === null || hints === void 0 ? void 0 : hints.otpId) && hints.otp) {
        tokenRequest = {
          grant_type: "otp",
          otp_id: hints.otpId,
          otp: hints.otp,
          scopes: ["ACCESS_DB"],
          public_key
        };
      } else {
        const email = yield promptForEmail(userInteraction, "Enter email address", hints === null || hints === void 0 ? void 0 : hints.email);
        if (/@demo.local$/.test(email)) {
          tokenRequest = {
            demo_user: email,
            grant_type: "demo",
            scopes: ["ACCESS_DB"],
            public_key
          };
        } else {
          tokenRequest = {
            email,
            grant_type: "otp",
            scopes: ["ACCESS_DB"]
          };
        }
      }
      const res1 = yield fetch(`${url}/token`, {
        body: JSON.stringify(tokenRequest),
        method: "post",
        headers: { "Content-Type": "application/json", mode: "cors" }
      });
      if (res1.status !== 200) {
        const errMsg = yield res1.text();
        yield alertUser(userInteraction, "Token request failed", {
          type: "error",
          messageCode: "GENERIC_ERROR",
          message: errMsg,
          messageParams: {}
        }).catch(() => {
        });
        throw new HttpError(res1, errMsg);
      }
      const response = yield res1.json();
      if (response.type === "tokens" || response.type === "error") {
        return response;
      } else if (tokenRequest.grant_type === "otp" && "email" in tokenRequest) {
        if (response.type !== "otp-sent")
          throw new Error(`Unexpected response from ${url}/token`);
        const otp = yield promptForOTP(userInteraction, tokenRequest.email);
        const tokenRequest2 = Object.assign(Object.assign({}, tokenRequest), { otp: otp || "", otp_id: response.otp_id, public_key });
        let res2 = yield fetch(`${url}/token`, {
          body: JSON.stringify(tokenRequest2),
          method: "post",
          headers: { "Content-Type": "application/json" },
          mode: "cors"
        });
        while (res2.status === 401) {
          const errorText = yield res2.text();
          tokenRequest2.otp = yield promptForOTP(userInteraction, tokenRequest.email, {
            type: "error",
            messageCode: "INVALID_OTP",
            message: errorText,
            messageParams: {}
          });
          res2 = yield fetch(`${url}/token`, {
            body: JSON.stringify(tokenRequest2),
            method: "post",
            headers: { "Content-Type": "application/json" },
            mode: "cors"
          });
        }
        if (res2.status !== 200) {
          const errMsg = yield res2.text();
          throw new HttpError(res2, errMsg);
        }
        const response2 = yield res2.json();
        return response2;
      } else {
        throw new Error(`Unexpected response from ${url}/token`);
      }
    });
  };
}
function prodLog(level, ...args2) {
  globalThis["console"][level](...args2);
}
function setCurrentUser(db, user) {
  return __awaiter2(this, void 0, void 0, function* () {
    const $logins = db.table("$logins");
    yield db.transaction("rw", $logins, (tx) => __awaiter2(this, void 0, void 0, function* () {
      const existingLogins = yield $logins.toArray();
      yield Promise.all(existingLogins.filter((login2) => login2.userId !== user.userId && login2.isLoggedIn).map((login2) => {
        login2.isLoggedIn = false;
        return $logins.put(login2);
      }));
      user.isLoggedIn = true;
      user.lastLogin = /* @__PURE__ */ new Date();
      try {
        yield user.save();
      } catch (e2) {
        try {
          if (e2.name === "DataCloneError") {
            prodLog("debug", `Login context property names:`, Object.keys(user));
            prodLog("debug", `Login context property names:`, Object.keys(user));
            prodLog("debug", `Login context:`, user);
            prodLog("debug", `Login context JSON:`, JSON.stringify(user));
          }
        } catch (_a) {
        }
        throw e2;
      }
      console.debug("Saved new user", user.email);
    }));
    yield waitUntil(db.cloud.currentUser, (currentUser) => currentUser.userId === user.userId);
  });
}
function login(db, hints) {
  return __awaiter2(this, void 0, void 0, function* () {
    var _a;
    const currentUser = yield db.getCurrentUser();
    const origUserId = currentUser.userId;
    if (currentUser.isLoggedIn && (!hints || !hints.email && !hints.userId)) {
      const licenseStatus = ((_a = currentUser.license) === null || _a === void 0 ? void 0 : _a.status) || "ok";
      if (licenseStatus === "ok" && currentUser.accessToken && (!currentUser.accessTokenExpiration || currentUser.accessTokenExpiration.getTime() > Date.now())) {
        return false;
      }
      if (currentUser.refreshToken && (!currentUser.refreshTokenExpiration || currentUser.refreshTokenExpiration.getTime() > Date.now())) {
        yield loadAccessToken(db);
        return false;
      }
    }
    const context2 = new AuthPersistedContext(db, {
      claims: {},
      lastLogin: /* @__PURE__ */ new Date(0)
    });
    yield authenticate(db.cloud.options.databaseUrl, context2, db.cloud.options.fetchTokens || otpFetchTokenCallback(db), db.cloud.userInteraction, hints);
    if (origUserId !== UNAUTHORIZED_USER.userId && context2.userId !== origUserId) {
      yield logout(db);
    }
    yield setCurrentUser(db, context2);
    triggerSync(db, "pull");
    return context2.userId !== origUserId;
  });
}
var swHolder = {};
var swContainer = typeof self !== "undefined" && self.document && // self.document is to verify we're not the SW ourself
typeof navigator !== "undefined" && navigator.serviceWorker;
if (swContainer)
  swContainer.ready.then((registration) => swHolder.registration = registration);
if (typeof self !== "undefined" && "clients" in self && !self.document) {
  addEventListener("message", (ev) => {
    var _a, _b;
    if ((_b = (_a = ev.data) === null || _a === void 0 ? void 0 : _a.type) === null || _b === void 0 ? void 0 : _b.startsWith("sw-broadcast-")) {
      [...self["clients"].matchAll({ includeUncontrolled: true })].forEach((client) => {
        var _a2;
        return client.id !== ((_a2 = ev.source) === null || _a2 === void 0 ? void 0 : _a2.id) && client.postMessage(ev.data);
      });
    }
  });
}
var SWBroadcastChannel = class {
  constructor(name) {
    this.name = name;
  }
  subscribe(listener) {
    if (!swContainer)
      return () => {
      };
    const forwarder = (ev) => {
      var _a;
      if (((_a = ev.data) === null || _a === void 0 ? void 0 : _a.type) === `sw-broadcast-${this.name}`) {
        listener(ev.data.message);
      }
    };
    swContainer.addEventListener("message", forwarder);
    return () => swContainer.removeEventListener("message", forwarder);
  }
  postMessage(message) {
    var _a;
    if (typeof self["clients"] === "object") {
      [...self["clients"].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
        type: `sw-broadcast-${this.name}`,
        message
      }));
    } else if (swHolder.registration) {
      (_a = swHolder.registration.active) === null || _a === void 0 ? void 0 : _a.postMessage({
        type: `sw-broadcast-${this.name}`,
        message
      });
    }
  }
};
var events = globalThis["lbc-events"] || (globalThis["lbc-events"] = /* @__PURE__ */ new Map());
function addListener(name, listener) {
  if (events.has(name)) {
    events.get(name).push(listener);
  } else {
    events.set(name, [listener]);
  }
}
function removeListener(name, listener) {
  const listeners = events.get(name);
  if (listeners) {
    const idx = listeners.indexOf(listener);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
  }
}
function dispatch(ev) {
  const listeners = events.get(ev.type);
  if (listeners) {
    listeners.forEach((listener) => {
      try {
        listener(ev);
      } catch (_a) {
      }
    });
  }
}
var BroadcastedAndLocalEvent = class extends Observable {
  constructor(name) {
    const bc = typeof BroadcastChannel === "undefined" ? new SWBroadcastChannel(name) : new BroadcastChannel(name);
    super((subscriber) => {
      function onCustomEvent(ev) {
        subscriber.next(ev.detail);
      }
      function onMessageEvent(ev) {
        console.debug("BroadcastedAndLocalEvent: onMessageEvent", ev);
        subscriber.next(ev.data);
      }
      let unsubscribe;
      addListener(`lbc-${name}`, onCustomEvent);
      try {
        if (bc instanceof SWBroadcastChannel) {
          unsubscribe = bc.subscribe((message) => subscriber.next(message));
        } else {
          console.debug("BroadcastedAndLocalEvent: bc.addEventListener()", name, "bc is a", bc);
          bc.addEventListener("message", onMessageEvent);
        }
      } catch (err) {
        console.warn("Failed to subscribe to broadcast channel", err);
      }
      return () => {
        removeListener(`lbc-${name}`, onCustomEvent);
        if (bc instanceof SWBroadcastChannel) {
          unsubscribe();
        } else {
          bc.removeEventListener("message", onMessageEvent);
        }
      };
    });
    this.name = name;
    this.bc = bc;
  }
  next(message) {
    console.debug("BroadcastedAndLocalEvent: bc.postMessage()", Object.assign({}, message), "bc is a", this.bc);
    this.bc.postMessage(message);
    const ev = new CustomEvent(`lbc-${this.name}`, { detail: message });
    dispatch(ev);
  }
};
function computeRealmSetHash(_a) {
  return __awaiter2(this, arguments, void 0, function* ({ realms, inviteRealms }) {
    const data = JSON.stringify([
      ...realms.map((realmId) => ({ realmId, accepted: true })),
      ...inviteRealms.map((realmId) => ({ realmId, accepted: false }))
    ].sort((a2, b) => a2.realmId < b.realmId ? -1 : a2.realmId > b.realmId ? 1 : 0));
    const byteArray = new TextEncoder().encode(data);
    const digestBytes = yield crypto.subtle.digest("SHA-1", byteArray);
    const base64 = b64encode(digestBytes);
    return base64;
  });
}
function getSyncableTables(db) {
  return Object.entries(db.cloud.schema || {}).filter(([, { markedForSync }]) => markedForSync).map(([tbl]) => db.tables.filter(({ name }) => name === tbl)[0]).filter((cloudTableSchema) => cloudTableSchema);
}
function getMutationTable(tableName) {
  return `$${tableName}_mutations`;
}
function getTableFromMutationTable(mutationTable) {
  var _a;
  const tableName = (_a = /^\$(.*)_mutations$/.exec(mutationTable)) === null || _a === void 0 ? void 0 : _a[1];
  if (!tableName)
    throw new Error(`Given mutationTable ${mutationTable} is not correct`);
  return tableName;
}
var concat3 = [].concat;
function flatten(a2) {
  return concat3.apply([], a2);
}
function listClientChanges(mutationTables_1, db_1) {
  return __awaiter2(this, arguments, void 0, function* (mutationTables, db, { since = {}, limit = Infinity } = {}) {
    const allMutsOnTables = yield Promise.all(mutationTables.map((mutationTable) => __awaiter2(this, void 0, void 0, function* () {
      const tableName = getTableFromMutationTable(mutationTable.name);
      const lastRevision = since[tableName];
      let query = lastRevision ? mutationTable.where("rev").above(lastRevision) : mutationTable;
      if (limit < Infinity)
        query = query.limit(limit);
      let muts = yield query.toArray();
      muts = canonicalizeToUpdateOps(muts);
      muts = removeRedundantUpdateOps(muts);
      const rv = muts.map((mut) => ({
        table: tableName,
        mut
      }));
      return rv;
    })));
    const sorted = flatten(allMutsOnTables).sort(
      (a2, b) => a2.mut.txid === b.mut.txid ? a2.mut.opNo - b.mut.opNo : a2.mut.ts - b.mut.ts
      // Different transactions - sort by timestamp when mutation resolved
    );
    const result = [];
    let currentEntry = null;
    let currentTxid = null;
    for (const { table, mut } of sorted) {
      if (currentEntry && currentEntry.table === table && currentTxid === mut.txid) {
        currentEntry.muts.push(mut);
      } else {
        currentEntry = {
          table,
          muts: [mut]
        };
        currentTxid = mut.txid;
        result.push(currentEntry);
      }
    }
    return result;
  });
}
function removeRedundantUpdateOps(muts) {
  const updateCoverage = /* @__PURE__ */ new Map();
  for (const mut of muts) {
    if (mut.type === "update") {
      if (mut.keys.length !== 1 || mut.changeSpecs.length !== 1) {
        continue;
      }
      const strKey = "" + mut.keys[0];
      const changeSpecs = mut.changeSpecs[0];
      if (Object.values(changeSpecs).some((v2) => typeof v2 === "object" && v2 && "@@propmod" in v2)) {
        continue;
      }
      let keyCoverage = updateCoverage.get(strKey);
      if (keyCoverage) {
        keyCoverage.push({ txid: mut.txid, updateSpec: changeSpecs });
      } else {
        updateCoverage.set(strKey, [{ txid: mut.txid, updateSpec: changeSpecs }]);
      }
    }
  }
  muts = muts.filter((mut) => {
    if (mut.type !== "update")
      return true;
    if (mut.keys.length !== 1 || mut.changeSpecs.length !== 1)
      return true;
    const changeSpecs = mut.changeSpecs[0];
    if (Object.values(changeSpecs).some((v2) => typeof v2 === "object" && v2 && "@@propmod" in v2)) {
      return true;
    }
    const unoverlappedProps = new Set(Object.keys(mut.changeSpecs[0]));
    const strKey = "" + mut.keys[0];
    const keyCoverage = updateCoverage.get(strKey);
    if (!keyCoverage)
      return true;
    for (let i2 = keyCoverage.length - 1; i2 >= 0; --i2) {
      const { txid, updateSpec } = keyCoverage[i2];
      if (txid === mut.txid)
        break;
      for (const keyPath of Object.keys(updateSpec)) {
        unoverlappedProps.delete(keyPath);
      }
    }
    if (unoverlappedProps.size === 0) {
      return false;
    }
    return true;
  });
  return muts;
}
function canonicalizeToUpdateOps(muts) {
  muts = muts.map((mut) => {
    if (mut.type === "modify" && mut.criteria.index === null) {
      const updateMut = Object.assign(Object.assign({}, mut), { criteria: void 0, changeSpec: void 0, type: "update", keys: mut.keys, changeSpecs: [mut.changeSpec] });
      delete updateMut.criteria;
      delete updateMut.changeSpec;
      return updateMut;
    }
    return mut;
  });
  return muts;
}
function randomString(bytes) {
  const buf = new Uint8Array(bytes);
  if (typeof crypto !== "undefined") {
    crypto.getRandomValues(buf);
  } else {
    for (let i2 = 0; i2 < bytes; i2++)
      buf[i2] = Math.floor(Math.random() * 256);
  }
  if (typeof Buffer !== "undefined" && Buffer.from) {
    return Buffer.from(buf).toString("base64");
  } else if (typeof btoa !== "undefined") {
    return btoa(String.fromCharCode.apply(null, buf));
  } else {
    throw new Error("No btoa or Buffer available");
  }
}
function listSyncifiedChanges(tablesToSyncify, currentUser, schema, alreadySyncedRealms) {
  return __awaiter2(this, void 0, void 0, function* () {
    const txid = `upload-${randomString(8)}`;
    if (currentUser.isLoggedIn) {
      if (tablesToSyncify.length > 0) {
        const ignoredRealms = new Set(alreadySyncedRealms || []);
        const upserts = yield Promise.all(tablesToSyncify.map((table) => __awaiter2(this, void 0, void 0, function* () {
          const { extractKey } = table.core.schema.primaryKey;
          if (!extractKey)
            return { table: table.name, muts: [] };
          const dexieCloudTableSchema = schema[table.name];
          const query = (dexieCloudTableSchema === null || dexieCloudTableSchema === void 0 ? void 0 : dexieCloudTableSchema.generatedGlobalId) ? table.filter((item) => {
            extractKey(item);
            return !ignoredRealms.has(item.realmId || "") && //(id[0] !== '#' || !!item.$ts) && // Private obj need no sync if not changed
            isValidAtID(extractKey(item), dexieCloudTableSchema === null || dexieCloudTableSchema === void 0 ? void 0 : dexieCloudTableSchema.idPrefix);
          }) : table.filter((item) => {
            const id2 = extractKey(item);
            return !ignoredRealms.has(item.realmId || "") && //(id[0] !== '#' || !!item.$ts) && // Private obj need no sync if not changed
            isValidSyncableID(id2);
          });
          const unsyncedObjects = yield query.toArray();
          if (unsyncedObjects.length > 0) {
            const mut = {
              type: "upsert",
              values: unsyncedObjects,
              keys: unsyncedObjects.map(extractKey),
              userId: currentUser.userId,
              txid
            };
            return {
              table: table.name,
              muts: [mut]
            };
          } else {
            return {
              table: table.name,
              muts: []
            };
          }
        })));
        return upserts.filter((op) => op.muts.length > 0);
      }
    }
    return [];
  });
}
function getTablesToSyncify(db, syncState) {
  const syncedTables = (syncState === null || syncState === void 0 ? void 0 : syncState.syncedTables) || [];
  const syncableTables = getSyncableTables(db);
  const tablesToSyncify = syncableTables.filter((tbl) => !syncedTables.includes(tbl.name));
  return tablesToSyncify;
}
var { toString: toStr } = {};
function getToStringTag(val) {
  return toStr.call(val).slice(8, -1);
}
function escapeDollarProps(value) {
  const keys2 = Object.keys(value);
  let dollarKeys = null;
  for (let i2 = 0, l2 = keys2.length; i2 < l2; ++i2) {
    if (keys2[i2][0] === "$") {
      dollarKeys = dollarKeys || [];
      dollarKeys.push(keys2[i2]);
    }
  }
  if (!dollarKeys)
    return value;
  const clone = { ...value };
  for (const k2 of dollarKeys) {
    delete clone[k2];
  }
  for (const k2 of dollarKeys) {
    clone["$" + k2] = value[k2];
  }
  return clone;
}
var ObjectDef = {
  replace: escapeDollarProps
};
function TypesonSimplified(...typeDefsInputs) {
  const typeDefs = typeDefsInputs.reduce((p2, c2) => ({ ...p2, ...c2 }), typeDefsInputs.reduce((p2, c2) => ({ ...c2, ...p2 }), {}));
  const protoMap = /* @__PURE__ */ new WeakMap();
  return {
    stringify(value, alternateChannel, space) {
      const json = JSON.stringify(value, function(key) {
        const realVal = this[key];
        const typeDef = getTypeDef(realVal);
        return typeDef ? typeDef.replace(realVal, alternateChannel, typeDefs) : realVal;
      }, space);
      return json;
    },
    parse(tson, alternateChannel) {
      const stack = [];
      return JSON.parse(tson, function(key, value) {
        const type = value === null || value === void 0 ? void 0 : value.$t;
        if (type) {
          const typeDef = typeDefs[type];
          value = typeDef ? typeDef.revive(value, alternateChannel, typeDefs) : value;
        }
        let top = stack[stack.length - 1];
        if (top && top[0] === value) {
          value = { ...value };
          for (const k2 of top[1])
            delete value[k2];
          for (const [k2, v2] of Object.entries(top[2])) {
            value[k2] = v2;
          }
          stack.pop();
        }
        if (value === void 0 || key[0] === "$" && key !== "$t") {
          top = stack[stack.length - 1];
          let deletes;
          let mods;
          if (top && top[0] === this) {
            deletes = top[1];
            mods = top[2];
          } else {
            stack.push([this, deletes = [], mods = {}]);
          }
          if (key[0] === "$" && key !== "$t") {
            deletes.push(key);
            mods[key.substr(1)] = value;
          } else {
            mods[key] = void 0;
          }
        }
        return value;
      });
    }
  };
  function getTypeDef(realVal) {
    const type = typeof realVal;
    switch (typeof realVal) {
      case "object":
      case "function": {
        if (realVal === null)
          return null;
        const proto = Object.getPrototypeOf(realVal);
        if (!proto)
          return ObjectDef;
        let typeDef = protoMap.get(proto);
        if (typeDef !== void 0)
          return typeDef;
        const toStringTag2 = getToStringTag(realVal);
        const entry = Object.entries(typeDefs).find(([typeName, typeDef2]) => {
          var _a, _b;
          return (_b = (_a = typeDef2 === null || typeDef2 === void 0 ? void 0 : typeDef2.test) === null || _a === void 0 ? void 0 : _a.call(typeDef2, realVal, toStringTag2)) !== null && _b !== void 0 ? _b : typeName === toStringTag2;
        });
        typeDef = entry === null || entry === void 0 ? void 0 : entry[1];
        if (!typeDef) {
          typeDef = Array.isArray(realVal) ? null : typeof realVal === "function" ? typeDefs.function || null : ObjectDef;
        }
        protoMap.set(proto, typeDef);
        return typeDef;
      }
      default:
        return typeDefs[type];
    }
  }
}
var BisonBinaryTypes = {
  Blob: {
    test: (blob, toStringTag2) => toStringTag2 === "Blob",
    replace: (blob, altChannel) => {
      const i2 = altChannel.length;
      altChannel.push(blob);
      return {
        $t: "Blob",
        mimeType: blob.type,
        i: i2
      };
    },
    revive: ({ i: i2, mimeType }, altChannel) => new Blob([altChannel[i2]], { type: mimeType })
  }
};
var numberDef = {
  number: {
    replace: (num) => {
      switch (true) {
        case isNaN(num):
          return { $t: "number", v: "NaN" };
        case num === Infinity:
          return { $t: "number", v: "Infinity" };
        case num === -Infinity:
          return { $t: "number", v: "-Infinity" };
        default:
          return num;
      }
    },
    revive: ({ v: v2 }) => Number(v2)
  }
};
var bigIntDef$1 = {
  bigint: {
    replace: (realVal) => {
      return { $t: "bigint", v: "" + realVal };
    },
    revive: (obj) => BigInt(obj.v)
  }
};
var DateDef = {
  Date: {
    replace: (date) => ({
      $t: "Date",
      v: isNaN(date.getTime()) ? "NaN" : date.toISOString()
    }),
    revive: ({ v: v2 }) => new Date(v2 === "NaN" ? NaN : Date.parse(v2))
  }
};
var SetDef = {
  Set: {
    replace: (set) => ({
      $t: "Set",
      v: Array.from(set.entries())
    }),
    revive: ({ v: v2 }) => new Set(v2)
  }
};
var MapDef = {
  Map: {
    replace: (map4) => ({
      $t: "Map",
      v: Array.from(map4.entries())
    }),
    revive: ({ v: v2 }) => new Map(v2)
  }
};
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof global !== "undefined" ? global : void 0;
var TypedArraysDefs = [
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "DataView",
  "BigInt64Array",
  "BigUint64Array"
].reduce((specs, typeName) => ({
  ...specs,
  [typeName]: {
    // Replace passes the the typed array into $t, buffer so that
    // the ArrayBuffer typedef takes care of further handling of the buffer:
    // {$t:"Uint8Array",buffer:{$t:"ArrayBuffer",idx:0}}
    // CHANGED ABOVE! Now shortcutting that for more sparse format of the typed arrays
    // to contain the b64 property directly.
    replace: (a2, _2, typeDefs) => {
      const result = {
        $t: typeName,
        v: typeDefs.ArrayBuffer.replace(a2.byteOffset === 0 && a2.byteLength === a2.buffer.byteLength ? a2.buffer : a2.buffer.slice(a2.byteOffset, a2.byteOffset + a2.byteLength), _2, typeDefs).v
      };
      return result;
    },
    revive: ({ v: v2 }, _2, typeDefs) => {
      const TypedArray = _global[typeName];
      return TypedArray && new TypedArray(typeDefs.ArrayBuffer.revive({ v: v2 }, _2, typeDefs));
    }
  }
}), {});
function b64LexEncode(b) {
  return b64ToLex(b64encode(b));
}
function b64LexDecode(b64Lex) {
  return b64decode(lexToB64(b64Lex));
}
function b64ToLex(base64) {
  var encoded = "";
  for (var i2 = 0, length2 = base64.length; i2 < length2; i2++) {
    encoded += ENCODE_TABLE[base64[i2]];
  }
  return encoded;
}
function lexToB64(base64lex) {
  if (typeof base64lex !== "string") {
    throw new Error("invalid decoder input: " + base64lex);
  }
  var base64 = "";
  for (var i2 = 0, length2 = base64lex.length; i2 < length2; i2++) {
    base64 += DECODE_TABLE[base64lex[i2]];
  }
  return base64;
}
var DECODE_TABLE = {
  "-": "=",
  "0": "A",
  "1": "B",
  "2": "C",
  "3": "D",
  "4": "E",
  "5": "F",
  "6": "G",
  "7": "H",
  "8": "I",
  "9": "J",
  A: "K",
  B: "L",
  C: "M",
  D: "N",
  E: "O",
  F: "P",
  G: "Q",
  H: "R",
  I: "S",
  J: "T",
  K: "U",
  L: "V",
  M: "W",
  N: "X",
  O: "Y",
  P: "Z",
  Q: "a",
  R: "b",
  S: "c",
  T: "d",
  U: "e",
  V: "f",
  W: "g",
  X: "h",
  Y: "i",
  Z: "j",
  _: "k",
  a: "l",
  b: "m",
  c: "n",
  d: "o",
  e: "p",
  f: "q",
  g: "r",
  h: "s",
  i: "t",
  j: "u",
  k: "v",
  l: "w",
  m: "x",
  n: "y",
  o: "z",
  p: "0",
  q: "1",
  r: "2",
  s: "3",
  t: "4",
  u: "5",
  v: "6",
  w: "7",
  x: "8",
  y: "9",
  z: "+",
  "|": "/"
};
var ENCODE_TABLE = {};
for (const c2 of Object.keys(DECODE_TABLE)) {
  ENCODE_TABLE[DECODE_TABLE[c2]] = c2;
}
var ArrayBufferDef = {
  ArrayBuffer: {
    replace: (ab) => ({
      $t: "ArrayBuffer",
      v: b64LexEncode(ab)
    }),
    revive: ({ v: v2 }) => {
      const ba = b64LexDecode(v2);
      return ba.buffer.byteLength === ba.byteLength ? ba.buffer : ba.buffer.slice(ba.byteOffset, ba.byteOffset + ba.byteLength);
    }
  }
};
var FakeBlob = class {
  constructor(buf, type) {
    this.buf = buf;
    this.type = type;
  }
};
function readBlobSync(b) {
  const req = new XMLHttpRequest();
  req.overrideMimeType("text/plain; charset=x-user-defined");
  req.open("GET", URL.createObjectURL(b), false);
  req.send();
  if (req.status !== 200 && req.status !== 0) {
    throw new Error("Bad Blob access: " + req.status);
  }
  return req.responseText;
}
function string2ArrayBuffer(str) {
  const array = new Uint8Array(str.length);
  for (let i2 = 0; i2 < str.length; ++i2) {
    array[i2] = str.charCodeAt(i2);
  }
  return array.buffer;
}
var BlobDef = {
  Blob: {
    test: (blob, toStringTag2) => toStringTag2 === "Blob" || blob instanceof FakeBlob,
    replace: (blob) => ({
      $t: "Blob",
      v: blob instanceof FakeBlob ? b64encode(blob.buf) : b64encode(string2ArrayBuffer(readBlobSync(blob))),
      type: blob.type
    }),
    revive: ({ type, v: v2 }) => {
      const ab = b64decode(v2);
      return typeof Blob !== void 0 ? new Blob([ab]) : new FakeBlob(ab.buffer, type);
    }
  }
};
var builtin = {
  ...numberDef,
  ...bigIntDef$1,
  ...DateDef,
  ...SetDef,
  ...MapDef,
  ...TypedArraysDefs,
  ...ArrayBufferDef,
  ...BlobDef
  // Should be moved to another preset for DOM types (or universal? since it supports node as well with FakeBlob)
};
function Bison(...typeDefsInputs) {
  const tson = TypesonSimplified(builtin, BisonBinaryTypes, ...typeDefsInputs);
  return {
    toBinary(value) {
      const [blob, json] = this.stringify(value);
      const lenBuf = new ArrayBuffer(4);
      new DataView(lenBuf).setUint32(0, blob.size);
      return new Blob([lenBuf, blob, json]);
    },
    stringify(value) {
      const binaries = [];
      const json = tson.stringify(value, binaries);
      const blob = new Blob(binaries.map((b) => {
        const lenBuf = new ArrayBuffer(4);
        new DataView(lenBuf).setUint32(0, "byteLength" in b ? b.byteLength : b.size);
        return new Blob([lenBuf, b]);
      }));
      return [blob, json];
    },
    async parse(json, binData) {
      let pos = 0;
      const arrayBuffers = [];
      const buf = await readBlobBinary(binData);
      const view = new DataView(buf);
      while (pos < buf.byteLength) {
        const len = view.getUint32(pos);
        pos += 4;
        const ab = buf.slice(pos, pos + len);
        pos += len;
        arrayBuffers.push(ab);
      }
      return tson.parse(json, arrayBuffers);
    },
    async fromBinary(blob) {
      const len = new DataView(await readBlobBinary(blob.slice(0, 4))).getUint32(0);
      const binData = blob.slice(4, len + 4);
      const json = await readBlob(blob.slice(len + 4));
      return await this.parse(json, binData);
    }
  };
}
function readBlob(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onabort = (ev) => reject(new Error("file read aborted"));
    reader.onerror = (ev) => reject(ev.target.error);
    reader.onload = (ev) => resolve(ev.target.result);
    reader.readAsText(blob);
  });
}
function readBlobBinary(blob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onabort = (ev) => reject(new Error("file read aborted"));
    reader.onerror = (ev) => reject(ev.target.error);
    reader.onload = (ev) => resolve(ev.target.result);
    reader.readAsArrayBuffer(blob);
  });
}
var undefinedDef = {
  undefined: {
    replace: () => ({
      $t: "undefined"
    }),
    revive: () => void 0
  }
};
var FileDef = {
  File: {
    test: (file, toStringTag2) => toStringTag2 === "File",
    replace: (file) => ({
      $t: "File",
      v: b64encode(string2ArrayBuffer(readBlobSync(file))),
      type: file.type,
      name: file.name,
      lastModified: new Date(file.lastModified).toISOString()
    }),
    revive: ({ type, v: v2, name, lastModified }) => {
      const ab = b64decode(v2);
      return new File([ab], name, {
        type,
        lastModified: new Date(lastModified).getTime()
      });
    }
  }
};
var hasBigIntSupport = typeof BigInt === "function" && typeof BigInt(0) === "bigint";
var FakeBigInt = class {
  toString() {
    return this.v;
  }
  constructor(value) {
    this.v = value;
  }
};
var bigIntDef = hasBigIntSupport ? {} : {
  bigint: {
    test: (val) => val instanceof FakeBigInt,
    replace: (fakeBigInt) => {
      return Object.assign({ $t: "bigint" }, fakeBigInt);
    },
    revive: ({ v: v2 }) => new FakeBigInt(v2)
  }
};
var defs = Object.assign(Object.assign(Object.assign(Object.assign({}, undefinedDef), bigIntDef), FileDef), { PropModification: {
  test: (val) => val instanceof PropModification,
  replace: (propModification) => {
    return Object.assign({ $t: "PropModification" }, propModification["@@propmod"]);
  },
  revive: (_a) => {
    var { $t } = _a, propModSpec = __rest(_a, ["$t"]);
    return new PropModification(propModSpec);
  }
} });
var TSON = TypesonSimplified(builtin, defs);
var BISON = Bison(defs);
function encodeIdsForServer(schema, currentUser, changes) {
  const rv = [];
  for (let change of changes) {
    const { table, muts } = change;
    const tableSchema = schema.tables.find((t2) => t2.name === table);
    if (!tableSchema)
      throw new Error(`Internal error: table ${table} not found in DBCore schema`);
    const { primaryKey } = tableSchema;
    let changeClone = change;
    muts.forEach((mut, mutIndex) => {
      const rewriteValues = !primaryKey.outbound && (mut.type === "upsert" || mut.type === "insert");
      mut.keys.forEach((key, keyIndex) => {
        if (Array.isArray(key)) {
          if (changeClone === change)
            changeClone = cloneChange(change, rewriteValues);
          const mutClone = changeClone.muts[mutIndex];
          const rewrittenKey = JSON.stringify(key);
          mutClone.keys[keyIndex] = rewrittenKey;
        } else if (key[0] === "#") {
          if (changeClone === change)
            changeClone = cloneChange(change, rewriteValues);
          const mutClone = changeClone.muts[mutIndex];
          if (!currentUser.isLoggedIn)
            throw new Error(`Internal error: Cannot sync private IDs before authenticated`);
          const rewrittenKey = `${key}:${currentUser.userId}`;
          mutClone.keys[keyIndex] = rewrittenKey;
          if (rewriteValues) {
            import_wrapper_default.setByKeyPath(mutClone.values[keyIndex], primaryKey.keyPath, rewrittenKey);
          }
        }
      });
    });
    rv.push(changeClone);
  }
  return rv;
}
function cloneChange(change, rewriteValues) {
  return Object.assign(Object.assign({}, change), { muts: rewriteValues ? change.muts.map((m2) => {
    return (m2.type === "insert" || m2.type === "upsert") && m2.values ? Object.assign(Object.assign({}, m2), { keys: m2.keys.slice(), values: m2.values.slice() }) : Object.assign(Object.assign({}, m2), { keys: m2.keys.slice() });
  }) : change.muts.map((m2) => Object.assign(Object.assign({}, m2), { keys: m2.keys.slice() })) });
}
var syncRatelimitDelays = /* @__PURE__ */ new WeakMap();
function checkSyncRateLimitDelay(db) {
  return __awaiter2(this, void 0, void 0, function* () {
    var _a, _b;
    const delatMilliseconds = ((_b = (_a = syncRatelimitDelays.get(db)) === null || _a === void 0 ? void 0 : _a.getTime()) !== null && _b !== void 0 ? _b : 0) - Date.now();
    if (delatMilliseconds > 0) {
      console.debug(`Stalling sync request ${delatMilliseconds} ms to spare ratelimits`);
      yield new Promise((resolve) => setTimeout(resolve, delatMilliseconds));
    }
  });
}
function updateSyncRateLimitDelays(db, res) {
  const limit = res.headers.get("Ratelimit-Limit");
  const remaining = res.headers.get("Ratelimit-Remaining");
  const reset = res.headers.get("Ratelimit-Reset");
  if (limit && remaining && reset) {
    const limitNum = Number(limit);
    const remainingNum = Math.max(0, Number(remaining));
    const willResetInSeconds = Number(reset);
    if (remainingNum < limitNum / 2) {
      const delay2 = Math.ceil(willResetInSeconds / (remainingNum + 1));
      syncRatelimitDelays.set(db, new Date(Date.now() + delay2 * 1e3));
      console.debug(`Sync ratelimit delay set to ${delay2} seconds`);
    } else {
      syncRatelimitDelays.delete(db);
      console.debug(`Sync ratelimit delay cleared`);
    }
  }
}
function syncWithServer(changes, y2, syncState, baseRevs, db, databaseUrl, schema, clientIdentity, currentUser) {
  return __awaiter2(this, void 0, void 0, function* () {
    const headers = {
      Accept: "application/json, application/x-bison, application/x-bison-stream",
      "Content-Type": "application/tson"
    };
    const updatedUser = yield loadAccessToken(db);
    const accessToken = updatedUser === null || updatedUser === void 0 ? void 0 : updatedUser.accessToken;
    if (accessToken) {
      headers.Authorization = `Bearer ${accessToken}`;
    }
    const syncRequest = {
      v: 2,
      dbID: syncState === null || syncState === void 0 ? void 0 : syncState.remoteDbId,
      clientIdentity,
      schema: schema || {},
      lastPull: syncState ? {
        serverRevision: syncState.serverRevision,
        yServerRevision: syncState.yServerRevision,
        realms: syncState.realms,
        inviteRealms: syncState.inviteRealms
      } : void 0,
      baseRevs,
      changes: encodeIdsForServer(db.dx.core.schema, currentUser, changes),
      y: y2,
      dxcv: db.cloud.version
    };
    console.debug("Sync request", syncRequest);
    db.syncStateChangedEvent.next({
      phase: "pushing"
    });
    const body = TSON.stringify(syncRequest);
    const res = yield fetch(`${databaseUrl}/sync`, {
      method: "post",
      headers,
      credentials: "include",
      // For Arr Affinity cookie only, for better Rate-Limit counting only.
      body
    });
    db.syncStateChangedEvent.next({
      phase: "pulling"
    });
    updateSyncRateLimitDelays(db, res);
    if (!res.ok) {
      throw new HttpError(res);
    }
    switch (res.headers.get("content-type")) {
      case "application/x-bison":
        return BISON.fromBinary(yield res.blob());
      case "application/x-bison-stream":
      //return BisonWebStreamReader(BISON, res);
      default:
      case "application/json": {
        const text2 = yield res.text();
        const syncRes = TSON.parse(text2);
        return syncRes;
      }
    }
  });
}
function modifyLocalObjectsWithNewUserId(syncifiedTables, currentUser, alreadySyncedRealms) {
  return __awaiter2(this, void 0, void 0, function* () {
    const ignoredRealms = new Set(alreadySyncedRealms || []);
    for (const table of syncifiedTables) {
      if (table.name === "members") {
        yield table.toCollection().modify((member) => {
          if (!ignoredRealms.has(member.realmId) && (!member.userId || member.userId === UNAUTHORIZED_USER.userId)) {
            member.userId = currentUser.userId;
          }
        });
      } else if (table.name === "roles") ;
      else if (table.name === "realms") {
        yield table.toCollection().modify((realm) => {
          if (!ignoredRealms.has(realm.realmId) && (realm.owner === void 0 || realm.owner === UNAUTHORIZED_USER.userId)) {
            realm.owner = currentUser.userId;
          }
        });
      } else {
        yield table.toCollection().modify((obj) => {
          if (!obj.realmId || !ignoredRealms.has(obj.realmId)) {
            if (!obj.owner || obj.owner === UNAUTHORIZED_USER.userId)
              obj.owner = currentUser.userId;
            if (!obj.realmId || obj.realmId === UNAUTHORIZED_USER.userId) {
              obj.realmId = currentUser.userId;
            }
          }
        });
      }
    }
  });
}
function throwIfCancelled(cancelToken) {
  if (cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.cancelled)
    throw new import_wrapper_default.AbortError(`Operation was cancelled`);
}
var isOnline = false;
if (typeof self !== "undefined" && typeof navigator !== "undefined") {
  isOnline = navigator.onLine;
  self.addEventListener("online", () => isOnline = true);
  self.addEventListener("offline", () => isOnline = false);
}
function updateBaseRevs(db, schema, latestRevisions, serverRev) {
  return __awaiter2(this, void 0, void 0, function* () {
    yield db.$baseRevs.bulkPut(Object.keys(schema).filter((table) => schema[table].markedForSync).map((tableName) => {
      const lastClientRevOnPreviousServerRev = latestRevisions[tableName] || 0;
      return {
        tableName,
        clientRev: lastClientRevOnPreviousServerRev + 1,
        serverRev
      };
    }));
    yield db.$baseRevs.where("tableName").noneOf(Object.keys(schema).filter((table) => schema[table].markedForSync)).delete();
  });
}
function getLatestRevisionsPerTable(clientChangeSet, lastRevisions = {}) {
  for (const { table, muts } of clientChangeSet) {
    const lastRev = muts.length > 0 ? muts[muts.length - 1].rev : null;
    lastRevisions[table] = lastRev || lastRevisions[table] || 0;
  }
  return lastRevisions;
}
function bulkUpdate(table, keys2, changeSpecs) {
  return __awaiter2(this, void 0, void 0, function* () {
    const objs = yield table.bulkGet(keys2);
    const resultKeys = [];
    const resultObjs = [];
    keys2.forEach((key, idx) => {
      const obj = objs[idx];
      if (obj) {
        for (const [keyPath, value] of Object.entries(changeSpecs[idx])) {
          if (keyPath === table.schema.primKey.keyPath) {
            if (cmp(value, key) !== 0) {
              throw new Error(`Cannot change primary key`);
            }
          } else {
            import_wrapper_default.setByKeyPath(obj, keyPath, value);
          }
        }
        resultKeys.push(key);
        resultObjs.push(obj);
      }
    });
    yield table.schema.primKey.keyPath == null ? table.bulkPut(resultObjs, resultKeys) : table.bulkPut(resultObjs);
  });
}
function applyServerChanges(changes, db) {
  return __awaiter2(this, void 0, void 0, function* () {
    console.debug("Applying server changes", changes, import_wrapper_default.currentTransaction);
    for (const { table: tableName, muts } of changes) {
      if (!db.dx._allTables[tableName]) {
        console.debug(`Server sent changes for table ${tableName} that we don't have. Ignoring.`);
        continue;
      }
      const table = db.table(tableName);
      const { primaryKey } = table.core.schema;
      const keyDecoder = (key) => {
        switch (key[0]) {
          case "[":
            if (key.endsWith("]"))
              try {
                return JSON.parse(key);
              } catch (_a) {
              }
            return key;
          case "#":
            if (key.endsWith(":" + db.cloud.currentUserId)) {
              return key.substr(0, key.length - db.cloud.currentUserId.length - 1);
            }
            return key;
          default:
            return key;
        }
      };
      for (const mut of muts) {
        const keys2 = mut.keys.map(keyDecoder);
        switch (mut.type) {
          case "insert":
            if (primaryKey.outbound) {
              yield table.bulkAdd(mut.values, keys2);
            } else {
              keys2.forEach((key, i2) => {
                import_wrapper_default.setByKeyPath(mut.values[i2], primaryKey.keyPath, key);
              });
              yield table.bulkAdd(mut.values);
            }
            break;
          case "upsert":
            if (primaryKey.outbound) {
              yield table.bulkPut(mut.values, keys2);
            } else {
              keys2.forEach((key, i2) => {
                import_wrapper_default.setByKeyPath(mut.values[i2], primaryKey.keyPath, key);
              });
              yield table.bulkPut(mut.values);
            }
            break;
          case "modify":
            if (keys2.length === 1) {
              yield table.update(keys2[0], mut.changeSpec);
            } else {
              yield table.where(":id").anyOf(keys2).modify(mut.changeSpec);
            }
            break;
          case "update":
            yield bulkUpdate(table, keys2, mut.changeSpecs);
            break;
          case "delete":
            yield table.bulkDelete(keys2);
            break;
        }
      }
    }
  });
}
var DEXIE_CLOUD_SYNCER_ID = "dexie-cloud-syncer";
function listUpdatesSince(yTable, sinceIncluding) {
  return yTable.where("i").between(sinceIncluding, Infinity, true).toArray();
}
function listYClientMessagesAndStateVector(db, tablesToSync) {
  return __awaiter2(this, void 0, void 0, function* () {
    const result = [];
    const lastUpdateIds = {};
    for (const table of tablesToSync) {
      if (table.schema.yProps) {
        for (const yProp of table.schema.yProps) {
          const yTable = db.table(yProp.updatesTable);
          const syncState = yield yTable.get(DEXIE_CLOUD_SYNCER_ID);
          const unsentFrom = (syncState === null || syncState === void 0 ? void 0 : syncState.unsentFrom) || 1;
          const receivedUntil = (syncState === null || syncState === void 0 ? void 0 : syncState.receivedUntil) || 0;
          const unsyncedFrom = Math.min(unsentFrom, receivedUntil + 1);
          const updates = yield listUpdatesSince(yTable, unsyncedFrom);
          if (updates.length > 0)
            lastUpdateIds[yTable.name] = updates[updates.length - 1].i;
          const perDoc = {};
          for (const update of updates) {
            const isLocal = ((update.f || 0) & 1) === 1;
            if (isLocal && update.i < unsentFrom)
              continue;
            const docKey = JSON.stringify(update.k) + "/" + isLocal;
            let entry = perDoc[docKey];
            if (!entry) {
              perDoc[docKey] = entry = {
                i: update.i,
                k: update.k,
                isLocal,
                u: []
              };
              entry.u.push(update.u);
            } else {
              entry.u.push(update.u);
              entry.i = Math.max(update.i, entry.i);
            }
          }
          for (const { k: k2, isLocal, u: u2, i: i2 } of Object.values(perDoc)) {
            const mergedUpdate = u2.length === 1 ? u2[0] : mergeUpdatesV2(u2);
            if (isLocal) {
              result.push({
                type: "u-c",
                table: table.name,
                prop: yProp.prop,
                k: k2,
                u: mergedUpdate,
                i: i2
              });
            } else {
              const stateVector = encodeStateVectorFromUpdateV2(mergedUpdate);
              result.push({
                type: "sv",
                table: table.name,
                prop: yProp.prop,
                k: k2,
                sv: stateVector
              });
            }
          }
        }
      }
    }
    return {
      yMessages: result,
      lastUpdateIds
    };
  });
}
function getUpdatesTable(db, table, ydocProp) {
  var _a, _b, _c;
  if (!db.dx._allTables[table])
    return void 0;
  const utbl = (_c = (_b = (_a = db.table(table)) === null || _a === void 0 ? void 0 : _a.schema.yProps) === null || _b === void 0 ? void 0 : _b.find((p2) => p2.prop === ydocProp)) === null || _c === void 0 ? void 0 : _c.updatesTable;
  if (!utbl) {
    console.debug(`No updatesTable found for ${table}.${ydocProp}`);
    return void 0;
  }
  if (!db.dx._allTables[utbl])
    return void 0;
  return db.table(utbl);
}
function applyYServerMessages(yMessages, db) {
  return __awaiter2(this, void 0, void 0, function* () {
    var _a;
    const receivedUntils = {};
    let resyncNeeded = false;
    let yServerRevision;
    for (const m2 of yMessages) {
      try {
        switch (m2.type) {
          case "u-s": {
            const utbl = getUpdatesTable(db, m2.table, m2.prop);
            if (utbl) {
              const updateRow = {
                k: m2.k,
                u: m2.u
              };
              if (m2.r) {
                updateRow.r = m2.r;
                yServerRevision = m2.r;
              }
              receivedUntils[utbl.name] = yield utbl.add(updateRow);
            }
            break;
          }
          case "u-ack": {
            const utbl = getUpdatesTable(db, m2.table, m2.prop);
            if (utbl) {
              yield db.transaction("rw", utbl, (tx) => __awaiter2(this, void 0, void 0, function* () {
                let syncer = yield tx.table(utbl.name).get(DEXIE_CLOUD_SYNCER_ID);
                yield tx.table(utbl.name).put(Object.assign(Object.assign({}, syncer || { i: DEXIE_CLOUD_SYNCER_ID }), { unsentFrom: Math.max((syncer === null || syncer === void 0 ? void 0 : syncer.unsentFrom) || 1, m2.i + 1) }));
              }));
            }
            break;
          }
          case "u-reject": {
            console.debug(`Y update rejected. Deleting it.`);
            const utbl = getUpdatesTable(db, m2.table, m2.prop);
            if (!utbl)
              break;
            const primaryKey = (_a = yield utbl.get(m2.i)) === null || _a === void 0 ? void 0 : _a.k;
            if (primaryKey != null) {
              yield db.transaction("rw", utbl, (tx) => {
                tx.idbtrans._rejecting_y_ypdate = true;
                return utbl.where("i").aboveOrEqual(m2.i).filter((u2) => cmp(u2.k, primaryKey) === 0 && ((u2.f || 0) & 1) === 1).delete();
              });
              const activeDoc = DexieYProvider.getDocCache(db.dx).find(m2.table, primaryKey, m2.prop);
              if (activeDoc)
                activeDoc.destroy();
            }
            break;
          }
          case "in-sync": {
            const doc2 = DexieYProvider.getDocCache(db.dx).find(m2.table, m2.k, m2.prop);
            if (doc2 && !doc2.isSynced) {
              doc2.emit("sync", [true, doc2]);
            }
            break;
          }
          case "y-complete-sync-done": {
            yServerRevision = m2.yServerRev;
            break;
          }
          case "outdated-server-rev":
            resyncNeeded = true;
            break;
        }
      } catch (e2) {
        console.error(`Failed to apply YMessage`, m2, e2);
      }
    }
    return {
      receivedUntils,
      resyncNeeded,
      yServerRevision
    };
  });
}
function updateYSyncStates(lastUpdateIdsBeforeSync, receivedUntilsAfterSync, db) {
  return __awaiter2(this, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e;
    const mergedSpec = {};
    for (const [yTable, lastUpdateId] of Object.entries(lastUpdateIdsBeforeSync)) {
      (_a = mergedSpec[yTable]) !== null && _a !== void 0 ? _a : mergedSpec[yTable] = {};
      mergedSpec[yTable].unsentFrom = lastUpdateId + 1;
    }
    for (const [yTable, lastUpdateId] of Object.entries(receivedUntilsAfterSync)) {
      (_b = mergedSpec[yTable]) !== null && _b !== void 0 ? _b : mergedSpec[yTable] = {};
      mergedSpec[yTable].receivedUntil = lastUpdateId;
    }
    const allYTables = Object.values(db.dx._dbSchema).filter((tblSchema) => tblSchema.yProps).map((tblSchema) => tblSchema.yProps.map((yProp) => yProp.updatesTable)).flat();
    for (const yTable of allYTables) {
      const mergedEntry = mergedSpec[yTable];
      const unsentFrom = (_c = mergedEntry === null || mergedEntry === void 0 ? void 0 : mergedEntry.unsentFrom) !== null && _c !== void 0 ? _c : 1;
      const receivedUntil = (_e = (_d = mergedEntry === null || mergedEntry === void 0 ? void 0 : mergedEntry.receivedUntil) !== null && _d !== void 0 ? _d : (
        // from local because we are in the same parent transaction (in sync.ts) that
        // applied all updates from the server
        (yield db.table(yTable).where("i").between(1, Infinity).reverse().limit(1).primaryKeys())[0]
      )) !== null && _e !== void 0 ? _e : 0;
      yield db.transaction("rw", yTable, () => __awaiter2(this, void 0, void 0, function* () {
        const state = yield db.table(yTable).get(DEXIE_CLOUD_SYNCER_ID);
        if (!state) {
          yield db.table(yTable).add({
            i: DEXIE_CLOUD_SYNCER_ID,
            unsentFrom,
            receivedUntil
          });
        } else {
          state.unsentFrom = Math.max(unsentFrom, state.unsentFrom || 1);
          state.receivedUntil = Math.max(receivedUntil, state.receivedUntil || 0);
          yield db.table(yTable).put(state);
        }
      }));
    }
  });
}
var BINSTREAM_TYPE_REALMID = 1;
var BINSTREAM_TYPE_TABLE_AND_PROP = 2;
var BINSTREAM_TYPE_DOCUMENT = 3;
function downloadYDocsFromServer(db_1, databaseUrl_1, _a) {
  return __awaiter2(this, arguments, void 0, function* (db, databaseUrl, { yDownloadedRealms, realms }) {
    if (yDownloadedRealms && realms && realms.every((realmId) => yDownloadedRealms[realmId] === "*")) {
      return;
    }
    console.debug("Downloading Y.Docs from added realms");
    const user = yield loadAccessToken(db);
    const headers = {
      "Content-Type": "application/json",
      Accept: "application/octet-stream"
    };
    if (user) {
      headers.Authorization = `Bearer ${user.accessToken}`;
    }
    const res = yield fetch(`${databaseUrl}/y/download`, {
      body: TSON.stringify({ downloadedRealms: yDownloadedRealms || {} }),
      method: "POST",
      headers,
      credentials: "include"
    });
    if (!res.ok) {
      throw new Error(`Failed to download Yjs documents from server. Status: ${res.status}`);
    }
    yield asyncIterablePipeline(getFetchResponseBodyGenerator(res), consumeChunkedBinaryStream, consumeDownloadChunks);
    function consumeDownloadChunks(chunks) {
      return __asyncGenerator2(this, arguments, function* consumeDownloadChunks_1() {
        var _a2, e_1, _b, _c;
        let currentRealmId = null;
        let currentTable = null;
        let currentProp = null;
        let docsToInsert = [];
        function storeCollectedDocs(completedRealm) {
          return __awaiter2(this, void 0, void 0, function* () {
            const lastDoc = docsToInsert[docsToInsert.length - 1];
            if (docsToInsert.length > 0) {
              if (!currentRealmId || !currentTable || !currentProp) {
                throw new Error(`Protocol error from ${databaseUrl}/y/download`);
              }
              const yTable = getUpdatesTable(db, currentTable, currentProp);
              if (yTable) {
                yield yTable.bulkAdd(docsToInsert);
              }
              docsToInsert = [];
            }
            if (currentRealmId && (currentTable && currentProp && lastDoc || completedRealm)) {
              yield db.$syncState.update("syncState", (syncState) => {
                const yDownloadedRealms2 = syncState.yDownloadedRealms || {};
                yDownloadedRealms2[currentRealmId] = completedRealm ? "*" : {
                  tbl: currentTable,
                  prop: currentProp,
                  key: lastDoc.k
                };
                syncState.yDownloadedRealms = yDownloadedRealms2;
              });
            }
          });
        }
        try {
          try {
            for (var _d = true, chunks_1 = __asyncValues2(chunks), chunks_1_1; chunks_1_1 = yield __await2(chunks_1.next()), _a2 = chunks_1_1.done, !_a2; _d = true) {
              _c = chunks_1_1.value;
              _d = false;
              const chunk = _c;
              const decoder = new Decoder(chunk);
              while (hasContent(decoder)) {
                switch (readUint8(decoder)) {
                  case BINSTREAM_TYPE_REALMID:
                    yield __await2(storeCollectedDocs(true));
                    currentRealmId = readVarString(decoder);
                    break;
                  case BINSTREAM_TYPE_TABLE_AND_PROP:
                    yield __await2(storeCollectedDocs(false));
                    currentTable = readVarString(decoder);
                    currentProp = readVarString(decoder);
                    break;
                  case BINSTREAM_TYPE_DOCUMENT: {
                    const k2 = readAny(decoder);
                    const u2 = readVarUint8Array(decoder);
                    docsToInsert.push({
                      k: k2,
                      u: u2
                    });
                    break;
                  }
                }
              }
              yield __await2(storeCollectedDocs(false));
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a2 && (_b = chunks_1.return)) yield __await2(_b.call(chunks_1));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          yield __await2(storeCollectedDocs(true));
        } catch (error) {
          if (!(error instanceof import_wrapper_default.DexieError)) {
            yield __await2(storeCollectedDocs(false));
          }
          throw error;
        }
      });
    }
  });
}
var CURRENT_SYNC_WORKER = "currentSyncWorker";
function sync(db, options, schema, syncOptions) {
  return _sync(db, options, schema, syncOptions).then((result) => {
    if (!(syncOptions === null || syncOptions === void 0 ? void 0 : syncOptions.justCheckIfNeeded)) {
      db.syncStateChangedEvent.next({
        phase: "in-sync"
      });
    }
    return result;
  }).catch((error) => __awaiter2(this, void 0, void 0, function* () {
    if (syncOptions === null || syncOptions === void 0 ? void 0 : syncOptions.justCheckIfNeeded)
      return Promise.reject(error);
    console.debug("Error from _sync", {
      isOnline,
      syncOptions,
      error
    });
    if (isOnline && (syncOptions === null || syncOptions === void 0 ? void 0 : syncOptions.retryImmediatelyOnFetchError) && (error === null || error === void 0 ? void 0 : error.name) === "TypeError" && /fetch/.test(error === null || error === void 0 ? void 0 : error.message)) {
      db.syncStateChangedEvent.next({
        phase: "error",
        error
      });
      yield new Promise((resolve) => setTimeout(resolve, 500));
      return yield sync(db, options, schema, Object.assign(Object.assign({}, syncOptions), { retryImmediatelyOnFetchError: false }));
    }
    yield db.$syncState.update("syncState", {
      timestamp: /* @__PURE__ */ new Date(),
      error: "" + error
    });
    db.syncStateChangedEvent.next({
      phase: isOnline ? "error" : "offline",
      error: new Error("" + (error === null || error === void 0 ? void 0 : error.message) || error)
    });
    return Promise.reject(error);
  }));
}
function _sync(db_1, options_1, schema_1) {
  return __awaiter2(this, arguments, void 0, function* (db, options, schema, { isInitialSync, cancelToken, justCheckIfNeeded, purpose } = {
    isInitialSync: false
  }) {
    var _a;
    if (!justCheckIfNeeded) {
      console.debug("SYNC STARTED", { isInitialSync, purpose });
    }
    if (!((_a = db.cloud.options) === null || _a === void 0 ? void 0 : _a.databaseUrl))
      throw new Error(`Internal error: sync must not be called when no databaseUrl is configured`);
    const { databaseUrl } = options;
    const currentUser = yield db.getCurrentUser();
    const tablesToSync = currentUser.isLoggedIn ? getSyncableTables(db) : [];
    const mutationTables = tablesToSync.map((tbl) => db.table(getMutationTable(tbl.name)));
    const persistedSyncState = yield db.getPersistedSyncState();
    const readyForSyncification = currentUser.isLoggedIn;
    const tablesToSyncify = readyForSyncification ? getTablesToSyncify(db, persistedSyncState) : [];
    throwIfCancelled(cancelToken);
    const doSyncify = tablesToSyncify.length > 0;
    if (doSyncify) {
      if (justCheckIfNeeded)
        return true;
      yield db.transaction("rw", tablesToSyncify, (tx) => __awaiter2(this, void 0, void 0, function* () {
        tx.idbtrans.disableChangeTracking = true;
        tx.idbtrans.disableAccessControl = true;
        yield modifyLocalObjectsWithNewUserId(tablesToSyncify, currentUser, persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.realms);
      }));
      throwIfCancelled(cancelToken);
    }
    const [clientChangeSet, syncState, baseRevs, { yMessages, lastUpdateIds }] = yield db.transaction("r", db.tables, () => __awaiter2(this, void 0, void 0, function* () {
      const syncState2 = yield db.getPersistedSyncState();
      let baseRevs2 = yield db.$baseRevs.toArray();
      baseRevs2 = baseRevs2.filter((br) => tablesToSync.some((tbl) => tbl.name === br.tableName));
      let clientChanges = yield listClientChanges(mutationTables, db);
      const yResults = yield listYClientMessagesAndStateVector(db, tablesToSync);
      throwIfCancelled(cancelToken);
      if (doSyncify) {
        const alreadySyncedRealms = [
          ...(persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.realms) || [],
          ...(persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.inviteRealms) || []
        ];
        const syncificationInserts = yield listSyncifiedChanges(tablesToSyncify, currentUser, schema, alreadySyncedRealms);
        throwIfCancelled(cancelToken);
        clientChanges = clientChanges.concat(syncificationInserts);
        return [clientChanges, syncState2, baseRevs2, yResults];
      }
      return [clientChanges, syncState2, baseRevs2, yResults];
    }));
    const pushSyncIsNeeded = clientChangeSet.some((set) => set.muts.some((mut) => mut.keys.length > 0)) || yMessages.some((m2) => m2.type === "u-c");
    if (justCheckIfNeeded) {
      console.debug("Sync is needed:", pushSyncIsNeeded);
      return pushSyncIsNeeded;
    }
    if (purpose === "push" && !pushSyncIsNeeded) {
      return false;
    }
    const latestRevisions = getLatestRevisionsPerTable(clientChangeSet, syncState === null || syncState === void 0 ? void 0 : syncState.latestRevisions);
    const clientIdentity = (syncState === null || syncState === void 0 ? void 0 : syncState.clientIdentity) || randomString$1(16);
    throwIfCancelled(cancelToken);
    const res = yield syncWithServer(clientChangeSet, yMessages, syncState, baseRevs, db, databaseUrl, schema, clientIdentity, currentUser);
    console.debug("Sync response", res);
    const { done, newSyncState } = yield db.transaction("rw", db.tables, (tx) => __awaiter2(this, void 0, void 0, function* () {
      tx.idbtrans.disableChangeTracking = true;
      tx.idbtrans.disableAccessControl = true;
      for (const tableName of Object.keys(schema)) {
        if (res.schema[tableName]) {
          schema[tableName] = res.schema[tableName];
        }
      }
      yield db.$syncState.put(schema, "schema");
      const addedClientChanges = yield listClientChanges(mutationTables, db, {
        since: latestRevisions
      });
      for (const mutTable of mutationTables) {
        const tableName = getTableFromMutationTable(mutTable.name);
        if (!addedClientChanges.some((ch) => ch.table === tableName && ch.muts.length > 0)) {
          yield Promise.all([
            mutTable.clear(),
            db.$baseRevs.where({ tableName }).delete()
          ]);
        } else if (latestRevisions[tableName]) {
          const latestRev = latestRevisions[tableName] || 0;
          yield Promise.all([
            mutTable.where("rev").belowOrEqual(latestRev).delete(),
            db.$baseRevs.where(":id").between([tableName, -Infinity], [tableName, latestRev + 1], true, true).reverse().offset(1).delete()
          ]);
        } else ;
      }
      getLatestRevisionsPerTable(addedClientChanges, latestRevisions);
      yield updateBaseRevs(db, schema, latestRevisions, res.serverRevision);
      const syncState2 = yield db.getPersistedSyncState();
      yield deleteObjectsFromRemovedRealms(db, res, syncState2);
      const newSyncState2 = syncState2 || {
        syncedTables: [],
        latestRevisions: {},
        realms: [],
        inviteRealms: [],
        clientIdentity
      };
      if (readyForSyncification) {
        newSyncState2.syncedTables = tablesToSync.map((tbl) => tbl.name).concat(tablesToSyncify.map((tbl) => tbl.name));
      }
      newSyncState2.latestRevisions = latestRevisions;
      newSyncState2.remoteDbId = res.dbId;
      newSyncState2.initiallySynced = true;
      newSyncState2.realms = res.realms;
      newSyncState2.inviteRealms = res.inviteRealms;
      newSyncState2.serverRevision = res.serverRevision;
      newSyncState2.yServerRevision = res.serverRevision;
      newSyncState2.timestamp = /* @__PURE__ */ new Date();
      delete newSyncState2.error;
      const filteredChanges = filterServerChangesThroughAddedClientChanges(res.changes, addedClientChanges);
      yield applyServerChanges(filteredChanges, db);
      if (res.yMessages) {
        const { receivedUntils, resyncNeeded, yServerRevision } = yield applyYServerMessages(res.yMessages, db);
        if (yServerRevision) {
          newSyncState2.yServerRevision = yServerRevision;
        }
        yield updateYSyncStates(lastUpdateIds, receivedUntils, db);
        if (resyncNeeded) {
          newSyncState2.yDownloadedRealms = {};
        }
      }
      db.$syncState.put(newSyncState2, "syncState");
      return {
        done: addedClientChanges.length === 0,
        newSyncState: newSyncState2
      };
    }));
    if (!done) {
      console.debug("MORE SYNC NEEDED. Go for it again!");
      yield checkSyncRateLimitDelay(db);
      return yield _sync(db, options, schema, { isInitialSync, cancelToken });
    }
    const usingYProps = Object.values(schema).some((tbl) => {
      var _a2;
      return (_a2 = tbl.yProps) === null || _a2 === void 0 ? void 0 : _a2.length;
    });
    const serverSupportsYprops = !!res.yMessages;
    if (usingYProps && serverSupportsYprops) {
      try {
        yield downloadYDocsFromServer(db, databaseUrl, newSyncState);
      } catch (error) {
        console.error("Failed to download Yjs documents from server", error);
      }
    }
    console.debug("SYNC DONE", { isInitialSync });
    db.syncCompleteEvent.next();
    return false;
  });
}
function deleteObjectsFromRemovedRealms(db, res, syncState) {
  return __awaiter2(this, void 0, void 0, function* () {
    const deletedRealms = /* @__PURE__ */ new Set();
    const rejectedRealms = /* @__PURE__ */ new Set();
    const previousRealmSet = syncState ? syncState.realms : [];
    const previousInviteRealmSet = syncState ? syncState.inviteRealms : [];
    const updatedRealmSet = new Set(res.realms);
    const updatedTotalRealmSet = new Set(res.realms.concat(res.inviteRealms));
    for (const realmId of previousRealmSet) {
      if (!updatedRealmSet.has(realmId)) {
        rejectedRealms.add(realmId);
        if (!updatedTotalRealmSet.has(realmId)) {
          deletedRealms.add(realmId);
        }
      }
    }
    for (const realmId of previousInviteRealmSet.concat(previousRealmSet)) {
      if (!updatedTotalRealmSet.has(realmId)) {
        deletedRealms.add(realmId);
      }
    }
    if (deletedRealms.size > 0 || rejectedRealms.size > 0) {
      const tables = getSyncableTables(db);
      for (const table of tables) {
        let realmsToDelete = ["realms", "members", "roles"].includes(table.name) ? deletedRealms : rejectedRealms;
        if (realmsToDelete.size === 0)
          continue;
        if (table.schema.indexes.some((idx) => idx.keyPath === "realmId" || Array.isArray(idx.keyPath) && idx.keyPath[0] === "realmId")) {
          yield table.where("realmId").anyOf([...realmsToDelete]).delete();
        } else {
          yield table.filter((obj) => !!(obj === null || obj === void 0 ? void 0 : obj.realmId) && realmsToDelete.has(obj.realmId)).delete();
        }
      }
    }
    if (rejectedRealms.size > 0 && (syncState === null || syncState === void 0 ? void 0 : syncState.yDownloadedRealms)) {
      for (const realmId of rejectedRealms) {
        delete syncState.yDownloadedRealms[realmId];
      }
    }
  });
}
function filterServerChangesThroughAddedClientChanges(serverChanges, addedClientChanges) {
  const changes = {};
  applyOperations(changes, serverChanges);
  const localPostChanges = {};
  applyOperations(localPostChanges, addedClientChanges);
  subtractChanges(changes, localPostChanges);
  return toDBOperationSet(changes);
}
var LIMIT_NUM_MESSAGES_PER_TIME = 10;
var TIME_WINDOW = 1e4;
var PAUSE_PERIOD = 1e3;
function MessagesFromServerConsumer(db) {
  const queue2 = [];
  const readyToServe = new BehaviorSubject(true);
  const event = new BehaviorSubject(null);
  let isWorking = false;
  let loopDetection = new Array(LIMIT_NUM_MESSAGES_PER_TIME).fill(0);
  event.subscribe(() => __awaiter2(this, void 0, void 0, function* () {
    if (isWorking)
      return;
    if (queue2.length > 0) {
      isWorking = true;
      loopDetection.shift();
      loopDetection.push(Date.now());
      readyToServe.next(false);
      try {
        yield consumeQueue();
      } finally {
        if (loopDetection[loopDetection.length - 1] - loopDetection[0] < TIME_WINDOW) {
          console.warn(`Slowing down websocket loop for ${PAUSE_PERIOD} milliseconds`);
          yield new Promise((resolve) => setTimeout(resolve, PAUSE_PERIOD));
        }
        isWorking = false;
        readyToServe.next(true);
      }
    }
  }));
  function enqueue2(msg) {
    queue2.push(msg);
    event.next(null);
  }
  function consumeQueue() {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f;
      while (queue2.length > 0) {
        const msg = queue2.shift();
        try {
          yield firstValueFrom(db.cloud.syncState.pipe(filter(({ phase }) => phase === "in-sync" || phase === "error")));
          console.debug("processing msg", msg);
          const persistedSyncState = db.cloud.persistedSyncState.value;
          if (!msg)
            continue;
          switch (msg.type) {
            case "token-expired":
              console.debug("WebSocket observable: Token expired. Refreshing token...");
              const user = db.cloud.currentUser.value;
              const refreshedLogin = yield refreshAccessToken(db.cloud.options.databaseUrl, user);
              yield db.table("$logins").update(user.userId, {
                accessToken: refreshedLogin.accessToken,
                accessTokenExpiration: refreshedLogin.accessTokenExpiration,
                claims: refreshedLogin.claims,
                license: refreshedLogin.license,
                data: refreshedLogin.data
              });
              break;
            case "realm-added":
              if (!((_a = persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.realms) === null || _a === void 0 ? void 0 : _a.includes(msg.realm)) && !((_b = persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.inviteRealms) === null || _b === void 0 ? void 0 : _b.includes(msg.realm))) {
                yield db.cloud.sync({ purpose: "pull", wait: true });
              }
              break;
            case "realm-accepted":
              if (!((_c = persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.realms) === null || _c === void 0 ? void 0 : _c.includes(msg.realm))) {
                yield db.cloud.sync({ purpose: "pull", wait: true });
              }
              break;
            case "realm-removed":
              if (((_d = persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.realms) === null || _d === void 0 ? void 0 : _d.includes(msg.realm)) || ((_e = persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.inviteRealms) === null || _e === void 0 ? void 0 : _e.includes(msg.realm))) {
                yield db.cloud.sync({ purpose: "pull", wait: true });
              }
              break;
            case "realms-changed":
              yield db.cloud.sync({ purpose: "pull", wait: true });
              break;
            case "changes":
              console.debug("changes");
              if (((_f = db.cloud.syncState.value) === null || _f === void 0 ? void 0 : _f.phase) === "error") {
                triggerSync(db, "pull");
                break;
              }
              yield db.transaction("rw", db.dx.tables, (tx) => __awaiter2(this, void 0, void 0, function* () {
                tx.idbtrans.disableChangeTracking = true;
                tx.idbtrans.disableAccessControl = true;
                const [schema, syncState, currentUser] = yield Promise.all([
                  db.getSchema(),
                  db.getPersistedSyncState(),
                  db.getCurrentUser()
                ]);
                console.debug("ws message queue: in transaction");
                if (!syncState || !schema || !currentUser) {
                  console.debug("required vars not present", {
                    syncState,
                    schema,
                    currentUser
                  });
                  return;
                }
                if (msg.baseRev !== syncState.serverRevision) {
                  console.debug(`baseRev (${msg.baseRev}) differs from our serverRevision in syncState (${syncState.serverRevision})`);
                  if (typeof msg.baseRev === "string" && // v2 format
                  (typeof syncState.serverRevision === "bigint" || // v1 format
                  typeof syncState.serverRevision === "object")) {
                    triggerSync(db, "pull");
                  }
                  return;
                }
                const ourRealmSetHash = yield import_wrapper_default.waitFor(
                  // Keep TX in non-IDB work
                  computeRealmSetHash(syncState)
                );
                console.debug("ourRealmSetHash", ourRealmSetHash);
                if (ourRealmSetHash !== msg.realmSetHash) {
                  console.debug("not same realmSetHash", msg.realmSetHash);
                  triggerSync(db, "pull");
                  return;
                }
                let clientChanges = [];
                if (currentUser.isLoggedIn) {
                  const mutationTables = getSyncableTables(db).map((tbl) => db.table(getMutationTable(tbl.name)));
                  clientChanges = yield listClientChanges(mutationTables, db);
                  console.debug("msg queue: client changes", clientChanges);
                }
                if (msg.changes.length > 0) {
                  const filteredChanges = filterServerChangesThroughAddedClientChanges(msg.changes, clientChanges);
                  console.debug("applying filtered server changes", filteredChanges);
                  yield applyServerChanges(filteredChanges, db);
                }
                syncState.latestRevisions = getLatestRevisionsPerTable(clientChanges, syncState.latestRevisions);
                syncState.serverRevision = msg.newRev;
                console.debug("Updating baseRefs", syncState.latestRevisions);
                yield updateBaseRevs(db, schema, syncState.latestRevisions, msg.newRev);
                console.debug("Updating syncState", syncState);
                yield db.$syncState.put(syncState, "syncState");
              }));
              console.debug("msg queue: done with rw transaction");
              break;
          }
        } catch (error) {
          console.error(`Error in msg queue`, error);
        }
      }
    });
  }
  return {
    enqueue: enqueue2,
    readyToServe
  };
}
var wm$1 = /* @__PURE__ */ new WeakMap();
var DEXIE_CLOUD_SCHEMA = {
  members: "@id, [userId+realmId], [email+realmId], realmId",
  roles: "[realmId+name]",
  realms: "@realmId",
  $jobs: "",
  $syncState: "",
  $baseRevs: "[tableName+clientRev]",
  $logins: "claims.sub, lastLogin"
};
var static_counter = 0;
function DexieCloudDB(dx) {
  if ("vip" in dx)
    dx = dx["vip"];
  let db = wm$1.get(dx.cloud);
  if (!db) {
    const localSyncEvent = new Subject();
    let syncStateChangedEvent = new BroadcastedAndLocalEvent(`syncstatechanged-${dx.name}`);
    let syncCompleteEvent = new BroadcastedAndLocalEvent(`synccomplete-${dx.name}`);
    localSyncEvent["id"] = ++static_counter;
    let initiallySynced = false;
    db = {
      get name() {
        return dx.name;
      },
      close() {
        return dx.close();
      },
      transaction: dx.transaction.bind(dx),
      table: dx.table.bind(dx),
      get tables() {
        return dx.tables;
      },
      cloud: dx.cloud,
      get $jobs() {
        return dx.table("$jobs");
      },
      get $syncState() {
        return dx.table("$syncState");
      },
      get $baseRevs() {
        return dx.table("$baseRevs");
      },
      get $logins() {
        return dx.table("$logins");
      },
      get realms() {
        return dx.realms;
      },
      get members() {
        return dx.members;
      },
      get roles() {
        return dx.roles;
      },
      get initiallySynced() {
        return initiallySynced;
      },
      localSyncEvent,
      get syncStateChangedEvent() {
        return syncStateChangedEvent;
      },
      get syncCompleteEvent() {
        return syncCompleteEvent;
      },
      dx
    };
    const helperMethods = {
      getCurrentUser() {
        return db.$logins.toArray().then((logins) => logins.find((l2) => l2.isLoggedIn) || UNAUTHORIZED_USER);
      },
      getPersistedSyncState() {
        return db.$syncState.get("syncState");
      },
      getSchema() {
        return db.$syncState.get("schema").then((schema) => {
          if (schema) {
            for (const table of db.tables) {
              if (table.schema.primKey && table.schema.primKey.keyPath && schema[table.name]) {
                schema[table.name].primaryKey = nameFromKeyPath(table.schema.primKey.keyPath);
              }
            }
          }
          return schema;
        });
      },
      getOptions() {
        return db.$syncState.get("options");
      },
      setInitiallySynced(value) {
        initiallySynced = value;
      },
      reconfigure() {
        syncStateChangedEvent = new BroadcastedAndLocalEvent(`syncstatechanged-${dx.name}`);
        syncCompleteEvent = new BroadcastedAndLocalEvent(`synccomplete-${dx.name}`);
      }
    };
    Object.assign(db, helperMethods);
    db.messageConsumer = MessagesFromServerConsumer(db);
    db.messageProducer = new Subject();
    wm$1.set(dx.cloud, db);
  }
  return db;
}
function nameFromKeyPath(keyPath) {
  return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
}
var isFirefox = typeof InstallTrigger !== "undefined";
var isSafari = typeof navigator !== "undefined" && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\/|Edge\//.test(navigator.userAgent);
var safariVersion = isSafari ? (
  // @ts-ignore
  [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1]
) : NaN;
var DISABLE_SERVICEWORKER_STRATEGY = isSafari && safariVersion <= 605 || // Disable for Safari for now.
isFirefox;
var IS_SERVICE_WORKER = typeof self !== "undefined" && "clients" in self && !self.document;
function throwVersionIncrementNeeded() {
  throw new import_wrapper_default.SchemaError(`Version increment needed to allow dexie-cloud change tracking`);
}
var { toString } = {};
function toStringTag(o2) {
  return toString.call(o2).slice(8, -1);
}
function getEffectiveKeys(primaryKey, req) {
  var _a;
  if (req.type === "delete")
    return req.keys;
  return ((_a = req.keys) === null || _a === void 0 ? void 0 : _a.slice()) || req.values.map(primaryKey.extractKey);
}
function applyToUpperBitFix(orig, bits) {
  return (bits & 1 ? orig[0].toUpperCase() : orig[0].toLowerCase()) + (bits & 2 ? orig[1].toUpperCase() : orig[1].toLowerCase()) + (bits & 4 ? orig[2].toUpperCase() : orig[2].toLowerCase());
}
var consonants = /b|c|d|f|g|h|j|k|l|m|n|p|q|r|s|t|v|x|y|z/i;
function isUpperCase(ch) {
  return ch >= "A" && ch <= "Z";
}
function generateTablePrefix(tableName, allPrefixes) {
  let rv = tableName[0].toLocaleLowerCase();
  for (let i2 = 1, l2 = tableName.length; i2 < l2 && rv.length < 3; ++i2) {
    if (consonants.test(tableName[i2]) || isUpperCase(tableName[i2]))
      rv += tableName[i2].toLowerCase();
  }
  while (allPrefixes.has(rv)) {
    if (/\d/g.test(rv)) {
      rv = rv.substr(0, rv.length - 1) + (rv[rv.length - 1] + 1);
      if (rv.length > 3)
        rv = rv.substr(0, 3);
      else
        continue;
    } else if (rv.length < 3) {
      rv = rv + "2";
      continue;
    }
    let bitFix = 1;
    let upperFixed = rv;
    while (allPrefixes.has(upperFixed) && bitFix < 8) {
      upperFixed = applyToUpperBitFix(rv, bitFix);
      ++bitFix;
    }
    if (bitFix < 8)
      rv = upperFixed;
    else {
      let nextChar = rv.charCodeAt(2) + 1 & 127;
      rv = rv.substr(0, 2) + String.fromCharCode(nextChar);
    }
  }
  return rv;
}
var time = 0;
function generateKey(prefix2, shardKey) {
  const a2 = new Uint8Array(18);
  const timePart = new Uint8Array(a2.buffer, 0, 6);
  const now = Date.now();
  if (time >= now) {
    ++time;
  } else {
    time = now;
  }
  timePart[0] = time / 1099511627776;
  timePart[1] = time / 4294967296;
  timePart[2] = time / 16777216;
  timePart[3] = time / 65536;
  timePart[4] = time / 256;
  timePart[5] = time;
  const randomPart = new Uint8Array(a2.buffer, 6);
  crypto.getRandomValues(randomPart);
  const id2 = new Uint8Array(a2.buffer);
  return prefix2 + b64LexEncode(id2) + (shardKey || "");
}
function createIdGenerationMiddleware(db) {
  return {
    stack: "dbcore",
    name: "idGenerationMiddleware",
    level: 1,
    create: (core) => {
      return Object.assign(Object.assign({}, core), { table: (tableName) => {
        const table = core.table(tableName);
        function generateOrVerifyAtKeys(req, idPrefix) {
          let valueClones = null;
          const keys2 = getEffectiveKeys(table.schema.primaryKey, req);
          keys2.forEach((key, idx) => {
            if (key === void 0) {
              const colocatedId = req.values[idx].realmId || db.cloud.currentUserId;
              const shardKey = colocatedId.substr(colocatedId.length - 3);
              keys2[idx] = generateKey(idPrefix, shardKey);
              if (!table.schema.primaryKey.outbound) {
                if (!valueClones)
                  valueClones = req.values.slice();
                valueClones[idx] = import_wrapper_default.deepClone(valueClones[idx]);
                import_wrapper_default.setByKeyPath(valueClones[idx], table.schema.primaryKey.keyPath, keys2[idx]);
              }
            } else if (typeof key !== "string" || !key.startsWith(idPrefix) && !key.startsWith("#" + idPrefix)) {
              throw new import_wrapper_default.ConstraintError(`The ID "${key}" is not valid for table "${tableName}". Primary '@' keys requires the key to be prefixed with "${idPrefix}" (or "#${idPrefix}).
If you want to generate IDs programmatically, remove '@' from the schema to get rid of this constraint. Dexie Cloud supports custom IDs as long as they are random and globally unique.`);
            }
          });
          return table.mutate(Object.assign(Object.assign({}, req), { keys: keys2, values: valueClones || req.values }));
        }
        return Object.assign(Object.assign({}, table), { mutate: (req) => {
          var _a, _b;
          const idbtrans = req.trans;
          if (idbtrans.mode === "versionchange") {
            idbtrans.disableChangeTracking = true;
            idbtrans.disableAccessControl = true;
          }
          if (idbtrans.disableChangeTracking) {
            return table.mutate(req);
          }
          if (req.type === "add" || req.type === "put") {
            const cloudTableSchema = (_a = db.cloud.schema) === null || _a === void 0 ? void 0 : _a[tableName];
            if (!(cloudTableSchema === null || cloudTableSchema === void 0 ? void 0 : cloudTableSchema.generatedGlobalId)) {
              if (cloudTableSchema === null || cloudTableSchema === void 0 ? void 0 : cloudTableSchema.markedForSync) {
                const keys2 = getEffectiveKeys(table.schema.primaryKey, req);
                keys2.forEach((key, idx) => {
                  if (!isValidSyncableID(key)) {
                    const type = Array.isArray(key) ? key.map(toStringTag).join(",") : toStringTag(key);
                    throw new import_wrapper_default.ConstraintError(`Invalid primary key type ${type} for table ${tableName}. Tables marked for sync has primary keys of type string or Array of string (and optional numbers)`);
                  }
                });
              }
            } else {
              if (((_b = db.cloud.options) === null || _b === void 0 ? void 0 : _b.databaseUrl) && !db.initiallySynced) {
                const keys2 = getEffectiveKeys(table.schema.primaryKey, req);
                return table.getMany({ keys: keys2, trans: req.trans, cache: "immutable" }).then((results) => {
                  if (results.length < keys2.length) {
                    throw new Error(`Unable to create new objects without an initial sync having been performed.`);
                  }
                  return table.mutate(req);
                });
              }
              return generateOrVerifyAtKeys(req, cloudTableSchema.idPrefix);
            }
          }
          return table.mutate(req);
        } });
      } });
    }
  };
}
function createImplicitPropSetterMiddleware(db) {
  return {
    stack: "dbcore",
    name: "implicitPropSetterMiddleware",
    level: 1,
    create: (core) => {
      return Object.assign(Object.assign({}, core), { table: (tableName) => {
        const table = core.table(tableName);
        return Object.assign(Object.assign({}, table), { mutate: (req) => {
          var _a, _b, _c, _d, _e, _f;
          const trans = req.trans;
          if (trans.disableChangeTracking) {
            return table.mutate(req);
          }
          const currentUserId = (_b = (_a = trans.currentUser) === null || _a === void 0 ? void 0 : _a.userId) !== null && _b !== void 0 ? _b : UNAUTHORIZED_USER.userId;
          if ((_d = (_c = db.cloud.schema) === null || _c === void 0 ? void 0 : _c[tableName]) === null || _d === void 0 ? void 0 : _d.markedForSync) {
            if (req.type === "add" || req.type === "put") {
              if (tableName === "members") {
                for (const member of req.values) {
                  if (typeof member.email === "string") {
                    member.email = member.email.trim().toLowerCase();
                  }
                }
              }
              for (const obj of req.values) {
                if (!obj.owner) {
                  obj.owner = currentUserId;
                }
                if (!obj.realmId) {
                  obj.realmId = currentUserId;
                }
                const key = (_f = (_e = table.schema.primaryKey).extractKey) === null || _f === void 0 ? void 0 : _f.call(_e, obj);
                if (typeof key === "string" && key[0] === "#") {
                  if (req.type === "put") {
                    delete req.criteria;
                    delete req.changeSpec;
                    if (!req.upsert)
                      delete req.updates;
                    obj.$ts = Date.now();
                  }
                }
              }
            }
          }
          return table.mutate(req);
        } });
      } });
    }
  };
}
function allSettled(possiblePromises) {
  return new Promise((resolve) => {
    if (possiblePromises.length === 0)
      resolve([]);
    let remaining = possiblePromises.length;
    const results = new Array(remaining);
    possiblePromises.forEach((p2, i2) => Promise.resolve(p2).then((value) => results[i2] = { status: "fulfilled", value }, (reason) => results[i2] = { status: "rejected", reason }).then(() => --remaining || resolve(results)));
  });
}
var counter$1 = 0;
function guardedTable(table) {
  const prop = "$lock" + ++counter$1;
  return Object.assign(Object.assign({}, table), { count: readLock(table.count, prop), get: readLock(table.get, prop), getMany: readLock(table.getMany, prop), openCursor: readLock(table.openCursor, prop), query: readLock(table.query, prop), mutate: writeLock(table.mutate, prop) });
}
function readLock(fn, prop) {
  return function readLocker(req) {
    const { readers, writers } = req.trans[prop] || (req.trans[prop] = { writers: [], readers: [] });
    const numWriters = writers.length;
    const promise = (numWriters > 0 ? writers[numWriters - 1].then(() => fn(req), () => fn(req)) : fn(req)).finally(() => {
      readers.splice(readers.indexOf(promise));
    });
    readers.push(promise);
    return promise;
  };
}
function writeLock(fn, prop) {
  return function writeLocker(req) {
    const { readers, writers } = req.trans[prop] || (req.trans[prop] = { writers: [], readers: [] });
    let promise = (writers.length > 0 ? writers[writers.length - 1].then(() => fn(req), () => fn(req)) : readers.length > 0 ? allSettled(readers).then(() => fn(req)) : fn(req)).finally(() => {
      writers.shift();
    });
    writers.push(promise);
    return promise;
  };
}
var outstandingTransactions = new BehaviorSubject(/* @__PURE__ */ new Set());
function isEagerSyncDisabled(db) {
  var _a, _b, _c, _d;
  return ((_a = db.cloud.options) === null || _a === void 0 ? void 0 : _a.disableEagerSync) || ((_c = (_b = db.cloud.currentUser.value) === null || _b === void 0 ? void 0 : _b.license) === null || _c === void 0 ? void 0 : _c.status) !== "ok" || !((_d = db.cloud.options) === null || _d === void 0 ? void 0 : _d.databaseUrl);
}
function createMutationTrackingMiddleware({ currentUserObservable, db }) {
  return {
    stack: "dbcore",
    name: "MutationTrackingMiddleware",
    level: 1,
    create: (core) => {
      const allTableNames = new Set(core.schema.tables.map((t2) => t2.name));
      const ordinaryTables = core.schema.tables.filter((t2) => !/^\$/.test(t2.name));
      const mutTableMap = /* @__PURE__ */ new Map();
      for (const tbl of ordinaryTables) {
        const mutationTableName = `$${tbl.name}_mutations`;
        if (allTableNames.has(mutationTableName)) {
          mutTableMap.set(tbl.name, core.table(mutationTableName));
        }
      }
      return Object.assign(Object.assign({}, core), { transaction: (tables, mode) => {
        let tx;
        if (mode === "readwrite") {
          const mutationTables = tables.filter((tbl) => {
            var _a, _b;
            return (_b = (_a = db.cloud.schema) === null || _a === void 0 ? void 0 : _a[tbl]) === null || _b === void 0 ? void 0 : _b.markedForSync;
          }).map((tbl) => getMutationTable(tbl));
          tx = core.transaction([...tables, ...mutationTables], mode);
        } else {
          tx = core.transaction(tables, mode);
        }
        if (mode === "readwrite") {
          tx.txid = randomString(16);
          tx.opCount = 0;
          tx.currentUser = currentUserObservable.value;
          outstandingTransactions.value.add(tx);
          outstandingTransactions.next(outstandingTransactions.value);
          const removeTransaction = () => {
            tx.removeEventListener("complete", txComplete);
            tx.removeEventListener("error", removeTransaction);
            tx.removeEventListener("abort", removeTransaction);
            outstandingTransactions.value.delete(tx);
            outstandingTransactions.next(outstandingTransactions.value);
          };
          const txComplete = () => {
            if (tx.mutationsAdded && !isEagerSyncDisabled(db)) {
              triggerSync(db, "push");
            }
            removeTransaction();
          };
          tx.addEventListener("complete", txComplete);
          tx.addEventListener("error", removeTransaction);
          tx.addEventListener("abort", removeTransaction);
        }
        return tx;
      }, table: (tableName) => {
        const table = core.table(tableName);
        if (/^\$/.test(tableName)) {
          if (tableName.endsWith("_mutations")) {
            return Object.assign(Object.assign({}, table), { mutate: (req) => {
              if (req.type === "add" || req.type === "put") {
                req.trans.mutationsAdded = true;
              }
              return table.mutate(req);
            } });
          } else if (tableName === "$logins") {
            return Object.assign(Object.assign({}, table), { mutate: (req) => {
              return table.mutate(req).then((res) => {
                req.trans.mutationsAdded = true;
                return res;
              }).catch((err) => {
                console.debug("Failed mutation $logins", err);
                return Promise.reject(err);
              });
            } });
          } else {
            return table;
          }
        }
        const { schema } = table;
        const mutsTable = mutTableMap.get(tableName);
        if (!mutsTable) {
          return table;
        }
        return guardedTable(Object.assign(Object.assign({}, table), { mutate: (req) => {
          var _a, _b, _c;
          const trans = req.trans;
          if (!trans.txid)
            return table.mutate(req);
          if (trans.disableChangeTracking)
            return table.mutate(req);
          if (!((_b = (_a = db.cloud.schema) === null || _a === void 0 ? void 0 : _a[tableName]) === null || _b === void 0 ? void 0 : _b.markedForSync))
            return table.mutate(req);
          if (!((_c = trans.currentUser) === null || _c === void 0 ? void 0 : _c.isLoggedIn)) {
            return table.mutate(req);
          }
          return req.type === "deleteRange" ? table.query({
            query: { range: req.range, index: schema.primaryKey },
            trans: req.trans,
            values: false
          }).then((res) => {
            return mutateAndLog({
              type: "delete",
              keys: res.result,
              trans: req.trans,
              criteria: { index: null, range: req.range }
            });
          }) : mutateAndLog(req);
        } }));
        function mutateAndLog(req) {
          var _a, _b;
          const trans = req.trans;
          const unsyncedProps = (_b = (_a = db.cloud.options) === null || _a === void 0 ? void 0 : _a.unsyncedProperties) === null || _b === void 0 ? void 0 : _b[tableName];
          const { txid, currentUser: { userId } } = trans;
          const { type } = req;
          const opNo = ++trans.opCount;
          function stripChangeSpec(changeSpec) {
            if (!unsyncedProps)
              return changeSpec;
            let rv = changeSpec;
            for (const keyPath of Object.keys(changeSpec)) {
              if (unsyncedProps.some((p2) => keyPath === p2 || keyPath.startsWith(p2 + "."))) {
                if (rv === changeSpec)
                  rv = Object.assign({}, changeSpec);
                delete rv[keyPath];
              }
            }
            return rv;
          }
          return table.mutate(req).then((res) => {
            var _a2;
            const { numFailures: hasFailures, failures } = res;
            let keys2 = type === "delete" ? req.keys : res.results;
            let values = "values" in req ? req.values : [];
            let changeSpec = "changeSpec" in req ? req.changeSpec : void 0;
            let updates = "updates" in req ? req.updates : void 0;
            let upsert = updates && "upsert" in req ? req.upsert : false;
            if (hasFailures) {
              keys2 = keys2.filter((_2, idx) => !failures[idx]);
              values = values.filter((_2, idx) => !failures[idx]);
            }
            if (unsyncedProps) {
              values = values.map((value) => {
                const newValue = Object.assign({}, value);
                for (const prop of unsyncedProps) {
                  delete newValue[prop];
                }
                return newValue;
              });
              if (changeSpec) {
                changeSpec = stripChangeSpec(changeSpec);
                if (Object.keys(changeSpec).length === 0) {
                  return res;
                }
              }
              if (updates) {
                let strippedChangeSpecs = updates.changeSpecs.map(stripChangeSpec);
                let newUpdates = {
                  keys: [],
                  changeSpecs: []
                };
                const validKeys = new RangeSet();
                let anyChangeSpecBecameEmpty = false;
                if (!upsert) {
                  for (let i2 = 0, l2 = strippedChangeSpecs.length; i2 < l2; ++i2) {
                    if (Object.keys(strippedChangeSpecs[i2]).length > 0) {
                      newUpdates.keys.push(updates.keys[i2]);
                      newUpdates.changeSpecs.push(strippedChangeSpecs[i2]);
                      validKeys.addKey(updates.keys[i2]);
                    } else {
                      anyChangeSpecBecameEmpty = true;
                    }
                  }
                  updates = newUpdates;
                  if (anyChangeSpecBecameEmpty) {
                    let newKeys = [];
                    let newValues = [];
                    for (let i2 = 0, l2 = keys2.length; i2 < l2; ++i2) {
                      if (validKeys.hasKey(keys2[i2])) {
                        newKeys.push(keys2[i2]);
                        newValues.push(values[i2]);
                      }
                    }
                    keys2 = newKeys;
                    values = newValues;
                  }
                }
              }
            }
            const ts = Date.now();
            let criteria = "criteria" in req && req.criteria ? Object.assign(Object.assign({}, req.criteria), { index: req.criteria.index === schema.primaryKey.keyPath ? null : req.criteria.index }) : void 0;
            if (unsyncedProps && (criteria === null || criteria === void 0 ? void 0 : criteria.index)) {
              const keyPaths = (_a2 = schema.indexes.find((idx) => idx.name === criteria.index)) === null || _a2 === void 0 ? void 0 : _a2.keyPath;
              const involvedProps = keyPaths ? typeof keyPaths === "string" ? [keyPaths] : keyPaths : [];
              if (involvedProps.some((p2) => unsyncedProps === null || unsyncedProps === void 0 ? void 0 : unsyncedProps.includes(p2))) {
                criteria = void 0;
              }
            }
            const mut = req.type === "delete" ? {
              type: "delete",
              ts,
              opNo,
              keys: keys2,
              criteria,
              txid,
              userId
            } : req.type === "add" ? {
              type: "insert",
              ts,
              opNo,
              keys: keys2,
              txid,
              userId,
              values
            } : upsert && updates ? {
              type: "upsert",
              ts,
              opNo,
              keys: keys2,
              values,
              changeSpecs: updates.changeSpecs.filter((_2, idx) => !failures[idx]),
              txid,
              userId
            } : criteria && changeSpec ? {
              // Common changeSpec for all keys
              type: "modify",
              ts,
              opNo,
              keys: keys2,
              criteria,
              changeSpec,
              txid,
              userId
            } : changeSpec ? {
              // In case criteria involved an unsynced property, we go for keys instead.
              type: "update",
              ts,
              opNo,
              keys: keys2,
              changeSpecs: keys2.map(() => changeSpec),
              txid,
              userId
            } : updates ? {
              // One changeSpec per key
              type: "update",
              ts,
              opNo,
              keys: updates.keys,
              changeSpecs: updates.changeSpecs,
              txid,
              userId
            } : {
              type: "upsert",
              ts,
              opNo,
              keys: keys2,
              values,
              txid,
              userId
            };
            if ("isAdditionalChunk" in req && req.isAdditionalChunk) {
              mut.isAdditionalChunk = true;
            }
            return keys2.length > 0 || criteria ? mutsTable.mutate({ type: "add", trans, values: [mut] }).then(() => {
              trans.mutationsAdded = true;
              return res;
            }) : res;
          });
        }
      } });
    }
  };
}
function overrideParseStoresSpec(origFunc, dexie) {
  return function(stores, dbSchema) {
    var _a;
    const storesClone = Object.assign(Object.assign({}, DEXIE_CLOUD_SCHEMA), stores);
    Object.keys(DEXIE_CLOUD_SCHEMA).forEach((tableName) => {
      const schemaSrc = storesClone[tableName];
      if (schemaSrc == null) {
        throw new Error(`Cannot delete table ${tableName} as it is needed for access control of Dexie Cloud`);
      }
      if (!stores[tableName]) {
        return;
      }
      const requestedIndexes = schemaSrc.split(",").map((spec) => spec.trim());
      const builtInIndexes = DEXIE_CLOUD_SCHEMA[tableName].split(",").map((spec) => spec.trim());
      const requestedIndexSet = new Set(requestedIndexes.map((index) => index.replace(/([&*]|\+\+)/g, "")));
      if (requestedIndexes[0] !== builtInIndexes[0]) {
        throw new Error(`Cannot override primary key of table ${tableName}. Please declare it as {${tableName}: ${JSON.stringify(DEXIE_CLOUD_SCHEMA[tableName])}`);
      }
      for (let i2 = 1; i2 < builtInIndexes.length; ++i2) {
        const builtInIndex = builtInIndexes[i2];
        if (!requestedIndexSet.has(builtInIndex.replace(/([&*]|\+\+)/g, ""))) {
          storesClone[tableName] += `,${builtInIndex}`;
        }
      }
    });
    const cloudSchema = dexie.cloud.schema || (dexie.cloud.schema = {});
    const allPrefixes = /* @__PURE__ */ new Set();
    Object.keys(storesClone).forEach((tableName) => {
      var _a2;
      const schemaSrc = (_a2 = storesClone[tableName]) === null || _a2 === void 0 ? void 0 : _a2.trim();
      const cloudTableSchema = cloudSchema[tableName] || (cloudSchema[tableName] = {});
      if (schemaSrc != null) {
        if (/^\@/.test(schemaSrc)) {
          storesClone[tableName] = storesClone[tableName].substr(1);
          cloudTableSchema.generatedGlobalId = true;
          cloudTableSchema.idPrefix = generateTablePrefix(tableName, allPrefixes);
          allPrefixes.add(cloudTableSchema.idPrefix);
        }
        if (!/^\$/.test(tableName)) {
          storesClone[`$${tableName}_mutations`] = "++rev";
          cloudTableSchema.markedForSync = true;
        }
        if (cloudTableSchema.deleted) {
          cloudTableSchema.deleted = false;
        }
      } else {
        cloudTableSchema.deleted = true;
        cloudTableSchema.markedForSync = false;
        storesClone[`$${tableName}_mutations`] = null;
      }
    });
    const rv = origFunc.call(this, storesClone, dbSchema);
    for (const [tableName, spec] of Object.entries(dbSchema)) {
      if ((_a = spec.yProps) === null || _a === void 0 ? void 0 : _a.length) {
        const cloudTableSchema = cloudSchema[tableName];
        if (cloudTableSchema) {
          cloudTableSchema.yProps = spec.yProps.map((yProp) => yProp.prop);
        }
      }
    }
    return rv;
  };
}
function performGuardedJob(db, jobName, job) {
  if (typeof navigator === "undefined" || !navigator.locks) {
    return job();
  }
  return navigator.locks.request(db.name + "|" + jobName, job);
}
function performInitialSync(db, cloudOptions, cloudSchema) {
  return __awaiter2(this, void 0, void 0, function* () {
    console.debug("Performing initial sync");
    yield performGuardedJob(db, CURRENT_SYNC_WORKER, () => sync(db, cloudOptions, cloudSchema, { isInitialSync: true }));
    console.debug("Done initial sync");
  });
}
var USER_INACTIVITY_TIMEOUT = 18e4;
var INACTIVE_WAIT_TIME = 2e4;
var userIsActive = new BehaviorSubject(true);
var userIsReallyActive = new BehaviorSubject(true);
userIsActive.pipe(switchMap((isActive) => {
  return isActive ? of(true) : of(false).pipe(delay(INACTIVE_WAIT_TIME));
}), distinctUntilChanged()).subscribe(userIsReallyActive);
var visibilityStateIsChanged = typeof document !== "undefined" ? fromEvent(document, "visibilitychange") : of({});
var documentBecomesHidden = visibilityStateIsChanged.pipe(filter(() => document.visibilityState === "hidden"));
var documentBecomesVisible = visibilityStateIsChanged.pipe(filter(() => document.visibilityState === "visible"));
var userDoesSomething = typeof window !== "undefined" ? merge(documentBecomesVisible, fromEvent(window, "mousedown"), fromEvent(window, "mousemove"), fromEvent(window, "keydown"), fromEvent(window, "wheel"), fromEvent(window, "touchmove")) : of({});
if (typeof document !== "undefined") {
  merge(
    of(true),
    // Make sure something is always emitted from start
    documentBecomesHidden,
    // so that we can eagerly emit false!
    userDoesSomething
  ).pipe(
    // No matter event source, compute whether user is visible using visibilityState:
    map(() => document.visibilityState === "visible"),
    // Make sure to emit it
    tap((isActive) => {
      if (userIsActive.value !== isActive) {
        userIsActive.next(isActive);
      }
    }),
    // Now, if true was emitted, make sure to set a timeout to emit false
    // unless new user activity things happen (in that case, the timeout will be cancelled!)
    switchMap((isActive) => isActive ? of(0).pipe(delay(USER_INACTIVITY_TIMEOUT - INACTIVE_WAIT_TIME), tap(() => userIsActive.next(false))) : of(0))
  ).subscribe(() => {
  });
}
var TokenExpiredError = class extends Error {
  constructor() {
    super(...arguments);
    this.name = "TokenExpiredError";
  }
};
function createYClientUpdateObservable(db) {
  const yTableRecords = flatten(db.tables.filter((table) => {
    var _a, _b;
    return ((_b = (_a = db.cloud.schema) === null || _a === void 0 ? void 0 : _a[table.name]) === null || _b === void 0 ? void 0 : _b.markedForSync) && table.schema.yProps;
  }).map((table) => table.schema.yProps.map((p2) => ({
    table: table.name,
    ydocProp: p2.prop,
    updatesTable: p2.updatesTable
  }))));
  return merge(...yTableRecords.map(({ table, ydocProp, updatesTable }) => {
    const yTbl = db.table(updatesTable);
    return from3(yTbl.get(DEXIE_CLOUD_SYNCER_ID)).pipe(switchMap((syncer) => {
      let currentUnsentFrom = (syncer === null || syncer === void 0 ? void 0 : syncer.unsentFrom) || 1;
      return from3(liveQuery(() => __awaiter2(this, void 0, void 0, function* () {
        const addedUpdates = yield listUpdatesSince(yTbl, currentUnsentFrom);
        return addedUpdates.filter((update) => update.f && update.f & 1).map((update) => {
          return {
            type: "u-c",
            table,
            prop: ydocProp,
            k: update.k,
            u: update.u,
            i: update.i
          };
        });
      }))).pipe(tap((addedUpdates) => {
        if (addedUpdates.length > 0) {
          currentUnsentFrom = addedUpdates.at(-1).i + 1;
        }
      }));
    }));
  })).pipe(
    // Flatten the array of messages.
    // If messageProducer emits empty array, nothing is emitted
    // but if messageProducer emits array of messages, they are
    // emitted one by one.
    mergeMap((messages) => messages)
  );
}
var awarenessWeakMap = /* @__PURE__ */ new WeakMap();
var getDocAwareness = (doc2) => awarenessWeakMap.get(doc2);
var wm2 = /* @__PURE__ */ new WeakMap();
function getOpenDocSignal(doc2) {
  let signal = wm2.get(doc2);
  if (!signal) {
    signal = new Subject();
    wm2.set(doc2, signal);
  }
  return signal;
}
var SERVER_PING_TIMEOUT = 2e4;
var CLIENT_PING_INTERVAL = 3e4;
var FAIL_RETRY_WAIT_TIME = 6e4;
var WSObservable = class extends Observable {
  constructor(db, rev, yrev, realmSetHash, clientIdentity, messageProducer, webSocketStatus, user) {
    super((subscriber) => new WSConnection(db, rev, yrev, realmSetHash, clientIdentity, user, subscriber, messageProducer, webSocketStatus));
  }
};
var counter = 0;
var WSConnection = class extends Subscription {
  constructor(db, rev, yrev, realmSetHash, clientIdentity, user, subscriber, messageProducer, webSocketStatus) {
    super(() => this.teardown());
    this.id = ++counter;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.reconnecting = false;
    console.debug("New WebSocket Connection", this.id, user.accessToken ? "authorized" : "unauthorized");
    this.db = db;
    this.databaseUrl = db.cloud.options.databaseUrl;
    this.rev = rev;
    this.yrev = yrev;
    this.realmSetHash = realmSetHash;
    this.clientIdentity = clientIdentity;
    this.user = user;
    this.subscriber = subscriber;
    this.lastUserActivity = /* @__PURE__ */ new Date();
    this.messageProducer = messageProducer;
    this.webSocketStatus = webSocketStatus;
    this.connect();
  }
  teardown() {
    console.debug("Teardown WebSocket Connection", this.id);
    this.disconnect();
  }
  disconnect() {
    this.webSocketStatus.next("disconnected");
    if (this.pinger) {
      clearInterval(this.pinger);
      this.pinger = null;
    }
    if (this.ws) {
      try {
        this.ws.close();
      } catch (_a) {
      }
    }
    this.ws = null;
    for (const sub of this.subscriptions) {
      sub.unsubscribe();
    }
    this.subscriptions.clear();
  }
  reconnect() {
    if (this.reconnecting)
      return;
    this.reconnecting = true;
    try {
      this.disconnect();
    } catch (_a) {
    }
    this.connect().catch(() => {
    }).then(() => this.reconnecting = false);
  }
  connect() {
    return __awaiter2(this, void 0, void 0, function* () {
      this.lastServerActivity = /* @__PURE__ */ new Date();
      if (this.pauseUntil && this.pauseUntil > /* @__PURE__ */ new Date()) {
        console.debug("WS not reconnecting just yet", {
          id: this.id,
          pauseUntil: this.pauseUntil
        });
        return;
      }
      if (this.ws) {
        throw new Error(`Called connect() when a connection is already open`);
      }
      if (!this.databaseUrl)
        throw new Error(`Cannot connect without a database URL`);
      if (this.closed) {
        return;
      }
      const tokenExpiration = this.user.accessTokenExpiration;
      if (tokenExpiration && tokenExpiration < /* @__PURE__ */ new Date()) {
        this.subscriber.error(new TokenExpiredError());
        return;
      }
      this.webSocketStatus.next("connecting");
      this.pinger = setInterval(() => __awaiter2(this, void 0, void 0, function* () {
        if (this.closed) {
          console.debug("pinger check", this.id, "CLOSED.");
          this.teardown();
          return;
        }
        if (this.ws) {
          try {
            this.ws.send(JSON.stringify({ type: "ping" }));
            setTimeout(() => {
              console.debug("pinger setTimeout", this.id, this.pinger ? `alive` : "dead");
              if (!this.pinger)
                return;
              if (this.closed) {
                console.debug("pinger setTimeout", this.id, "subscription is closed");
                this.teardown();
                return;
              }
              if (this.lastServerActivity < new Date(Date.now() - SERVER_PING_TIMEOUT)) {
                console.debug("pinger: server is inactive");
                console.debug("pinger reconnecting");
                this.reconnect();
              } else {
                console.debug("pinger: server still active");
              }
            }, SERVER_PING_TIMEOUT);
          } catch (_a) {
            console.debug("pinger catch error", this.id, "reconnecting");
            this.reconnect();
          }
        } else {
          console.debug("pinger", this.id, "reconnecting");
          this.reconnect();
        }
      }), CLIENT_PING_INTERVAL);
      const wsUrl = new URL(this.databaseUrl);
      wsUrl.protocol = wsUrl.protocol === "http:" ? "ws" : "wss";
      const searchParams = new URLSearchParams();
      if (this.subscriber.closed)
        return;
      searchParams.set("v", "2");
      if (this.rev)
        searchParams.set("rev", this.rev);
      if (this.yrev)
        searchParams.set("yrev", this.yrev);
      searchParams.set("realmsHash", this.realmSetHash);
      searchParams.set("clientId", this.clientIdentity);
      searchParams.set("dxcv", this.db.cloud.version);
      if (this.user.accessToken) {
        searchParams.set("token", this.user.accessToken);
      }
      console.debug("dexie-cloud WebSocket create");
      const ws = this.ws = new WebSocket(`${wsUrl}/changes?${searchParams}`);
      ws.binaryType = "arraybuffer";
      ws.onclose = (event) => {
        if (!this.pinger)
          return;
        console.debug("dexie-cloud WebSocket onclosed", this.id);
        this.reconnect();
      };
      ws.onmessage = (event) => {
        if (!this.pinger)
          return;
        this.lastServerActivity = /* @__PURE__ */ new Date();
        try {
          const msg = typeof event.data === "string" ? TSON.parse(event.data) : decodeYMessage(new Uint8Array(event.data));
          console.debug("dexie-cloud WebSocket onmessage", msg.type, msg);
          if (msg.type === "error") {
            throw new Error(`Error message from dexie-cloud: ${msg.error}`);
          } else if (msg.type === "aware") {
            const docCache = DexieYProvider.getDocCache(this.db.dx);
            const doc2 = docCache.find(msg.table, msg.k, msg.prop);
            if (doc2) {
              const awareness = getDocAwareness(doc2);
              if (awareness) {
                applyAwarenessUpdate(awareness, msg.u, "server");
              }
            }
          } else if (msg.type === "pong") {
          } else if (msg.type === "doc-open") {
            const docCache = DexieYProvider.getDocCache(this.db.dx);
            const doc2 = docCache.find(msg.table, msg.k, msg.prop);
            if (doc2) {
              getOpenDocSignal(doc2).next();
            }
          } else if (msg.type === "u-ack" || msg.type === "u-reject" || msg.type === "u-s" || msg.type === "in-sync" || msg.type === "outdated-server-rev" || msg.type === "y-complete-sync-done") {
            applyYServerMessages([msg], this.db).then((_a) => __awaiter2(this, [_a], void 0, function* ({ resyncNeeded, yServerRevision, receivedUntils }) {
              if (yServerRevision) {
                yield this.db.$syncState.update("syncState", { yServerRevision });
              }
              if (msg.type === "u-s" && receivedUntils) {
                const utbl = getUpdatesTable(this.db, msg.table, msg.prop);
                if (utbl) {
                  const receivedUntil = receivedUntils[utbl.name];
                  if (receivedUntil) {
                    yield utbl.update(DEXIE_CLOUD_SYNCER_ID, { receivedUntil });
                  }
                }
              }
              if (resyncNeeded) {
                yield this.db.cloud.sync({ purpose: "pull", wait: true });
              }
            }));
          } else {
            this.subscriber.next(msg);
          }
        } catch (e2) {
          this.subscriber.error(e2);
        }
      };
      try {
        let everConnected = false;
        yield new Promise((resolve, reject) => {
          ws.onopen = (event) => {
            console.debug("dexie-cloud WebSocket onopen");
            everConnected = true;
            resolve(null);
          };
          ws.onerror = (event) => {
            if (!everConnected) {
              const error = event.error || new Error("WebSocket Error");
              this.subscriber.error(error);
              this.webSocketStatus.next("error");
              reject(error);
            } else {
              this.reconnect();
            }
          };
        });
        this.subscriptions.add(this.messageProducer.subscribe((msg) => {
          var _a, _b;
          if (!this.closed) {
            if (msg.type === "ready" && this.webSocketStatus.value !== "connected") {
              this.webSocketStatus.next("connected");
            }
            console.debug("dexie-cloud WebSocket send", msg.type, msg);
            if (msg.type === "ready") {
              this.rev = msg.rev;
              (_a = this.ws) === null || _a === void 0 ? void 0 : _a.send(TSON.stringify(msg));
            } else {
              (_b = this.ws) === null || _b === void 0 ? void 0 : _b.send(encodeYMessage(msg));
            }
          }
        }));
        if (this.user.isLoggedIn && !isEagerSyncDisabled(this.db)) {
          this.subscriptions.add(createYClientUpdateObservable(this.db).subscribe(this.db.messageProducer));
        }
      } catch (error) {
        this.pauseUntil = new Date(Date.now() + FAIL_RETRY_WAIT_TIME);
      }
    });
  }
};
var InvalidLicenseError = class extends Error {
  constructor(license) {
    super(license === "expired" ? `License expired` : license === "deactivated" ? `User deactivated` : "Invalid license");
    this.name = "InvalidLicenseError";
    if (license) {
      this.license = license;
    }
  }
};
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function waitAndReconnectWhenUserDoesSomething(error) {
  return __awaiter2(this, void 0, void 0, function* () {
    console.error(`WebSocket observable: error but revive when user does some active thing...`, error);
    yield sleep(3e3);
    console.debug("waiting for someone to do something");
    yield firstValueFrom(userDoesSomething);
    console.debug("someone did something!");
  });
}
function connectWebSocket(db) {
  var _a;
  if (!((_a = db.cloud.options) === null || _a === void 0 ? void 0 : _a.databaseUrl)) {
    throw new Error(`No database URL to connect WebSocket to`);
  }
  const readyForChangesMessage = db.messageConsumer.readyToServe.pipe(
    filter((isReady) => isReady),
    // When consumer is ready for new messages, produce such a message to inform server about it
    switchMap(() => db.getPersistedSyncState()),
    // We need the info on which server revision we are at:
    filter((syncState) => syncState && syncState.serverRevision),
    // We wont send anything to server before inital sync has taken place
    switchMap((syncState) => __awaiter2(this, void 0, void 0, function* () {
      return {
        // Produce the message to trigger server to send us new messages to consume:
        type: "ready",
        rev: syncState.serverRevision,
        realmSetHash: yield computeRealmSetHash(syncState)
      };
    }))
  );
  const messageProducer = merge(readyForChangesMessage, db.messageProducer);
  function createObservable() {
    return db.cloud.persistedSyncState.pipe(
      filter((syncState) => syncState === null || syncState === void 0 ? void 0 : syncState.serverRevision),
      // Don't connect before there's no initial sync performed.
      take(1),
      // Don't continue waking up whenever syncState change
      switchMap((syncState) => db.cloud.currentUser.pipe(map((userLogin) => [userLogin, syncState]))),
      switchMap(([userLogin, syncState]) => {
        return userIsReallyActive.pipe(map((isActive) => [isActive ? userLogin : null, syncState]));
      }),
      switchMap(([userLogin, syncState]) => {
        if ((userLogin === null || userLogin === void 0 ? void 0 : userLogin.isLoggedIn) && !(syncState === null || syncState === void 0 ? void 0 : syncState.realms.includes(userLogin.userId))) {
          return db.cloud.persistedSyncState.pipe(filter((syncState2) => (syncState2 === null || syncState2 === void 0 ? void 0 : syncState2.realms.includes(userLogin.userId)) || false), take(1), map((syncState2) => [userLogin, syncState2]));
        }
        return new BehaviorSubject([userLogin, syncState]);
      }),
      switchMap((_a2) => __awaiter2(this, [_a2], void 0, function* ([userLogin, syncState]) {
        return [userLogin, yield computeRealmSetHash(syncState)];
      })),
      distinctUntilChanged(([prevUser, prevHash], [currUser, currHash]) => prevUser === currUser && prevHash === currHash),
      switchMap(([userLogin, realmSetHash]) => {
        var _a2;
        if (!((_a2 = db.cloud.persistedSyncState) === null || _a2 === void 0 ? void 0 : _a2.value)) {
          return createObservable();
        }
        if (userLogin) {
          return new WSObservable(db, db.cloud.persistedSyncState.value.serverRevision, db.cloud.persistedSyncState.value.yServerRevision, realmSetHash, db.cloud.persistedSyncState.value.clientIdentity, messageProducer, db.cloud.webSocketStatus, userLogin);
        } else {
          return from3([]);
        }
      }),
      catchError((error) => {
        if ((error === null || error === void 0 ? void 0 : error.name) === "TokenExpiredError") {
          console.debug("WebSocket observable: Token expired. Refreshing token...");
          return of(true).pipe(switchMap(() => __awaiter2(this, void 0, void 0, function* () {
            const user = yield db.getCurrentUser();
            const refreshedLogin = yield refreshAccessToken(db.cloud.options.databaseUrl, user);
            yield db.table("$logins").update(user.userId, {
              accessToken: refreshedLogin.accessToken,
              accessTokenExpiration: refreshedLogin.accessTokenExpiration,
              claims: refreshedLogin.claims,
              license: refreshedLogin.license,
              data: refreshedLogin.data
            });
          })), switchMap(() => createObservable()));
        } else {
          return throwError(() => error);
        }
      }),
      catchError((error) => {
        db.cloud.webSocketStatus.next("error");
        if (error instanceof InvalidLicenseError) {
          return throwError(() => error);
        }
        return from3(waitAndReconnectWhenUserDoesSomething(error)).pipe(switchMap(() => createObservable()));
      })
    );
  }
  return createObservable().subscribe({
    next: (msg) => {
      if (msg) {
        console.debug("WS got message", msg);
        db.messageConsumer.enqueue(msg);
      }
    },
    error: (error) => {
      console.error("WS got error", error);
    },
    complete: () => {
      console.debug("WS observable completed");
    }
  });
}
function isSyncNeeded(db) {
  return __awaiter2(this, void 0, void 0, function* () {
    var _a;
    return ((_a = db.cloud.options) === null || _a === void 0 ? void 0 : _a.databaseUrl) && db.cloud.schema ? yield sync(db, db.cloud.options, db.cloud.schema, { justCheckIfNeeded: true }) : false;
  });
}
var ongoingSyncs = /* @__PURE__ */ new WeakMap();
function syncIfPossible(db, cloudOptions, cloudSchema, options) {
  const ongoing = ongoingSyncs.get(db);
  if (ongoing) {
    if (ongoing.pull || (options === null || options === void 0 ? void 0 : options.purpose) === "push") {
      console.debug("syncIfPossible(): returning the ongoing sync promise.");
      return ongoing.promise;
    } else {
      let hasPullTakenPlace = false;
      const subscription = db.cloud.syncState.subscribe((syncState) => {
        if (syncState.phase === "pulling") {
          hasPullTakenPlace = true;
        }
      });
      return ongoing.promise.then(() => {
        subscription.unsubscribe();
      }).catch((error) => {
        subscription.unsubscribe();
        return Promise.reject(error);
      }).then(() => {
        if (!hasPullTakenPlace) {
          return syncIfPossible(db, cloudOptions, cloudSchema, options);
        }
      });
    }
  }
  const promise = _syncIfPossible();
  ongoingSyncs.set(db, { promise, pull: (options === null || options === void 0 ? void 0 : options.purpose) !== "push" });
  return promise;
  function _syncIfPossible() {
    return __awaiter2(this, void 0, void 0, function* () {
      try {
        yield checkSyncRateLimitDelay(db);
        yield performGuardedJob(db, CURRENT_SYNC_WORKER, () => sync(db, cloudOptions, cloudSchema, options));
        ongoingSyncs.delete(db);
        console.debug("Done sync");
      } catch (error) {
        ongoingSyncs.delete(db);
        console.error(`Failed to sync client changes`, error);
        throw error;
      }
    });
  }
}
var SECONDS = 1e3;
function LocalSyncWorker(db, cloudOptions, cloudSchema) {
  let localSyncEventSubscription = null;
  let cancelToken = { cancelled: false };
  let nextRetryTime = 0;
  let syncStartTime = 0;
  function syncAndRetry(retryNum = 1) {
    setTimeout(() => {
      const purpose = pullSignalled ? "pull" : "push";
      syncStartTime = Date.now();
      syncIfPossible(db, cloudOptions, cloudSchema, {
        cancelToken,
        retryImmediatelyOnFetchError: true,
        // workaround for "net::ERR_NETWORK_CHANGED" in chrome.
        purpose
      }).then(() => {
        if (cancelToken.cancelled) {
          stop();
        } else {
          if (pullSignalled || pushSignalled) {
            pullSignalled = false;
            pushSignalled = false;
            return syncAndRetry();
          }
        }
        ongoingSync = false;
        nextRetryTime = 0;
        syncStartTime = 0;
      }).catch((error) => {
        console.error("error in syncIfPossible()", error);
        if (cancelToken.cancelled) {
          stop();
          ongoingSync = false;
          nextRetryTime = 0;
          syncStartTime = 0;
        } else if (retryNum < 5) {
          const retryIn = [0, 20, 40, 300, 900][retryNum] * SECONDS;
          nextRetryTime = Date.now() + retryIn;
          syncStartTime = 0;
          setTimeout(() => syncAndRetry(retryNum + 1), retryIn);
        } else {
          ongoingSync = false;
          nextRetryTime = 0;
          syncStartTime = 0;
        }
      });
    }, 0);
  }
  let pullSignalled = false;
  let pushSignalled = false;
  let ongoingSync = false;
  const consumer = (purpose) => {
    if (cancelToken.cancelled)
      return;
    if (purpose === "pull") {
      pullSignalled = true;
    }
    if (purpose === "push") {
      pushSignalled = true;
    }
    if (ongoingSync) {
      if (nextRetryTime) {
        console.debug(`Sync is paused until ${new Date(nextRetryTime).toISOString()} due to error in last sync attempt`);
      } else if (syncStartTime > 0 && Date.now() - syncStartTime > 20 * SECONDS) {
        console.debug(`An existing sync operation is taking more than 20 seconds. Will resync when done.`);
      }
      return;
    }
    ongoingSync = true;
    syncAndRetry();
  };
  const start = () => {
    console.debug("Starting LocalSyncWorker", db.localSyncEvent["id"]);
    localSyncEventSubscription = db.localSyncEvent.subscribe(({ purpose }) => {
      consumer(purpose || "pull");
    });
  };
  const stop = () => {
    console.debug("Stopping LocalSyncWorker");
    cancelToken.cancelled = true;
    if (localSyncEventSubscription)
      localSyncEventSubscription.unsubscribe();
  };
  return {
    start,
    stop
  };
}
function updateSchemaFromOptions(schema, options) {
  if (schema && options) {
    if (options.unsyncedTables) {
      for (const tableName of options.unsyncedTables) {
        if (schema[tableName]) {
          schema[tableName].markedForSync = false;
        }
      }
    }
  }
}
function verifySchema(db) {
  var _a, _b;
  for (const table of db.tables) {
    if ((_b = (_a = db.cloud.schema) === null || _a === void 0 ? void 0 : _a[table.name]) === null || _b === void 0 ? void 0 : _b.markedForSync) {
      if (table.schema.primKey.auto) {
        throw new import_wrapper_default.SchemaError(`Table ${table.name} is both autoIncremented and synced. Use db.cloud.configure({unsyncedTables: [${JSON.stringify(table.name)}]}) to blacklist it from sync`);
      }
      if (!table.schema.primKey.keyPath) {
        throw new import_wrapper_default.SchemaError(`Table ${table.name} cannot be both synced and outbound. Use db.cloud.configure({unsyncedTables: [${JSON.stringify(table.name)}]}) to blacklist it from sync`);
      }
    }
  }
}
var n;
var l$1;
var u$1;
var i$1;
var r$1;
var o$1;
var e$1;
var f$1;
var c$1;
var s$1;
var a$1;
var p$1 = {};
var v$1 = [];
var y = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var w$1 = Array.isArray;
function d$1(n2, l2) {
  for (var u2 in l2) n2[u2] = l2[u2];
  return n2;
}
function g(n2) {
  n2 && n2.parentNode && n2.parentNode.removeChild(n2);
}
function _$1(l2, u2, t2) {
  var i2, r2, o2, e2 = {};
  for (o2 in u2) "key" == o2 ? i2 = u2[o2] : "ref" == o2 ? r2 = u2[o2] : e2[o2] = u2[o2];
  if (arguments.length > 2 && (e2.children = arguments.length > 3 ? n.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps) for (o2 in l2.defaultProps) void 0 === e2[o2] && (e2[o2] = l2.defaultProps[o2]);
  return m$1(l2, e2, i2, r2, null);
}
function m$1(n2, t2, i2, r2, o2) {
  var e2 = { type: n2, props: t2, key: i2, ref: r2, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o2 ? ++u$1 : o2, __i: -1, __u: 0 };
  return null == o2 && null != l$1.vnode && l$1.vnode(e2), e2;
}
function k$1(n2) {
  return n2.children;
}
function x(n2, l2) {
  this.props = n2, this.context = l2;
}
function S(n2, l2) {
  if (null == l2) return n2.__ ? S(n2.__, n2.__i + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) return u2.__e;
  return "function" == typeof n2.type ? S(n2) : null;
}
function C$1(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++) if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
      n2.__e = n2.__c.base = u2.__e;
      break;
    }
    return C$1(n2);
  }
}
function M(n2) {
  (!n2.__d && (n2.__d = true) && i$1.push(n2) && !$2.__r++ || r$1 != l$1.debounceRendering) && ((r$1 = l$1.debounceRendering) || o$1)($2);
}
function $2() {
  for (var n2, u2, t2, r2, o2, f2, c2, s2 = 1; i$1.length; ) i$1.length > s2 && i$1.sort(e$1), n2 = i$1.shift(), s2 = i$1.length, n2.__d && (t2 = void 0, r2 = void 0, o2 = (r2 = (u2 = n2).__v).__e, f2 = [], c2 = [], u2.__P && ((t2 = d$1({}, r2)).__v = r2.__v + 1, l$1.vnode && l$1.vnode(t2), O(u2.__P, t2, r2, u2.__n, u2.__P.namespaceURI, 32 & r2.__u ? [o2] : null, f2, null == o2 ? S(r2) : o2, !!(32 & r2.__u), c2), t2.__v = r2.__v, t2.__.__k[t2.__i] = t2, N(f2, t2, c2), r2.__e = r2.__ = null, t2.__e != o2 && C$1(t2)));
  $2.__r = 0;
}
function I(n2, l2, u2, t2, i2, r2, o2, e2, f2, c2, s2) {
  var a2, h2, y2, w2, d2, g2, _2, m2 = t2 && t2.__k || v$1, b = l2.length;
  for (f2 = P(u2, l2, m2, f2, b), a2 = 0; a2 < b; a2++) null != (y2 = u2.__k[a2]) && (h2 = -1 == y2.__i ? p$1 : m2[y2.__i] || p$1, y2.__i = a2, g2 = O(n2, y2, h2, i2, r2, o2, e2, f2, c2, s2), w2 = y2.__e, y2.ref && h2.ref != y2.ref && (h2.ref && B$1(h2.ref, null, y2), s2.push(y2.ref, y2.__c || w2, y2)), null == d2 && null != w2 && (d2 = w2), (_2 = !!(4 & y2.__u)) || h2.__k === y2.__k ? f2 = A$1(y2, f2, n2, _2) : "function" == typeof y2.type && void 0 !== g2 ? f2 = g2 : w2 && (f2 = w2.nextSibling), y2.__u &= -7);
  return u2.__e = d2, f2;
}
function P(n2, l2, u2, t2, i2) {
  var r2, o2, e2, f2, c2, s2 = u2.length, a2 = s2, h2 = 0;
  for (n2.__k = new Array(i2), r2 = 0; r2 < i2; r2++) null != (o2 = l2[r2]) && "boolean" != typeof o2 && "function" != typeof o2 ? ("string" == typeof o2 || "number" == typeof o2 || "bigint" == typeof o2 || o2.constructor == String ? o2 = n2.__k[r2] = m$1(null, o2, null, null, null) : w$1(o2) ? o2 = n2.__k[r2] = m$1(k$1, { children: o2 }, null, null, null) : null == o2.constructor && o2.__b > 0 ? o2 = n2.__k[r2] = m$1(o2.type, o2.props, o2.key, o2.ref ? o2.ref : null, o2.__v) : n2.__k[r2] = o2, f2 = r2 + h2, o2.__ = n2, o2.__b = n2.__b + 1, -1 != (c2 = o2.__i = L(o2, u2, f2, a2)) && (a2--, (e2 = u2[c2]) && (e2.__u |= 2)), null == e2 || null == e2.__v ? (-1 == c2 && (i2 > s2 ? h2-- : i2 < s2 && h2++), "function" != typeof o2.type && (o2.__u |= 4)) : c2 != f2 && (c2 == f2 - 1 ? h2-- : c2 == f2 + 1 ? h2++ : (c2 > f2 ? h2-- : h2++, o2.__u |= 4))) : n2.__k[r2] = null;
  if (a2) for (r2 = 0; r2 < s2; r2++) null != (e2 = u2[r2]) && 0 == (2 & e2.__u) && (e2.__e == t2 && (t2 = S(e2)), D$1(e2, e2));
  return t2;
}
function A$1(n2, l2, u2, t2) {
  var i2, r2;
  if ("function" == typeof n2.type) {
    for (i2 = n2.__k, r2 = 0; i2 && r2 < i2.length; r2++) i2[r2] && (i2[r2].__ = n2, l2 = A$1(i2[r2], l2, u2, t2));
    return l2;
  }
  n2.__e != l2 && (t2 && (l2 && n2.type && !l2.parentNode && (l2 = S(n2)), u2.insertBefore(n2.__e, l2 || null)), l2 = n2.__e);
  do {
    l2 = l2 && l2.nextSibling;
  } while (null != l2 && 8 == l2.nodeType);
  return l2;
}
function L(n2, l2, u2, t2) {
  var i2, r2, o2, e2 = n2.key, f2 = n2.type, c2 = l2[u2], s2 = null != c2 && 0 == (2 & c2.__u);
  if (null === c2 && null == e2 || s2 && e2 == c2.key && f2 == c2.type) return u2;
  if (t2 > (s2 ? 1 : 0)) {
    for (i2 = u2 - 1, r2 = u2 + 1; i2 >= 0 || r2 < l2.length; ) if (null != (c2 = l2[o2 = i2 >= 0 ? i2-- : r2++]) && 0 == (2 & c2.__u) && e2 == c2.key && f2 == c2.type) return o2;
  }
  return -1;
}
function T$1(n2, l2, u2) {
  "-" == l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || y.test(l2) ? u2 : u2 + "px";
}
function j$1(n2, l2, u2, t2, i2) {
  var r2, o2;
  n: if ("style" == l2) if ("string" == typeof u2) n2.style.cssText = u2;
  else {
    if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2) for (l2 in t2) u2 && l2 in u2 || T$1(n2.style, l2, "");
    if (u2) for (l2 in u2) t2 && u2[l2] == t2[l2] || T$1(n2.style, l2, u2[l2]);
  }
  else if ("o" == l2[0] && "n" == l2[1]) r2 = l2 != (l2 = l2.replace(f$1, "$1")), o2 = l2.toLowerCase(), l2 = o2 in n2 || "onFocusOut" == l2 || "onFocusIn" == l2 ? o2.slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + r2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = c$1, n2.addEventListener(l2, r2 ? a$1 : s$1, r2)) : n2.removeEventListener(l2, r2 ? a$1 : s$1, r2);
  else {
    if ("http://www.w3.org/2000/svg" == i2) l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l2 && "height" != l2 && "href" != l2 && "list" != l2 && "form" != l2 && "tabIndex" != l2 && "download" != l2 && "rowSpan" != l2 && "colSpan" != l2 && "role" != l2 && "popover" != l2 && l2 in n2) try {
      n2[l2] = null == u2 ? "" : u2;
      break n;
    } catch (n3) {
    }
    "function" == typeof u2 || (null == u2 || false === u2 && "-" != l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, "popover" == l2 && 1 == u2 ? "" : u2));
  }
}
function F(n2) {
  return function(u2) {
    if (this.l) {
      var t2 = this.l[u2.type + n2];
      if (null == u2.t) u2.t = c$1++;
      else if (u2.t < t2.u) return;
      return t2(l$1.event ? l$1.event(u2) : u2);
    }
  };
}
function O(n2, u2, t2, i2, r2, o2, e2, f2, c2, s2) {
  var a2, h2, p2, v2, y2, _2, m2, b, S2, C2, M2, $3, P2, A2, H, L2, T2, j2 = u2.type;
  if (null != u2.constructor) return null;
  128 & t2.__u && (c2 = !!(32 & t2.__u), o2 = [f2 = u2.__e = t2.__e]), (a2 = l$1.__b) && a2(u2);
  n: if ("function" == typeof j2) try {
    if (b = u2.props, S2 = "prototype" in j2 && j2.prototype.render, C2 = (a2 = j2.contextType) && i2[a2.__c], M2 = a2 ? C2 ? C2.props.value : a2.__ : i2, t2.__c ? m2 = (h2 = u2.__c = t2.__c).__ = h2.__E : (S2 ? u2.__c = h2 = new j2(b, M2) : (u2.__c = h2 = new x(b, M2), h2.constructor = j2, h2.render = E), C2 && C2.sub(h2), h2.state || (h2.state = {}), h2.__n = i2, p2 = h2.__d = true, h2.__h = [], h2._sb = []), S2 && null == h2.__s && (h2.__s = h2.state), S2 && null != j2.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = d$1({}, h2.__s)), d$1(h2.__s, j2.getDerivedStateFromProps(b, h2.__s))), v2 = h2.props, y2 = h2.state, h2.__v = u2, p2) S2 && null == j2.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), S2 && null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
    else {
      if (S2 && null == j2.getDerivedStateFromProps && b !== v2 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(b, M2), u2.__v == t2.__v || !h2.__e && null != h2.shouldComponentUpdate && false === h2.shouldComponentUpdate(b, h2.__s, M2)) {
        for (u2.__v != t2.__v && (h2.props = b, h2.state = h2.__s, h2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.some(function(n3) {
          n3 && (n3.__ = u2);
        }), $3 = 0; $3 < h2._sb.length; $3++) h2.__h.push(h2._sb[$3]);
        h2._sb = [], h2.__h.length && e2.push(h2);
        break n;
      }
      null != h2.componentWillUpdate && h2.componentWillUpdate(b, h2.__s, M2), S2 && null != h2.componentDidUpdate && h2.__h.push(function() {
        h2.componentDidUpdate(v2, y2, _2);
      });
    }
    if (h2.context = M2, h2.props = b, h2.__P = n2, h2.__e = false, P2 = l$1.__r, A2 = 0, S2) {
      for (h2.state = h2.__s, h2.__d = false, P2 && P2(u2), a2 = h2.render(h2.props, h2.state, h2.context), H = 0; H < h2._sb.length; H++) h2.__h.push(h2._sb[H]);
      h2._sb = [];
    } else do {
      h2.__d = false, P2 && P2(u2), a2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s;
    } while (h2.__d && ++A2 < 25);
    h2.state = h2.__s, null != h2.getChildContext && (i2 = d$1(d$1({}, i2), h2.getChildContext())), S2 && !p2 && null != h2.getSnapshotBeforeUpdate && (_2 = h2.getSnapshotBeforeUpdate(v2, y2)), L2 = a2, null != a2 && a2.type === k$1 && null == a2.key && (L2 = V(a2.props.children)), f2 = I(n2, w$1(L2) ? L2 : [L2], u2, t2, i2, r2, o2, e2, f2, c2, s2), h2.base = u2.__e, u2.__u &= -161, h2.__h.length && e2.push(h2), m2 && (h2.__E = h2.__ = null);
  } catch (n3) {
    if (u2.__v = null, c2 || null != o2) if (n3.then) {
      for (u2.__u |= c2 ? 160 : 128; f2 && 8 == f2.nodeType && f2.nextSibling; ) f2 = f2.nextSibling;
      o2[o2.indexOf(f2)] = null, u2.__e = f2;
    } else {
      for (T2 = o2.length; T2--; ) g(o2[T2]);
      z$1(u2);
    }
    else u2.__e = t2.__e, u2.__k = t2.__k, n3.then || z$1(u2);
    l$1.__e(n3, u2, t2);
  }
  else null == o2 && u2.__v == t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : f2 = u2.__e = q(t2.__e, u2, t2, i2, r2, o2, e2, c2, s2);
  return (a2 = l$1.diffed) && a2(u2), 128 & u2.__u ? void 0 : f2;
}
function z$1(n2) {
  n2 && n2.__c && (n2.__c.__e = true), n2 && n2.__k && n2.__k.forEach(z$1);
}
function N(n2, u2, t2) {
  for (var i2 = 0; i2 < t2.length; i2++) B$1(t2[i2], t2[++i2], t2[++i2]);
  l$1.__c && l$1.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l$1.__e(n3, u3.__v);
    }
  });
}
function V(n2) {
  return "object" != typeof n2 || null == n2 || n2.__b && n2.__b > 0 ? n2 : w$1(n2) ? n2.map(V) : d$1({}, n2);
}
function q(u2, t2, i2, r2, o2, e2, f2, c2, s2) {
  var a2, h2, v2, y2, d2, _2, m2, b = i2.props || p$1, k2 = t2.props, x2 = t2.type;
  if ("svg" == x2 ? o2 = "http://www.w3.org/2000/svg" : "math" == x2 ? o2 = "http://www.w3.org/1998/Math/MathML" : o2 || (o2 = "http://www.w3.org/1999/xhtml"), null != e2) {
    for (a2 = 0; a2 < e2.length; a2++) if ((d2 = e2[a2]) && "setAttribute" in d2 == !!x2 && (x2 ? d2.localName == x2 : 3 == d2.nodeType)) {
      u2 = d2, e2[a2] = null;
      break;
    }
  }
  if (null == u2) {
    if (null == x2) return document.createTextNode(k2);
    u2 = document.createElementNS(o2, x2, k2.is && k2), c2 && (l$1.__m && l$1.__m(t2, e2), c2 = false), e2 = null;
  }
  if (null == x2) b === k2 || c2 && u2.data == k2 || (u2.data = k2);
  else {
    if (e2 = e2 && n.call(u2.childNodes), !c2 && null != e2) for (b = {}, a2 = 0; a2 < u2.attributes.length; a2++) b[(d2 = u2.attributes[a2]).name] = d2.value;
    for (a2 in b) if (d2 = b[a2], "children" == a2) ;
    else if ("dangerouslySetInnerHTML" == a2) v2 = d2;
    else if (!(a2 in k2)) {
      if ("value" == a2 && "defaultValue" in k2 || "checked" == a2 && "defaultChecked" in k2) continue;
      j$1(u2, a2, null, d2, o2);
    }
    for (a2 in k2) d2 = k2[a2], "children" == a2 ? y2 = d2 : "dangerouslySetInnerHTML" == a2 ? h2 = d2 : "value" == a2 ? _2 = d2 : "checked" == a2 ? m2 = d2 : c2 && "function" != typeof d2 || b[a2] === d2 || j$1(u2, a2, d2, b[a2], o2);
    if (h2) c2 || v2 && (h2.__html == v2.__html || h2.__html == u2.innerHTML) || (u2.innerHTML = h2.__html), t2.__k = [];
    else if (v2 && (u2.innerHTML = ""), I("template" == t2.type ? u2.content : u2, w$1(y2) ? y2 : [y2], t2, i2, r2, "foreignObject" == x2 ? "http://www.w3.org/1999/xhtml" : o2, e2, f2, e2 ? e2[0] : i2.__k && S(i2, 0), c2, s2), null != e2) for (a2 = e2.length; a2--; ) g(e2[a2]);
    c2 || (a2 = "value", "progress" == x2 && null == _2 ? u2.removeAttribute("value") : null != _2 && (_2 !== u2[a2] || "progress" == x2 && !_2 || "option" == x2 && _2 != b[a2]) && j$1(u2, a2, _2, b[a2], o2), a2 = "checked", null != m2 && m2 != u2[a2] && j$1(u2, a2, m2, b[a2], o2));
  }
  return u2;
}
function B$1(n2, u2, t2) {
  try {
    if ("function" == typeof n2) {
      var i2 = "function" == typeof n2.__u;
      i2 && n2.__u(), i2 && null == u2 || (n2.__u = n2(u2));
    } else n2.current = u2;
  } catch (n3) {
    l$1.__e(n3, t2);
  }
}
function D$1(n2, u2, t2) {
  var i2, r2;
  if (l$1.unmount && l$1.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current != n2.__e || B$1(i2, null, u2)), null != (i2 = n2.__c)) {
    if (i2.componentWillUnmount) try {
      i2.componentWillUnmount();
    } catch (n3) {
      l$1.__e(n3, u2);
    }
    i2.base = i2.__P = null;
  }
  if (i2 = n2.__k) for (r2 = 0; r2 < i2.length; r2++) i2[r2] && D$1(i2[r2], u2, t2 || "function" != typeof n2.type);
  t2 || g(n2.__e), n2.__c = n2.__ = n2.__e = void 0;
}
function E(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function G(u2, t2, i2) {
  var r2, o2, e2, f2;
  t2 == document && (t2 = document.documentElement), l$1.__ && l$1.__(u2, t2), o2 = (r2 = false) ? null : t2.__k, e2 = [], f2 = [], O(t2, u2 = t2.__k = _$1(k$1, null, [u2]), o2 || p$1, p$1, t2.namespaceURI, o2 ? null : t2.firstChild ? n.call(t2.childNodes) : null, e2, o2 ? o2.__e : t2.firstChild, r2, f2), N(e2, u2, f2);
}
n = v$1.slice, l$1 = { __e: function(n2, l2, u2, t2) {
  for (var i2, r2, o2; l2 = l2.__; ) if ((i2 = l2.__c) && !i2.__) try {
    if ((r2 = i2.constructor) && null != r2.getDerivedStateFromError && (i2.setState(r2.getDerivedStateFromError(n2)), o2 = i2.__d), null != i2.componentDidCatch && (i2.componentDidCatch(n2, t2 || {}), o2 = i2.__d), o2) return i2.__E = i2;
  } catch (l3) {
    n2 = l3;
  }
  throw n2;
} }, u$1 = 0, x.prototype.setState = function(n2, l2) {
  var u2;
  u2 = null != this.__s && this.__s != this.state ? this.__s : this.__s = d$1({}, this.state), "function" == typeof n2 && (n2 = n2(d$1({}, u2), this.props)), n2 && d$1(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), M(this));
}, x.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), M(this));
}, x.prototype.render = k$1, i$1 = [], o$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e$1 = function(n2, l2) {
  return n2.__v.__b - l2.__v.__b;
}, $2.__r = 0, f$1 = /(PointerCapture)$|Capture$/i, c$1 = 0, s$1 = F(false), a$1 = F(true);
var Styles = {
  Alert: {
    error: {
      color: "red",
      fontWeight: "bold"
    },
    warning: {
      color: "#f80",
      fontWeight: "bold"
    },
    info: {
      color: "black"
    }
  },
  Darken: {
    position: "fixed",
    top: 0,
    left: 0,
    opacity: 0.5,
    backgroundColor: "#000",
    width: "100vw",
    height: "100vh",
    zIndex: 150,
    webkitBackdropFilter: "blur(2px)",
    backdropFilter: "blur(2px)"
  },
  DialogOuter: {
    position: "fixed",
    top: 0,
    left: 0,
    width: "100vw",
    height: "100vh",
    zIndex: 150,
    alignItems: "center",
    display: "flex",
    justifyContent: "center",
    padding: "16px",
    boxSizing: "border-box"
  },
  DialogInner: {
    position: "relative",
    color: "#222",
    backgroundColor: "#fff",
    padding: "24px",
    marginBottom: "2em",
    maxWidth: "400px",
    width: "100%",
    maxHeight: "90%",
    overflowY: "auto",
    border: "3px solid #3d3d5d",
    borderRadius: "8px",
    boxShadow: "0 0 80px 10px #666",
    fontFamily: "sans-serif",
    boxSizing: "border-box"
  },
  Input: {
    height: "35px",
    width: "100%",
    maxWidth: "100%",
    borderColor: "#ccf4",
    outline: "none",
    fontSize: "16px",
    padding: "8px",
    boxSizing: "border-box",
    backgroundColor: "#f9f9f9",
    borderRadius: "4px",
    border: "1px solid #ccc",
    marginTop: "6px",
    fontFamily: "inherit"
  },
  Button: {
    padding: "10px 20px",
    margin: "0 4px",
    border: "1px solid #d1d5db",
    borderRadius: "6px",
    backgroundColor: "#ffffff",
    cursor: "pointer",
    fontSize: "14px",
    fontWeight: "500",
    color: "#374151",
    transition: "all 0.2s ease"
  },
  PrimaryButton: {
    padding: "10px 20px",
    margin: "0 4px",
    border: "1px solid #3b82f6",
    borderRadius: "6px",
    backgroundColor: "#3b82f6",
    color: "white",
    cursor: "pointer",
    fontSize: "14px",
    fontWeight: "500",
    transition: "all 0.2s ease"
  },
  ButtonsDiv: {
    display: "flex",
    justifyContent: "flex-end",
    gap: "12px",
    marginTop: "24px",
    paddingTop: "20px"
  },
  Label: {
    display: "block",
    marginBottom: "12px",
    fontSize: "14px",
    fontWeight: "500",
    color: "#333"
  },
  WindowHeader: {
    margin: "0 0 20px 0",
    fontSize: "18px",
    fontWeight: "600",
    color: "#333",
    borderBottom: "1px solid #eee",
    paddingBottom: "10px"
  }
};
function Dialog({ children, className }) {
  return _$1(
    "div",
    { className: `dexie-dialog ${className || ""}` },
    _$1("div", { style: Styles.Darken }),
    _$1(
      "div",
      { style: Styles.DialogOuter },
      _$1("div", { style: Styles.DialogInner }, children)
    )
  );
}
var t;
var r;
var u;
var i;
var o = 0;
var f = [];
var c = l$1;
var e = c.__b;
var a = c.__r;
var v = c.diffed;
var l = c.__c;
var m = c.unmount;
var s = c.__;
function p(n2, t2) {
  c.__h && c.__h(r, n2, o || t2), o = 0;
  var u2 = r.__H || (r.__H = { __: [], __h: [] });
  return n2 >= u2.__.length && u2.__.push({}), u2.__[n2];
}
function d(n2) {
  return o = 1, h(D, n2);
}
function h(n2, u2, i2) {
  var o2 = p(t++, 2);
  if (o2.t = n2, !o2.__c && (o2.__ = [D(void 0, u2), function(n3) {
    var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n3);
    t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
  }], o2.__c = r, !r.__f)) {
    var f2 = function(n3, t2, r2) {
      if (!o2.__c.__H) return true;
      var u3 = o2.__c.__H.__.filter(function(n4) {
        return !!n4.__c;
      });
      if (u3.every(function(n4) {
        return !n4.__N;
      })) return !c2 || c2.call(this, n3, t2, r2);
      var i3 = o2.__c.props !== n3;
      return u3.forEach(function(n4) {
        if (n4.__N) {
          var t3 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t3 !== n4.__[0] && (i3 = true);
        }
      }), c2 && c2.call(this, n3, t2, r2) || i3;
    };
    r.__f = true;
    var c2 = r.shouldComponentUpdate, e2 = r.componentWillUpdate;
    r.componentWillUpdate = function(n3, t2, r2) {
      if (this.__e) {
        var u3 = c2;
        c2 = void 0, f2(n3, t2, r2), c2 = u3;
      }
      e2 && e2.call(this, n3, t2, r2);
    }, r.shouldComponentUpdate = f2;
  }
  return o2.__N || o2.__;
}
function _(n2, u2) {
  var i2 = p(t++, 4);
  !c.__s && C(i2.__H, u2) && (i2.__ = n2, i2.u = u2, r.__h.push(i2));
}
function A(n2) {
  return o = 5, T(function() {
    return { current: n2 };
  }, []);
}
function T(n2, r2) {
  var u2 = p(t++, 7);
  return C(u2.__H, r2) && (u2.__ = n2(), u2.__H = r2, u2.__h = n2), u2.__;
}
function j() {
  for (var n2; n2 = f.shift(); ) if (n2.__P && n2.__H) try {
    n2.__H.__h.forEach(z), n2.__H.__h.forEach(B), n2.__H.__h = [];
  } catch (t2) {
    n2.__H.__h = [], c.__e(t2, n2.__v);
  }
}
c.__b = function(n2) {
  r = null, e && e(n2);
}, c.__ = function(n2, t2) {
  n2 && t2.__k && t2.__k.__m && (n2.__m = t2.__k.__m), s && s(n2, t2);
}, c.__r = function(n2) {
  a && a(n2), t = 0;
  var i2 = (r = n2.__c).__H;
  i2 && (u === r ? (i2.__h = [], r.__h = [], i2.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.u = n3.__N = void 0;
  })) : (i2.__h.forEach(z), i2.__h.forEach(B), i2.__h = [], t = 0)), u = r;
}, c.diffed = function(n2) {
  v && v(n2);
  var t2 = n2.__c;
  t2 && t2.__H && (t2.__H.__h.length && (1 !== f.push(t2) && i === c.requestAnimationFrame || ((i = c.requestAnimationFrame) || w)(j)), t2.__H.__.forEach(function(n3) {
    n3.u && (n3.__H = n3.u), n3.u = void 0;
  })), u = r = null;
}, c.__c = function(n2, t2) {
  t2.some(function(n3) {
    try {
      n3.__h.forEach(z), n3.__h = n3.__h.filter(function(n4) {
        return !n4.__ || B(n4);
      });
    } catch (r2) {
      t2.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), t2 = [], c.__e(r2, n3.__v);
    }
  }), l && l(n2, t2);
}, c.unmount = function(n2) {
  m && m(n2);
  var t2, r2 = n2.__c;
  r2 && r2.__H && (r2.__H.__.forEach(function(n3) {
    try {
      z(n3);
    } catch (n4) {
      t2 = n4;
    }
  }), r2.__H = void 0, t2 && c.__e(t2, r2.__v));
};
var k = "function" == typeof requestAnimationFrame;
function w(n2) {
  var t2, r2 = function() {
    clearTimeout(u2), k && cancelAnimationFrame(t2), setTimeout(n2);
  }, u2 = setTimeout(r2, 35);
  k && (t2 = requestAnimationFrame(r2));
}
function z(n2) {
  var t2 = r, u2 = n2.__c;
  "function" == typeof u2 && (n2.__c = void 0, u2()), r = t2;
}
function B(n2) {
  var t2 = r;
  n2.__c = n2.__(), r = t2;
}
function C(n2, t2) {
  return !n2 || n2.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n2[r2];
  });
}
function D(n2, t2) {
  return "function" == typeof t2 ? t2(n2) : t2;
}
function resolveText({ message, messageCode, messageParams }) {
  return message.replace(/\{\w+\}/ig, (n2) => messageParams[n2.substring(1, n2.length - 1)]);
}
var OTP_LENGTH = 8;
function LoginDialog({ title, type, alerts, fields, submitLabel, cancelLabel, onCancel, onSubmit }) {
  const [params2, setParams] = d({});
  const firstFieldRef = A(null);
  _(() => {
    var _a;
    return (_a = firstFieldRef.current) === null || _a === void 0 ? void 0 : _a.focus();
  }, []);
  return _$1(
    Dialog,
    { className: "dxc-login-dlg" },
    _$1(
      k$1,
      null,
      _$1("h3", { style: Styles.WindowHeader }, title),
      alerts.map((alert) => _$1("p", { style: Styles.Alert[alert.type] }, resolveText(alert))),
      _$1("form", { onSubmit: (ev) => {
        ev.preventDefault();
        onSubmit(params2);
      } }, Object.entries(fields).map(([fieldName, { type: type2, label, placeholder }], idx) => _$1(
        "label",
        { style: Styles.Label, key: idx },
        label ? `${label}: ` : "",
        _$1("input", { ref: idx === 0 ? firstFieldRef : void 0, type: type2, name: fieldName, autoComplete: "on", style: Styles.Input, autoFocus: true, placeholder, value: params2[fieldName] || "", onInput: (ev) => {
          var _a;
          const value = valueTransformer(type2, (_a = ev.target) === null || _a === void 0 ? void 0 : _a["value"]);
          let updatedParams = Object.assign(Object.assign({}, params2), { [fieldName]: value });
          setParams(updatedParams);
          if (type2 === "otp" && (value === null || value === void 0 ? void 0 : value.trim().length) === OTP_LENGTH) {
            onSubmit(updatedParams);
          }
        } })
      )))
    ),
    _$1(
      "div",
      { style: Styles.ButtonsDiv },
      _$1(
        k$1,
        null,
        _$1("button", { type: "submit", style: Styles.PrimaryButton, onClick: () => onSubmit(params2) }, submitLabel),
        cancelLabel && _$1("button", { style: Styles.Button, onClick: onCancel }, cancelLabel)
      )
    )
  );
}
function valueTransformer(type, value) {
  switch (type) {
    case "email":
      return value.toLowerCase();
    case "otp":
      return value.toUpperCase();
    default:
      return value;
  }
}
var LoginGui = class extends x {
  constructor(props) {
    super(props);
    this.observer = (userInteraction) => this.setState({ userInteraction });
    this.state = { userInteraction: void 0 };
  }
  componentDidMount() {
    this.subscription = from3(this.props.db.cloud.userInteraction).subscribe(this.observer);
  }
  componentWillUnmount() {
    if (this.subscription) {
      this.subscription.unsubscribe();
      delete this.subscription;
    }
  }
  render(props, { userInteraction }) {
    if (!userInteraction)
      return null;
    return _$1(LoginDialog, Object.assign({}, userInteraction));
  }
};
function setupDefaultGUI(db) {
  let closed = false;
  const el = document.createElement("div");
  if (document.body) {
    document.body.appendChild(el);
    G(_$1(LoginGui, { db: db.vip }), el);
  } else {
    addEventListener("DOMContentLoaded", () => {
      if (!closed) {
        document.body.appendChild(el);
        G(_$1(LoginGui, { db: db.vip }), el);
      }
    });
  }
  return {
    unsubscribe() {
      try {
        el.remove();
      } catch (_a) {
      }
      closed = true;
    },
    get closed() {
      return closed;
    }
  };
}
function associate(factory) {
  const wm3 = /* @__PURE__ */ new WeakMap();
  return (x2) => {
    let rv = wm3.get(x2);
    if (!rv) {
      rv = factory(x2);
      wm3.set(x2, rv);
    }
    return rv;
  };
}
var getCurrentUserEmitter = associate((db) => new BehaviorSubject(UNAUTHORIZED_USER));
function computeSyncState(db) {
  let _prevStatus = db.cloud.webSocketStatus.value;
  const lazyWebSocketStatus = db.cloud.webSocketStatus.pipe(switchMap((status) => {
    const prevStatus = _prevStatus;
    _prevStatus = status;
    const rv = of(status);
    switch (status) {
      // A normal scenario is that the WS reconnects and falls shortly in disconnected-->connection-->connected.
      // Don't distract user with this unless these things take more time than normal:
      // Only show disconnected if disconnected more than 500ms, or if we can
      // see that the user is indeed not active.
      case "disconnected":
        return userIsActive.value ? rv.pipe(debounceTime(500)) : rv;
      // Only show connecting if previous state was 'not-started' or 'error', or if
      // the time it takes to connect goes beyond 4 seconds.
      case "connecting":
        return prevStatus === "not-started" || prevStatus === "error" ? rv : rv.pipe(debounceTime(4e3));
      default:
        return rv;
    }
  }));
  return combineLatest([
    lazyWebSocketStatus,
    db.syncStateChangedEvent.pipe(startWith({ phase: "initial" })),
    getCurrentUserEmitter(db.dx._novip),
    userIsReallyActive
  ]).pipe(map(([status, syncState, user, userIsActive2]) => {
    var _a;
    if (((_a = user.license) === null || _a === void 0 ? void 0 : _a.status) && user.license.status !== "ok") {
      return {
        phase: "offline",
        status: "offline",
        license: user.license.status
      };
    }
    let { phase, error, progress } = syncState;
    let adjustedStatus = status;
    if (phase === "error") {
      adjustedStatus = "error";
    }
    if (status === "not-started") {
      if (phase === "pushing" || phase === "pulling") {
        adjustedStatus = "connecting";
      }
    }
    const previousPhase = db.cloud.syncState.value.phase;
    if (previousPhase === "error" && (syncState.phase === "pushing" || syncState.phase === "pulling")) {
      adjustedStatus = "connecting";
    }
    if (!userIsActive2) {
      adjustedStatus = "disconnected";
    }
    const retState = {
      phase,
      error,
      progress,
      status: isOnline ? adjustedStatus : "offline",
      license: "ok"
    };
    return retState;
  }));
}
function createSharedValueObservable(o2, defaultValue) {
  let currentValue = defaultValue;
  let shared = from3(o2).pipe(map((x2) => currentValue = x2), share({ resetOnRefCountZero: () => timer(1e3) }));
  const rv = new Observable((observer) => {
    let didEmit = false;
    const subscription = shared.subscribe({
      next(value) {
        didEmit = true;
        observer.next(value);
      },
      error(error) {
        observer.error(error);
      },
      complete() {
        observer.complete();
      }
    });
    if (!didEmit && !subscription.closed) {
      observer.next(currentValue);
    }
    return subscription;
  });
  rv.getValue = () => currentValue;
  return rv;
}
var getGlobalRolesObservable = associate((db) => {
  return createSharedValueObservable(liveQuery(() => db.roles.where({ realmId: "rlm-public" }).toArray().then((roles) => {
    const rv = {};
    for (const role of roles.slice().sort((a2, b) => (a2.sortOrder || 0) - (b.sortOrder || 0))) {
      rv[role.name] = role;
    }
    return rv;
  })), {});
});
var getInternalAccessControlObservable = associate((db) => {
  return createSharedValueObservable(getCurrentUserEmitter(db._novip).pipe(switchMap((currentUser) => liveQuery(() => db.transaction("r", "realms", "members", () => Promise.all([
    db.members.where({ userId: currentUser.userId }).toArray(),
    db.realms.toArray(),
    currentUser.userId
  ]).then(([selfMembers, realms, userId]) => {
    return { selfMembers, realms, userId };
  }))))), {
    selfMembers: [],
    realms: [],
    get userId() {
      return db.cloud.currentUserId;
    }
  });
});
function mapValueObservable(o2, mapper) {
  let currentValue;
  const rv = o2.pipe(map((x2) => currentValue = mapper(x2)));
  rv.getValue = () => currentValue !== void 0 ? currentValue : currentValue = mapper(o2.getValue());
  return rv;
}
function mergePermissions(...permissions2) {
  if (permissions2.length === 0)
    return {};
  const reduced = permissions2.reduce((result, next) => {
    const ret = Object.assign({}, result);
    for (const [verb, rights] of Object.entries(next)) {
      if (verb in ret && ret[verb]) {
        if (ret[verb] === "*")
          continue;
        if (rights === "*") {
          ret[verb] = "*";
        } else if (Array.isArray(rights) && Array.isArray(ret[verb])) {
          const r2 = ret;
          const retVerb = r2[verb];
          r2[verb] = [.../* @__PURE__ */ new Set([...retVerb, ...rights])];
        } else if (typeof rights === "object" && rights && typeof ret[verb] === "object") {
          const mergedRights = ret[verb];
          for (const [tableName, tableRights] of Object.entries(rights)) {
            if (mergedRights[tableName] === "*")
              continue;
            if (tableRights === "*") {
              mergedRights[tableName] = "*";
            } else if (Array.isArray(mergedRights[tableName]) && Array.isArray(tableRights)) {
              mergedRights[tableName] = [
                .../* @__PURE__ */ new Set([...mergedRights[tableName], ...tableRights])
              ];
            }
          }
        }
      } else {
        ret[verb] = next[verb];
      }
    }
    return ret;
  });
  return reduced;
}
var getPermissionsLookupObservable = associate((db) => {
  const o2 = createSharedValueObservable(combineLatest([
    getInternalAccessControlObservable(db._novip),
    getGlobalRolesObservable(db._novip)
  ]).pipe(map(([{ selfMembers, realms, userId }, globalRoles]) => ({
    selfMembers,
    realms,
    userId,
    globalRoles
  }))), {
    selfMembers: [],
    realms: [],
    userId: UNAUTHORIZED_USER.userId,
    globalRoles: {}
  });
  return mapValueObservable(o2, ({ selfMembers, realms, userId, globalRoles }) => {
    const rv = realms.map((realm) => {
      const selfRealmMembers = selfMembers.filter((m2) => m2.realmId === realm.realmId);
      const directPermissionSets = selfRealmMembers.map((m2) => m2.permissions).filter((p2) => p2);
      const rolePermissionSets = flatten(selfRealmMembers.map((m2) => m2.roles).filter((roleName) => roleName)).map((role) => globalRoles[role]).filter((role) => role).map((role) => role.permissions);
      return Object.assign(Object.assign({}, realm), { permissions: realm.owner === userId ? { manage: "*" } : mergePermissions(...directPermissionSets, ...rolePermissionSets) });
    }).reduce((p2, c2) => Object.assign(Object.assign({}, p2), { [c2.realmId]: c2 }), {
      [userId]: {
        realmId: userId,
        owner: userId,
        name: userId,
        permissions: { manage: "*" }
      }
    });
    return rv;
  });
});
var PermissionChecker = class {
  constructor(permissions2, tableName, isOwner) {
    this.permissions = permissions2 || {};
    this.tableName = tableName;
    this.isOwner = isOwner;
  }
  add(...tableNames) {
    var _a;
    if (this.permissions.manage === "*")
      return true;
    if ((_a = this.permissions.manage) === null || _a === void 0 ? void 0 : _a.includes(this.tableName))
      return true;
    if (this.permissions.add === "*")
      return true;
    if (tableNames.every((tableName) => {
      var _a2;
      return (_a2 = this.permissions.add) === null || _a2 === void 0 ? void 0 : _a2.includes(tableName);
    })) {
      return true;
    }
    return false;
  }
  update(...props) {
    var _a, _b;
    if (this.isOwner || this.permissions.manage === "*")
      return true;
    if ((_a = this.permissions.manage) === null || _a === void 0 ? void 0 : _a.includes(this.tableName))
      return true;
    if (this.permissions.update === "*") {
      return props.every((prop) => prop !== "owner");
    }
    const tablePermissions = (_b = this.permissions.update) === null || _b === void 0 ? void 0 : _b[this.tableName];
    if (tablePermissions === "*")
      return props.every((prop) => prop !== "owner");
    return props.every((prop) => tablePermissions === null || tablePermissions === void 0 ? void 0 : tablePermissions.some((permittedProp) => permittedProp === prop || permittedProp === "*" && prop !== "owner"));
  }
  delete() {
    var _a;
    if (this.isOwner || this.permissions.manage === "*")
      return true;
    if ((_a = this.permissions.manage) === null || _a === void 0 ? void 0 : _a.includes(this.tableName))
      return true;
    return false;
  }
};
function permissions(dexie, obj, tableName) {
  if (!obj)
    throw new TypeError(`Cannot check permissions of undefined or null. A Dexie Cloud object with realmId and owner expected.`);
  const { owner, realmId } = obj;
  if (!tableName) {
    if (typeof obj.table !== "function") {
      throw new TypeError(`Missing 'table' argument to permissions and table could not be extracted from entity`);
    }
    tableName = obj.table();
  }
  const source = getPermissionsLookupObservable(dexie);
  const mapper = (permissionsLookup) => {
    const realm = permissionsLookup[realmId || dexie.cloud.currentUserId];
    if (!realm)
      return new PermissionChecker({}, tableName, !owner || owner === dexie.cloud.currentUserId);
    return new PermissionChecker(realm.permissions, tableName, realmId === void 0 || realmId === dexie.cloud.currentUserId || owner === dexie.cloud.currentUserId);
  };
  const o2 = source.pipe(map(mapper));
  o2.getValue = () => mapper(source.getValue());
  return o2;
}
var getInvitesObservable = associate((db) => {
  const membersByEmail = getCurrentUserEmitter(db._novip).pipe(switchMap((currentUser) => liveQuery(() => db.members.where({ email: currentUser.email || "" }).toArray())));
  const permissions2 = getPermissionsLookupObservable(db._novip);
  const accessControl = getInternalAccessControlObservable(db._novip);
  return createSharedValueObservable(combineLatest([membersByEmail, accessControl, permissions2]).pipe(map(([membersByEmail2, accessControl2, realmLookup]) => {
    const reducer = (result, m2) => Object.assign(Object.assign({}, result), { [m2.id]: Object.assign(Object.assign({}, m2), { realm: realmLookup[m2.realmId] }) });
    const emailMembersById = membersByEmail2.reduce(reducer, {});
    const membersById = accessControl2.selfMembers.reduce(reducer, emailMembersById);
    return Object.values(membersById).filter((invite) => !invite.accepted).map((invite) => Object.assign(Object.assign({}, invite), {
      accept() {
        return __awaiter2(this, void 0, void 0, function* () {
          yield db.members.update(invite.id, { accepted: /* @__PURE__ */ new Date() });
        });
      },
      reject() {
        return __awaiter2(this, void 0, void 0, function* () {
          yield db.members.update(invite.id, { rejected: /* @__PURE__ */ new Date() });
        });
      }
    }));
  })), []);
});
function createYHandler(db) {
  return (provider) => {
    var _a;
    const doc2 = provider.doc;
    if (!doc2) {
      throw new Error("Internal error: DexieYProvider.createYHandler called without a doc. This is unexpected.");
    }
    const { parentTable } = doc2.meta || {};
    if (!((_a = db.cloud.schema) === null || _a === void 0 ? void 0 : _a[parentTable].markedForSync)) {
      return;
    }
    let awareness;
    Object.defineProperty(provider, "awareness", {
      get() {
        if (awareness)
          return awareness;
        awareness = createAwareness(db, doc2, provider);
        awarenessWeakMap.set(doc2, awareness);
        return awareness;
      }
    });
  };
}
function createAwareness(db, doc2, provider) {
  const { parentTable, parentId, parentProp, updatesTable } = doc2.meta;
  const awareness = new Awareness(doc2);
  const reopenDocSignal = getOpenDocSignal(doc2);
  awareness.on("update", ({ added, updated, removed }, origin) => {
    const changedClients = added.concat(updated).concat(removed);
    const user = db.cloud.currentUser.value;
    if (origin !== "server" && user.isLoggedIn && !isEagerSyncDisabled(db)) {
      const update = encodeAwarenessUpdate(awareness, changedClients);
      db.messageProducer.next({
        type: "aware",
        table: parentTable,
        prop: parentProp,
        k: doc2.meta.parentId,
        u: update
      });
      if (provider.destroyed) {
        db.messageProducer.next({
          type: "doc-close",
          table: parentTable,
          prop: parentProp,
          k: doc2.meta.parentId
        });
      }
    }
  });
  awareness.on("destroy", () => {
    removeAwarenessStates(awareness, [doc2.clientID], "provider destroyed");
  });
  (() => __awaiter2(this, void 0, void 0, function* () {
    if (provider.destroyed)
      return;
    let connected = false;
    let currentFlowId = 1;
    const subscription = combineLatest([
      db.cloud.webSocketStatus,
      // Wake up when webSocket status changes
      reopenDocSignal.pipe(startWith(null))
      // Wake up when reopenDocSignal emits
    ]).subscribe(([wsStatus]) => {
      if (provider.destroyed)
        return;
      connected = wsStatus === "connected";
      const user = db.cloud.currentUser.value;
      if (wsStatus === "connected" && user.isLoggedIn && !isEagerSyncDisabled(db)) {
        ++currentFlowId;
        openDocumentOnServer().catch((error) => {
          console.warn(`Error catched in createYHandler.ts: ${error}`);
        });
      }
    });
    provider.addCleanupHandler(subscription);
    function openDocumentOnServer() {
      return __awaiter2(this, void 0, void 0, function* () {
        const myFlow = currentFlowId;
        const yTbl = db.table(updatesTable);
        const syncStateTbl = db.$syncState;
        const [receivedUntil, yServerRev] = yield db.transaction("r", syncStateTbl, yTbl, () => __awaiter2(this, void 0, void 0, function* () {
          const syncState = yield yTbl.get(DEXIE_CLOUD_SYNCER_ID);
          const persistedSyncState = yield syncStateTbl.get("syncState");
          return [
            (syncState === null || syncState === void 0 ? void 0 : syncState.receivedUntil) || 0,
            (persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.yServerRevision) || (persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.serverRevision)
          ];
        }));
        if (provider.destroyed || currentFlowId !== myFlow || !connected)
          return;
        const docOpenMsg = {
          type: "doc-open",
          table: parentTable,
          prop: parentProp,
          k: parentId,
          serverRev: yServerRev
        };
        const serverUpdatesSinceLastSync = yield yTbl.where("i").between(receivedUntil, Infinity, false).filter(
          (update) => cmp(update.k, parentId) === 0 && // Only updates for this document
          ((update.f || 0) & 1) === 0
          // Don't include local changes
        ).toArray();
        if (provider.destroyed || currentFlowId !== myFlow || !connected)
          return;
        if (serverUpdatesSinceLastSync.length > 0) {
          const mergedUpdate = mergeUpdatesV2(serverUpdatesSinceLastSync.map((update) => update.u));
          const stateVector = encodeStateVectorFromUpdateV2(mergedUpdate);
          docOpenMsg.sv = stateVector;
        }
        db.messageProducer.next(docOpenMsg);
      });
    }
  }))();
  return awareness;
}
function getTiedRealmId(objectId) {
  return "rlm~" + objectId;
}
function getTiedObjectId(realmId) {
  return realmId.startsWith("rlm~") ? realmId.substr(4) : null;
}
var ydocTriggers = {};
var middlewares = /* @__PURE__ */ new WeakMap();
var txRunner = TriggerRunner("tx");
var unloadRunner = TriggerRunner("unload");
function TriggerRunner(name) {
  let triggerExecPromise = null;
  let triggerScheduled = false;
  let registry = /* @__PURE__ */ new Map();
  function execute(registryCopy) {
    return __awaiter2(this, void 0, void 0, function* () {
      for (const { db, parentId, triggers, parentTable, prop } of registryCopy.values()) {
        const yDoc = DexieYProvider.getOrCreateDocument(db, parentTable, prop, parentId);
        try {
          const provider = DexieYProvider.load(yDoc);
          yield provider.whenLoaded;
          for (const trigger of triggers) {
            yield trigger(yDoc, parentId);
          }
        } catch (error) {
          if ((error === null || error === void 0 ? void 0 : error.name) === "AbortError") ;
          else {
            console.error(`Error in YDocTrigger ${error}`);
          }
        } finally {
          DexieYProvider.release(yDoc);
        }
      }
    });
  }
  return {
    name,
    run() {
      return __awaiter2(this, void 0, void 0, function* () {
        console.log(`Running trigger (${name})?`, triggerScheduled, registry.size, !!triggerExecPromise);
        if (!triggerScheduled && registry.size > 0) {
          triggerScheduled = true;
          if (triggerExecPromise)
            yield triggerExecPromise.catch(() => {
            });
          setTimeout(() => {
            console.log("Running trigger really!", name);
            triggerScheduled = false;
            const registryCopy = registry;
            registry = /* @__PURE__ */ new Map();
            triggerExecPromise = execute(registryCopy).finally(() => {
              triggerExecPromise = null;
            });
          }, 0);
        }
      });
    },
    enqueue(db, parentTable, parentId, prop, trigger) {
      const key = `${db.name}:${parentTable}:${parentId}:${prop}`;
      let entry = registry.get(key);
      if (!entry) {
        entry = {
          db,
          parentTable,
          parentId,
          prop,
          triggers: /* @__PURE__ */ new Set()
        };
        console.log(`Adding trigger ${key}`);
        registry.set(key, entry);
      }
      entry.triggers.add(trigger);
    }
  };
}
var createMiddleware = (db) => ({
  stack: "dbcore",
  level: 10,
  name: "yTriggerMiddleware",
  create: (down) => {
    return Object.assign(Object.assign({}, down), { transaction: (stores, mode, options) => {
      const idbtrans = down.transaction(stores, mode, options);
      if (mode === "readonly")
        return idbtrans;
      if (!stores.some((store) => ydocTriggers[store]))
        return idbtrans;
      idbtrans.addEventListener("complete", onTransactionCommitted);
      return idbtrans;
    }, table: (updatesTable) => {
      const coreTable = down.table(updatesTable);
      const triggerSpec = ydocTriggers[updatesTable];
      if (!triggerSpec)
        return coreTable;
      const { trigger, parentTable, prop } = triggerSpec;
      return Object.assign(Object.assign({}, coreTable), { mutate(req) {
        var _a;
        switch (req.type) {
          case "add": {
            for (const yUpdateRow of req.values) {
              if (yUpdateRow.k == void 0)
                continue;
              const primaryKey = yUpdateRow.k;
              const doc2 = DexieYProvider.getDocCache(db).find(parentTable, primaryKey, prop);
              const runner = doc2 && ((_a = DexieYProvider.for(doc2)) === null || _a === void 0 ? void 0 : _a.refCount) ? unloadRunner : txRunner;
              runner.enqueue(db, parentTable, primaryKey, prop, trigger);
            }
            break;
          }
          case "delete":
            if (req.trans._rejecting_y_ypdate) {
              coreTable.getMany({
                keys: req.keys,
                trans: req.trans,
                cache: "immutable"
              }).then((updates) => {
                const keySet = new RangeSet();
                for (const { k: k2 } of updates) {
                  if (k2 != void 0)
                    keySet.addKey(k2);
                }
                for (const interval2 of keySet) {
                  txRunner.enqueue(db, parentTable, interval2.from, prop, trigger);
                }
              });
            }
            break;
        }
        return coreTable.mutate(req);
      } });
    } });
  }
});
function onTransactionCommitted() {
  txRunner.run();
}
function beforeProviderUnload() {
  unloadRunner.run();
}
function defineYDocTrigger(table, prop, trigger) {
  var _a, _b;
  const updatesTable = (_b = (_a = table.schema.yProps) === null || _a === void 0 ? void 0 : _a.find((p2) => p2.prop === prop)) === null || _b === void 0 ? void 0 : _b.updatesTable;
  if (!updatesTable)
    throw new Error(`Table ${table.name} does not have a Yjs property named ${prop}`);
  ydocTriggers[updatesTable] = {
    trigger,
    parentTable: table.name,
    prop
  };
  const db = table.db._novip;
  let mw = middlewares.get(db);
  if (!mw) {
    mw = createMiddleware(db);
    middlewares.set(db, mw);
  }
  db.use(mw);
  {
    DexieYProvider.on("beforeunload", beforeProviderUnload);
  }
}
var DEFAULT_OPTIONS = {
  nameSuffix: true
};
function dexieCloud(dexie) {
  const origIdbName = dexie.name;
  const currentUserEmitter = getCurrentUserEmitter(dexie);
  const subscriptions = [];
  let configuredProgramatically = false;
  let localSyncWorker = null;
  dexie.on(
    "ready",
    (dexie2) => __awaiter2(this, void 0, void 0, function* () {
      try {
        yield onDbReady(dexie2);
      } catch (error) {
        console.error(error);
      }
    }),
    true
    // true = sticky
  );
  let closed = false;
  function throwIfClosed() {
    if (closed)
      throw new import_wrapper_default.DatabaseClosedError();
  }
  dexie.once("close", () => {
    subscriptions.forEach((subscription) => subscription.unsubscribe());
    subscriptions.splice(0, subscriptions.length);
    closed = true;
    localSyncWorker && localSyncWorker.stop();
    localSyncWorker = null;
    currentUserEmitter.next(UNAUTHORIZED_USER);
  });
  const syncComplete = new Subject();
  dexie.cloud = {
    // @ts-ignore
    version: "4.2.5",
    options: Object.assign({}, DEFAULT_OPTIONS),
    schema: null,
    get currentUserId() {
      return currentUserEmitter.value.userId || UNAUTHORIZED_USER.userId;
    },
    currentUser: currentUserEmitter,
    syncState: new BehaviorSubject({
      phase: "initial",
      status: "not-started"
    }),
    events: {
      syncComplete
    },
    persistedSyncState: new BehaviorSubject(void 0),
    userInteraction: new BehaviorSubject(void 0),
    webSocketStatus: new BehaviorSubject("not-started"),
    login(hint) {
      return __awaiter2(this, void 0, void 0, function* () {
        const db = DexieCloudDB(dexie);
        yield db.cloud.sync();
        yield login(db, hint);
      });
    },
    invites: getInvitesObservable(dexie),
    roles: getGlobalRolesObservable(dexie),
    configure(options) {
      options = dexie.cloud.options = Object.assign(Object.assign({}, dexie.cloud.options), options);
      configuredProgramatically = true;
      if (options.databaseUrl && options.nameSuffix) {
        dexie.name = `${origIdbName}-${getDbNameFromDbUrl(options.databaseUrl)}`;
        DexieCloudDB(dexie).reconfigure();
      }
      updateSchemaFromOptions(dexie.cloud.schema, dexie.cloud.options);
    },
    logout() {
      return __awaiter2(this, arguments, void 0, function* ({ force } = {}) {
        force ? yield _logout(DexieCloudDB(dexie), { deleteUnsyncedData: true }) : yield logout(DexieCloudDB(dexie));
      });
    },
    sync() {
      return __awaiter2(this, arguments, void 0, function* ({ wait, purpose } = { wait: true, purpose: "push" }) {
        var _a;
        if (wait === void 0)
          wait = true;
        const db = DexieCloudDB(dexie);
        const licenseStatus = ((_a = db.cloud.currentUser.value.license) === null || _a === void 0 ? void 0 : _a.status) || "ok";
        if (licenseStatus !== "ok") {
          yield loadAccessToken(db);
        }
        if (purpose === "pull") {
          const syncState = db.cloud.persistedSyncState.value;
          triggerSync(db, purpose);
          if (wait) {
            const newSyncState = yield firstValueFrom(db.cloud.persistedSyncState.pipe(filter((newSyncState2) => (newSyncState2 === null || newSyncState2 === void 0 ? void 0 : newSyncState2.timestamp) != null && (!syncState || newSyncState2.timestamp > syncState.timestamp))));
            if (newSyncState === null || newSyncState === void 0 ? void 0 : newSyncState.error) {
              throw new Error(`Sync error: ` + newSyncState.error);
            }
          }
        } else if (yield isSyncNeeded(db)) {
          const syncState = db.cloud.persistedSyncState.value;
          triggerSync(db, purpose);
          if (wait) {
            console.debug("db.cloud.login() is waiting for sync completion...");
            yield firstValueFrom(from3(liveQuery(() => __awaiter2(this, void 0, void 0, function* () {
              const syncNeeded = yield isSyncNeeded(db);
              const newSyncState = yield db.getPersistedSyncState();
              if ((newSyncState === null || newSyncState === void 0 ? void 0 : newSyncState.timestamp) !== (syncState === null || syncState === void 0 ? void 0 : syncState.timestamp) && (newSyncState === null || newSyncState === void 0 ? void 0 : newSyncState.error))
                throw new Error(`Sync error: ` + newSyncState.error);
              return syncNeeded;
            }))).pipe(filter((isNeeded) => !isNeeded)));
            console.debug("Done waiting for sync completion because we have nothing to push anymore");
          }
        }
      });
    },
    permissions(obj, tableName) {
      return permissions(dexie._novip, obj, tableName);
    }
  };
  dexie.Version.prototype["_parseStoresSpec"] = import_wrapper_default.override(dexie.Version.prototype["_parseStoresSpec"], (origFunc) => overrideParseStoresSpec(origFunc, dexie));
  dexie.Table.prototype.newId = function({ colocateWith } = {}) {
    const shardKey = colocateWith && colocateWith.substr(colocateWith.length - 3);
    return generateKey(dexie.cloud.schema[this.name].idPrefix || "", shardKey);
  };
  dexie.Table.prototype.idPrefix = function() {
    var _a, _b;
    return ((_b = (_a = this.db.cloud.schema) === null || _a === void 0 ? void 0 : _a[this.name]) === null || _b === void 0 ? void 0 : _b.idPrefix) || "";
  };
  dexie.use(createMutationTrackingMiddleware({
    currentUserObservable: dexie.cloud.currentUser,
    db: DexieCloudDB(dexie)
  }));
  dexie.use(createImplicitPropSetterMiddleware(DexieCloudDB(dexie)));
  dexie.use(createIdGenerationMiddleware(DexieCloudDB(dexie)));
  function onDbReady(dexie2) {
    return __awaiter2(this, void 0, void 0, function* () {
      var _a, _b, _c, _d, _e, _f, _g;
      closed = false;
      const db = DexieCloudDB(dexie2);
      if (typeof window !== "undefined" && typeof document !== "undefined") {
        if (!((_a = db.cloud.options) === null || _a === void 0 ? void 0 : _a.customLoginGui)) {
          subscriptions.push(setupDefaultGUI(dexie2));
        }
      }
      if (!db.cloud.isServiceWorkerDB) {
        subscriptions.push(computeSyncState(db).subscribe(dexie2.cloud.syncState));
      }
      subscriptions.push(db.syncCompleteEvent.subscribe(syncComplete));
      if (!db.tables.every((table) => table.core)) {
        throwVersionIncrementNeeded();
      }
      const swRegistrations = "serviceWorker" in navigator ? yield navigator.serviceWorker.getRegistrations() : [];
      const [initiallySynced, lastSyncedRealms] = yield db.transaction("rw", db.$syncState, () => __awaiter2(this, void 0, void 0, function* () {
        var _a2, _b2;
        const { options, schema } = db.cloud;
        const [persistedOptions, persistedSchema, persistedSyncState] = yield Promise.all([
          db.getOptions(),
          db.getSchema(),
          db.getPersistedSyncState()
        ]);
        if (!configuredProgramatically) {
          db.cloud.options = persistedOptions || null;
        } else if (!persistedOptions || JSON.stringify(persistedOptions) !== JSON.stringify(options)) {
          if (!options)
            throw new Error(`Internal error`);
          const newPersistedOptions = Object.assign({}, options);
          delete newPersistedOptions.fetchTokens;
          delete newPersistedOptions.awarenessProtocol;
          yield db.$syncState.put(newPersistedOptions, "options");
        }
        if (((_a2 = db.cloud.options) === null || _a2 === void 0 ? void 0 : _a2.tryUseServiceWorker) && "serviceWorker" in navigator && swRegistrations.length > 0 && !DISABLE_SERVICEWORKER_STRATEGY) {
          console.debug("Dexie Cloud Addon: Using service worker");
          db.cloud.usingServiceWorker = true;
        } else {
          if (((_b2 = db.cloud.options) === null || _b2 === void 0 ? void 0 : _b2.tryUseServiceWorker) && !db.cloud.isServiceWorkerDB) {
            console.debug("dexie-cloud-addon: Not using service worker.", swRegistrations.length === 0 ? "No SW registrations found." : "serviceWorker" in navigator && DISABLE_SERVICEWORKER_STRATEGY ? "Avoiding SW background sync and SW periodic bg sync for this browser due to browser bugs." : "navigator.serviceWorker not present");
          }
          db.cloud.usingServiceWorker = false;
        }
        updateSchemaFromOptions(schema, db.cloud.options);
        updateSchemaFromOptions(persistedSchema, db.cloud.options);
        if (!schema) {
          db.cloud.schema = persistedSchema || null;
        } else if (!persistedSchema || JSON.stringify(persistedSchema) !== JSON.stringify(schema)) {
          const newPersistedSchema = persistedSchema || {};
          for (const [table, tblSchema] of Object.entries(schema)) {
            const newTblSchema = newPersistedSchema[table];
            if (!newTblSchema) {
              newPersistedSchema[table] = Object.assign({}, tblSchema);
            } else {
              newTblSchema.markedForSync = tblSchema.markedForSync;
              tblSchema.deleted = newTblSchema.deleted;
              newTblSchema.generatedGlobalId = tblSchema.generatedGlobalId;
            }
          }
          yield db.$syncState.put(newPersistedSchema, "schema");
          Object.assign(schema, newPersistedSchema);
        }
        return [persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.initiallySynced, persistedSyncState === null || persistedSyncState === void 0 ? void 0 : persistedSyncState.realms];
      }));
      if (initiallySynced) {
        db.setInitiallySynced(true);
      }
      verifySchema(db);
      throwIfClosed();
      if (!db.cloud.isServiceWorkerDB) {
        subscriptions.push(liveQuery(() => db.getCurrentUser()).subscribe(currentUserEmitter));
        subscriptions.push(liveQuery(() => db.getPersistedSyncState()).subscribe(db.cloud.persistedSyncState));
        yield firstValueFrom(combineLatest([
          currentUserEmitter.pipe(skip(1), take(1)),
          db.cloud.persistedSyncState.pipe(skip(1), take(1))
        ]));
        const yHandler = createYHandler(db);
        DexieYProvider.on.new.subscribe(yHandler);
        db.dx.once("close", () => {
          DexieYProvider.on.new.unsubscribe(yHandler);
        });
      }
      let changedUser = false;
      const user = yield db.getCurrentUser();
      const requireAuth = (_b = db.cloud.options) === null || _b === void 0 ? void 0 : _b.requireAuth;
      if (requireAuth) {
        if (db.cloud.isServiceWorkerDB) {
          console.debug("Dexie Cloud Service worker. Waiting for application to authenticate.");
          yield firstValueFrom(currentUserEmitter.pipe(filter((user2) => !!user2.isLoggedIn), take(1)));
          console.debug("Dexie Cloud Service worker. Application has authenticated.");
        } else {
          if (typeof requireAuth === "object") {
            if (!user.isLoggedIn || requireAuth.userId && user.userId !== requireAuth.userId || requireAuth.email && user.email !== requireAuth.email) {
              changedUser = yield login(db, requireAuth);
            }
          } else if (!user.isLoggedIn) {
            changedUser = yield login(db);
          }
        }
      }
      if (user.isLoggedIn && (!lastSyncedRealms || !lastSyncedRealms.includes(user.userId))) {
        changedUser = true;
      }
      if (localSyncWorker)
        localSyncWorker.stop();
      localSyncWorker = null;
      throwIfClosed();
      const doInitialSync = ((_c = db.cloud.options) === null || _c === void 0 ? void 0 : _c.databaseUrl) && (!initiallySynced || changedUser);
      if (doInitialSync) {
        yield performInitialSync(db, db.cloud.options, db.cloud.schema);
        db.setInitiallySynced(true);
      }
      throwIfClosed();
      if (db.cloud.usingServiceWorker && ((_d = db.cloud.options) === null || _d === void 0 ? void 0 : _d.databaseUrl)) {
        if (!doInitialSync) {
          registerSyncEvent(db, "push").catch(() => {
          });
        }
        registerPeriodicSyncEvent(db).catch(() => {
        });
      } else if (((_e = db.cloud.options) === null || _e === void 0 ? void 0 : _e.databaseUrl) && db.cloud.schema && !db.cloud.isServiceWorkerDB) {
        localSyncWorker = LocalSyncWorker(db, db.cloud.options, db.cloud.schema);
        localSyncWorker.start();
        if (!doInitialSync) {
          triggerSync(db, "push");
        }
      }
      throwIfClosed();
      if (!db.cloud.isServiceWorkerDB) {
        subscriptions.push(fromEvent(self, "online").subscribe(() => {
          console.debug("online!");
          db.syncStateChangedEvent.next({
            phase: "not-in-sync"
          });
          if (!isEagerSyncDisabled(db)) {
            triggerSync(db, "push");
          }
        }), fromEvent(self, "offline").subscribe(() => {
          console.debug("offline!");
          db.syncStateChangedEvent.next({
            phase: "offline"
          });
        }));
      }
      if (((_f = db.cloud.options) === null || _f === void 0 ? void 0 : _f.databaseUrl) && !((_g = db.cloud.options) === null || _g === void 0 ? void 0 : _g.disableWebSocket) && !IS_SERVICE_WORKER) {
        subscriptions.push(connectWebSocket(db));
      }
    });
  }
}
dexieCloud.version = "4.2.5";
import_wrapper_default.Cloud = dexieCloud;
export {
  dexieCloud as default,
  defineYDocTrigger,
  dexieCloud,
  getTiedObjectId,
  getTiedRealmId,
  resolveText
};
//# sourceMappingURL=dexie-cloud-addon.js.map
